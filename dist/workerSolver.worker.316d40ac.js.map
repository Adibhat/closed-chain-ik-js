{"version":3,"sources":["../src/core/utils/solver.js","../node_modules/linear-solve/gauss-jordan.js","../node_modules/svd-js/build-umd/svd-js.min.js","../src/core/utils/matrix.js","../src/core/ChainSolver.js","../src/core/MatrixPool.js","../src/core/Solver.js","../src/core/Goal.js","../src/worker/serialize.js","../src/worker/utils.js","../src/worker/workerSolver.worker.js"],"names":["tempPos","Float64Array","tempQuat","tempEuler","accumulateClosureError","solver","joint","startIndex","errorVector","result","isConverged","rowCount","totalError","translationConvergeThreshold","rotationConvergeThreshold","translationErrorClamp","rotationErrorClamp","translationFactor","rotationFactor","translationDoFCount","rotationDoFCount","dofFlags","dof","getClosureError","isGoal","posMag","vec3","length","rotMag","vec4","scale","i","d","accumulateTargetError","lockedJointDoFCount","lockedJointDoF","dofTarget","dofValues","dofList","posDelta","distance","rotDelta","DOF","EX","EY","EZ","lockedDoFCount","get","lockedDoF","isLocked","rowIndex","l","eulerMag","transpose","outMatrix","a","tr","tc","r","c","identity","matrix","scalar","multiply","b","Error","m","n","k","sum","ti","create","row","col","Array","copy","sourceMatrix","clone","rows","resultMatrix","solve","vector","res","linearSolve","set","svd","ru","rq","rv","u","v","q","urows","vrows","qrows","rqrow","qval","fill","invert","add","subtract","magnitudeSquared","cols","magnitude","Math","sqrt","toString","dec","str","toFixed","log","console","mat","targetRelativeToJointMatrix","targetDeltaWorldMatrix","tempDeltaWorldMatrix","tempInverseMatrixWorld","tempQuat2","tempPos2","targetJoints","freeJoints","errorResultInfo","dofResultInfo","errorRows","freeDoF","SOLVE_STATUS","CONVERGED","STALLED","DIVERGED","TIMEOUT","SOLVE_STATUS_NAMES","Object","entries","sort","map","el","ChainSolver","chain","from","targets","affectedClosures","affectedConnectedClosures","prevDoFValues","maxIterations","matrixPool","useSVD","translationStep","rotationStep","stallThreshold","dampingFactor","divergeThreshold","restPoseFactor","init","filter","j","targetSet","isClosure","Map","forEach","Set","Uint8Array","target","currJoint","isJoint","parent","child","iterations","prevErrorMagnitude","Infinity","status","clear","restPoseSet","tryMinimizeEulerAngles","releaseAll","updateMatrixWorld","countUnconvergedVariables","setMatrixDoFNeedsUpdate","fillErrorVector","jacobian","fillJacobian","pseudoInverse","failedSVD","min","uTranspose","qInverse","val","inv","abs","vqinv","err","jacobianIdentityDamping","jacobianTranspose","jjt","jjti","jjtii","deltaTheta","restPose","restPoseResult","colIndex","colCount","dofRestPose","jij","ident","nullSpaceProjection","stalled","delta","applyJointAngles","lockedJoint","dti","has","value","getDoFValue","hitLimit","setDoFValue","lockedCount","outJacobian","freeJoint","relevantClosures","relevantConnectedClosures","matrixWorld","co","getDeltaWorldMatrix","targetJoint","totalRows","unconvergedRows","addToTargetList","push","FixedMatrixPool","matrices","index","MatrixPool","pools","poolArray","colPools","pool","Solver","roots","isArray","solvers","updateStructure","chains","traversal","allChainJoints","traverseChains","frame","curr","chainSet","children","delete","independentChains","currChain","pop","otherChain","dependent","splice","nonChainJoints","root","traverse","results","s","Joint","Goal","args","setFreeDoF","rotCount","Number","includes","setDoF","X","Y","Z","serialize","frames","info","name","minDoFLimit","maxDoFLimit","position","quaternion","type","slice","closureJoints","inf","isLink","deserialize","data","Link","setMatrixNeedsUpdate","JOINT_STRIDE","LINK_STRIDE","generateSharedBuffer","useSharedArrayBuffer","arrayBuffer","SharedArrayBuffer","ArrayBuffer","applyToBuffer","Float32Array","floatBuffer","byteBuffer","copyDoFValues","copyJointSettings","copyFrameToBuffer","applyFromBuffer","copyBufferToFrame","byteOffset","floatOffset","setPosition","setQuaternion","Boolean","changed","useSharedArrayBuffers","solveHandle","buffer","updateSolve","find","setTimeout","postMessage","resultsBuffer","global","onmessage","e","serialized","f","assign","clearTimeout"],"mappings":"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MAAA,GAAA,KAAA,GAAA,IAAA,EAAA,EAAA,IAAA,MAAA,GAAA,KAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,KAAA,IAAA,EAAA,GAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IAAA,GAAA,EAAA,EAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,KAAA,IAAA,KAAA,KAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,KAAA,IAAA,EAAA,GAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,MAAA,CAAA,IAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,KAAA,IAAA,KAAA,KAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,IAAA,GAAA,EAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,OAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,CAAA,GAAA,MAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,OAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,GAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,IAAA,IAAA,EAAA,EAAA,EAAA,GAAA,IAAA,CAAA,IAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAAA,GAAA,KAAA,IAAA,EAAA,KAAA,EAAA,CAAA,GAAA,EAAA,MAAA,GAAA,KAAA,IAAA,EAAA,EAAA,KAAA,EAAA,MAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,KAAA,KAAA,IAAA,IAAA,IAAA,IAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAAA,KAAA,KAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,EAAA,CAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,IAAA,EAAA,GAAA,GAAA,MAAA,IAAA,EAAA,EAAA,GAAA,KAAA,EAAA,EAAA,EAAA,IAAA,IAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,MAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,KAAA,KAAA,EAAA,EAAA,GAAA,IAAA,EAAA,IAAA,EAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAAA,CAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KAAA,KAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,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","file":"workerSolver.worker.316d40ac.js","sourceRoot":"..\\example","sourcesContent":["import { vec3, vec4 } from 'gl-matrix';\r\nimport { DOF } from '../Joint.js';\r\n\r\nconst tempPos = new Float64Array( 3 );\r\nconst tempQuat = new Float64Array( 4 );\r\nconst tempEuler = new Float64Array( 3 );\r\nexport function accumulateClosureError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\tdofFlags,\r\n\t\tdof,\r\n\t} = joint;\r\n\r\n\t// Get the error from child towards the closure target\r\n\tjoint.getClosureError( tempPos, tempQuat );\r\n\r\n\tlet rowCount = 7;\r\n\tif ( joint.isGoal ) {\r\n\r\n\t\ttempPos[ 0 ] *= dofFlags[ 0 ];\r\n\t\ttempPos[ 1 ] *= dofFlags[ 1 ];\r\n\t\ttempPos[ 2 ] *= dofFlags[ 2 ];\r\n\t\trowCount = translationDoFCount;\r\n\r\n\t\tif ( rotationDoFCount === 0 ) {\r\n\r\n\t\t\ttempQuat[ 0 ] = 0;\r\n\t\t\ttempQuat[ 1 ] = 0;\r\n\t\t\ttempQuat[ 2 ] = 0;\r\n\t\t\ttempQuat[ 3 ] = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trowCount += 4;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tlet isConverged = false;\r\n\tlet totalError = 0;\r\n\tconst posMag = vec3.length( tempPos );\r\n\tconst rotMag = vec4.length( tempQuat );\r\n\tif (\r\n\t\tposMag < translationConvergeThreshold &&\r\n\t\trotMag < rotationConvergeThreshold\r\n\t) {\r\n\r\n\t\tisConverged = true;\r\n\r\n\t}\r\n\r\n\ttotalError += posMag + rotMag;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tif ( posMag > translationErrorClamp ) {\r\n\r\n\t\t\tvec3.scale( tempPos, tempPos, translationErrorClamp / posMag );\r\n\r\n\t\t}\r\n\r\n\t\tvec4.scale( tempPos, tempPos, translationFactor );\r\n\r\n\t\tif ( rotMag > rotationErrorClamp ) {\r\n\r\n\t\t\tvec4.scale( tempQuat, tempQuat, rotationErrorClamp / rotMag );\r\n\r\n\t\t}\r\n\r\n\t\tvec4.scale( tempQuat, tempQuat, rotationFactor );\r\n\r\n\t\tif ( joint.isGoal ) {\r\n\r\n\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\r\n\r\n\t\t\t\tconst d = dof[ i ];\r\n\t\t\t\terrorVector[ startIndex + i ][ 0 ] = tempPos[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joint.rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 0 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 1 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 2 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 3 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\terrorVector[ startIndex + 0 ][ 0 ] = tempPos[ 0 ];\r\n\t\t\terrorVector[ startIndex + 1 ][ 0 ] = tempPos[ 1 ];\r\n\t\t\terrorVector[ startIndex + 2 ][ 0 ] = tempPos[ 2 ];\r\n\r\n\t\t\terrorVector[ startIndex + 3 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\terrorVector[ startIndex + 4 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\terrorVector[ startIndex + 5 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\terrorVector[ startIndex + 6 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tresult.totalError = totalError;\r\n\tresult.isConverged = isConverged;\r\n\tresult.rowCount = rowCount;\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function accumulateTargetError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\t// Find whether or not the target has converged or not\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\tlockedJointDoFCount,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\tlockedJointDoF,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\tdofTarget,\r\n\t\tdofValues,\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t\tdofList,\r\n\t} = joint;\r\n\r\n\t// get the position delta\r\n\tconst posDelta = vec3.distance( dofValues, dofTarget );\r\n\r\n\t// TODO: if three euler angles are being used we should set this to a quaternion to measure\r\n\t// error rather than euler angles. We should instead just always use quaternions for targets\r\n\t// for now.\r\n\t// Before running this solver we try to ensure the target and restPose are minimized\r\n\tlet rotDelta =\r\n\t\tdofTarget[ DOF.EX ] - dofValues[ DOF.EX ] +\r\n\t\tdofTarget[ DOF.EY ] - dofValues[ DOF.EY ] +\r\n\t\tdofTarget[ DOF.EZ ] - dofValues[ DOF.EZ ];\r\n\r\n\t// Get the row count\r\n\tconst lockedDoFCount = lockedJointDoFCount.get( joint ) || 0;\r\n\tresult.rowCount = translationDoFCount + rotationDoFCount - lockedDoFCount;\r\n\tresult.isConverged = posDelta < translationConvergeThreshold && rotDelta < rotationConvergeThreshold;\r\n\tresult.totalError = posDelta + rotDelta;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tconst lockedDoF = lockedJointDoF.get( joint );\r\n\t\tconst isLocked = lockedDoFCount !== 0;\r\n\r\n\t\tlet rowIndex = 0;\r\n\r\n\t\t// error from current state to target\r\n\t\ttempPos[ 0 ] = dofTarget[ 0 ] - dofValues[ 0 ];\r\n\t\ttempPos[ 1 ] = dofTarget[ 1 ] - dofValues[ 1 ];\r\n\t\ttempPos[ 2 ] = dofTarget[ 2 ] - dofValues[ 2 ];\r\n\r\n\t\t// clamp the position delta to the max error step\r\n\t\tconst posMag = vec3.length( tempPos );\r\n\t\tvec3.scale( tempPos, tempPos, translationFactor * translationErrorClamp / posMag );\r\n\t\tfor ( let i = 0, l = translationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempPos[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// get the euler differences\r\n\t\t// before running this solver we minimize the euler targets\r\n\t\ttempEuler[ 0 ] = joint.dofTarget[ 3 ] - joint.dofValues[ 3 ];\r\n\t\ttempEuler[ 1 ] = joint.dofTarget[ 4 ] - joint.dofValues[ 4 ];\r\n\t\ttempEuler[ 2 ] = joint.dofTarget[ 5 ] - joint.dofValues[ 5 ];\r\n\r\n\t\t// clamp the euler difference to the error step magnitude\r\n\t\tconst eulerMag = vec3.length( tempEuler );\r\n\t\tvec3.scale( tempEuler, tempEuler, rotationFactor * rotationErrorClamp / eulerMag );\r\n\t\tfor ( let i = translationDoFCount, l = translationDoFCount + rotationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempEuler[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","/**\n * Gauss-Jordan elimination\n */\n\nvar linear = (function(){\n/**\n * Used internally to solve systems\n * If you want to solve A.x = B,\n * choose data=A and mirror=B.\n * mirror can be either an array representing a vector\n * or an array of arrays representing a matrix.\n */\nfunction Mat(data, mirror) {\n  // Clone the original matrix\n  this.data = new Array(data.length);\n  for (var i=0, cols=data[0].length; i<data.length; i++) {\n    this.data[i] = new Array(cols);\n    for(var j=0; j<cols; j++) {\n      this.data[i][j] = data[i][j];\n    }\n  }\n\n  if (mirror) {\n    if (typeof mirror[0] !== \"object\") {\n      for (var i=0; i<mirror.length; i++) {\n        mirror[i] = [mirror[i]];\n      }\n    }\n    this.mirror = new Mat(mirror);\n  }\n}\n\n/**\n * Swap lines i and j in the matrix\n */\nMat.prototype.swap = function (i, j) {\n  if (this.mirror) this.mirror.swap(i,j);\n  var tmp = this.data[i];\n  this.data[i] = this.data[j];\n  this.data[j] = tmp;\n}\n\n/**\n * Multiply line number i by l\n */\nMat.prototype.multline = function (i, l) {\n  if (this.mirror) this.mirror.multline(i,l);\n  var line = this.data[i];\n  for (var k=line.length-1; k>=0; k--) {\n    line[k] *= l;\n  }\n}\n\n/**\n * Add line number j multiplied by l to line number i\n */\nMat.prototype.addmul = function (i, j, l) {\n  if (this.mirror) this.mirror.addmul(i,j,l);\n  var lineI = this.data[i], lineJ = this.data[j];\n  for (var k=lineI.length-1; k>=0; k--) {\n    lineI[k] = lineI[k] + l*lineJ[k];\n  }\n}\n\n/**\n * Tests if line number i is composed only of zeroes\n */\nMat.prototype.hasNullLine = function (i) {\n  for (var j=0; j<this.data[i].length; j++) {\n    if (this.data[i][j] !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nMat.prototype.gauss = function() {\n  var pivot = 0,\n      lines = this.data.length,\n      columns = this.data[0].length,\n      nullLines = [];\n\n  for (var j=0; j<columns; j++) {\n    // Find the line on which there is the maximum value of column j\n    var maxValue = 0, maxLine = 0;\n    for (var k=pivot; k<lines; k++) {\n      var val = this.data[k][j];\n      if (Math.abs(val) > Math.abs(maxValue)) {\n        maxLine = k;\n        maxValue = val;\n      } \n    }\n    if (maxValue === 0) {\n      // The matrix is not invertible. The system may still have solutions.\n      nullLines.push(pivot);\n    } else {\n      // The value of the pivot is maxValue\n      this.multline(maxLine, 1/maxValue);\n      this.swap(maxLine, pivot);\n      for (var i=0; i<lines; i++) {\n        if (i !== pivot) {\n          this.addmul(i, pivot, -this.data[i][j]);\n        }\n      }\n    }\n    pivot++;\n  }\n\n  // Check that the system has null lines where it should\n  for (var i=0; i<nullLines.length; i++) {\n    if (!this.mirror.hasNullLine(nullLines[i])) {\n      throw new Error(\"singular matrix\");\n    }\n  }\n  return this.mirror.data;\n}\n\n/**\n * Solves A.x = b\n * @param A\n * @param b\n * @return x\n */\nexports.solve = function solve(A, b) {\n  var result = new Mat(A,b).gauss();\n  if (result.length > 0 && result[0].length === 1) {\n    // Convert Nx1 matrices to simple javascript arrays\n    for (var i=0; i<result.length; i++) result[i] = result[i][0];\n  }\n  return result;\n}\n\nfunction identity(n) {\n  var id = new Array(n);\n  for (var i=0; i<n; i++) {\n    id[i] = new Array(n);\n    for (var j=0; j<n; j++) {\n      id[i][j] = (i === j) ? 1 : 0;\n    }\n  }\n  return id;\n}\n\n/**\n * invert a matrix\n */\nexports.invert = function invert(A) {\n  return new Mat(A, identity(A.length)).gauss();\n}\n\nreturn exports;\n})();\n\nif (typeof module.exports === \"object\") module.exports = linear;\n","!function(r,f){\"object\"==typeof exports&&\"undefined\"!=typeof module?f(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],f):f((r=\"undefined\"!=typeof globalThis?globalThis:r||self).SVDJS={})}(this,function(r){\"use strict\";r.SVD=function(r,f,o,e,t){if(f=void 0===f||f,o=void 0===o||o,t=1e-64/(e=e||Math.pow(2,-52)),!r)throw new TypeError(\"Matrix a is not defined\");var i,a,n,s,h,l,M,d,p,b,u,w,y=r[0].length,q=r.length;if(q<y)throw new TypeError(\"Invalid matrix: m < n\");for(var v=[],c=[],x=[],g=\"f\"===f?q:y,m=b=M=0;m<q;m++)c[m]=new Array(g).fill(0);for(m=0;m<y;m++)x[m]=new Array(y).fill(0);var S,T=new Array(y).fill(0);for(m=0;m<q;m++)for(i=0;i<y;i++)c[m][i]=r[m][i];for(m=0;m<y;m++){for(v[m]=M,p=0,n=m+1,i=m;i<q;i++)p+=Math.pow(c[i][m],2);if(p<t)M=0;else for(d=(l=c[m][m])*(M=l<0?Math.sqrt(p):-Math.sqrt(p))-p,c[m][m]=l-M,i=n;i<y;i++){for(p=0,a=m;a<q;a++)p+=c[a][m]*c[a][i];for(l=p/d,a=m;a<q;a++)c[a][i]=c[a][i]+l*c[a][m]}for(T[m]=M,p=0,i=n;i<y;i++)p+=Math.pow(c[m][i],2);if(p<t)M=0;else{for(d=(l=c[m][m+1])*(M=l<0?Math.sqrt(p):-Math.sqrt(p))-p,c[m][m+1]=l-M,i=n;i<y;i++)v[i]=c[m][i]/d;for(i=n;i<q;i++){for(p=0,a=n;a<y;a++)p+=c[i][a]*c[m][a];for(a=n;a<y;a++)c[i][a]=c[i][a]+p*v[a]}}b<(u=Math.abs(T[m])+Math.abs(v[m]))&&(b=u)}if(o)for(m=y-1;0<=m;m--){if(0!==M){for(d=c[m][m+1]*M,i=n;i<y;i++)x[i][m]=c[m][i]/d;for(i=n;i<y;i++){for(p=0,a=n;a<y;a++)p+=c[m][a]*x[a][i];for(a=n;a<y;a++)x[a][i]=x[a][i]+p*x[a][m]}}for(i=n;i<y;i++)x[m][i]=0,x[i][m]=0;x[m][m]=1,M=v[m],n=m}if(f){if(\"f\"===f)for(m=y;m<q;m++){for(i=y;i<q;i++)c[m][i]=0;c[m][m]=1}for(m=y-1;0<=m;m--){for(n=m+1,M=T[m],i=n;i<g;i++)c[m][i]=0;if(0!==M){for(d=c[m][m]*M,i=n;i<g;i++){for(p=0,a=n;a<q;a++)p+=c[a][m]*c[a][i];for(l=p/d,a=m;a<q;a++)c[a][i]=c[a][i]+l*c[a][m]}for(i=m;i<q;i++)c[i][m]=c[i][m]/M}else for(i=m;i<q;i++)c[i][m]=0;c[m][m]=c[m][m]+1}}for(e*=b,a=y-1;0<=a;a--)for(var k=0;k<50;k++){for(S=!1,n=a;0<=n;n--){if(Math.abs(v[n])<=e){S=!0;break}if(Math.abs(T[n-1])<=e)break}if(!S)for(h=0,s=n-(p=1),m=n;m<a+1&&(l=p*v[m],v[m]=h*v[m],!(Math.abs(l)<=e));m++)if(M=T[m],T[m]=Math.sqrt(l*l+M*M),h=M/(d=T[m]),p=-l/d,f)for(i=0;i<q;i++)u=c[i][s],w=c[i][m],c[i][s]=u*h+w*p,c[i][m]=-u*p+w*h;if(w=T[a],n===a){if(w<0&&(T[a]=-w,o))for(i=0;i<y;i++)x[i][a]=-x[i][a];break}for(b=T[n],l=(((u=T[a-1])-w)*(u+w)+((M=v[a-1])-(d=v[a]))*(M+d))/(2*d*u),M=Math.sqrt(l*l+1),l=((b-w)*(b+w)+d*(u/(l<0?l-M:l+M)-d))/b,m=n+(p=h=1);m<a+1;m++){if(M=v[m],u=T[m],d=p*M,M*=h,w=Math.sqrt(l*l+d*d),l=b*(h=l/(v[m-1]=w))+M*(p=d/w),M=-b*p+M*h,d=u*p,u*=h,o)for(i=0;i<y;i++)b=x[i][m-1],w=x[i][m],x[i][m-1]=b*h+w*p,x[i][m]=-b*p+w*h;if(w=Math.sqrt(l*l+d*d),l=(h=l/(T[m-1]=w))*M+(p=d/w)*u,b=-p*M+h*u,f)for(i=0;i<q;i++)u=c[i][m-1],w=c[i][m],c[i][m-1]=u*h+w*p,c[i][m]=-u*p+w*h}v[n]=0,v[a]=l,T[a]=b}for(m=0;m<y;m++)T[m]<e&&(T[m]=0);return{u:c,q:T,v:x}},r.VERSION=\"1.1.1\",Object.defineProperty(r,\"__esModule\",{value:!0})});\n","import linearSolve from 'linear-solve';\r\nimport { SVD } from 'svd-js';\r\n\r\nfunction transpose( outMatrix, a ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ c ][ r ] = a[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction identity( outMatrix ) {\r\n\r\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = r === c ? 1 : 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction scale( outMatrix, matrix, scalar ) {\r\n\r\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = matrix[ r ][ c ] * scalar;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction multiply( outMatrix, a, b ) {\r\n\r\n\tif ( a === b ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n\t// a is m x n\r\n\t// b is n x k\r\n\t// outMatrix is m x k\r\n\r\n\t// m = a rows\r\n\t// n = a cols or b rows\r\n\t// k = b cols\r\n\r\n\tconst m = a.length;\r\n\tconst n = b.length;\r\n\tconst k = b[ 0 ].length;\r\n\r\n\t// iterate over m\r\n\tfor ( let r = 0, tr = m; r < tr; r ++ ) {\r\n\r\n\t\t// iterate over k\r\n\t\tfor ( let c = 0, tc = k; c < tc; c ++ ) {\r\n\r\n\t\t\tlet sum = 0;\r\n\r\n\t\t\t// iterate over n\r\n\t\t\tfor ( let i = 0, ti = n; i < ti; i ++ ) {\r\n\r\n\t\t\t\tsum += a[ r ][ i ] * b[ i ][ c ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutMatrix[ r ][ c ] = sum;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction create( row, col ) {\r\n\r\n\tconst result = new Array( row );\r\n\tfor ( let i = 0; i < row; i ++ ) {\r\n\r\n\t\tresult[ i ] = new Float64Array( col );\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction copy( outMatrix, sourceMatrix ) {\r\n\r\n\tconst tr = sourceMatrix.length;\r\n\tconst tc = sourceMatrix[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = sourceMatrix[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction clone( matrix ) {\r\n\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tconst resultMatrix = create( rows, cols );\r\n\tcopy( resultMatrix, matrix );\r\n\treturn resultMatrix;\r\n\r\n}\r\n\r\nfunction solve( outMatrix, matrix, vector ) {\r\n\r\n\tconst res = linearSolve.solve( matrix, vector );\r\n\tfor ( let i = 0, l = res.length; i < l; i ++ ) {\r\n\r\n\t\toutMatrix[ i ].set( res[ i ] );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction svd( ru, rq, rv, matrix ) {\r\n\r\n\tconst { u, v, q } = SVD( matrix );\r\n\r\n\tconst urows = u.length;\r\n\tfor ( let r = 0; r < urows; r ++ ) {\r\n\r\n\t\tru[ r ].set( u[ r ] );\r\n\r\n\t}\r\n\r\n\tconst vrows = v.length;\r\n\tfor ( let r = 0; r < vrows; r ++ ) {\r\n\r\n\t\trv[ r ].set( v[ r ] );\r\n\r\n\t}\r\n\r\n\tconst qrows = q.length;\r\n\tfor ( let r = 0; r < qrows; r ++ ) {\r\n\r\n\t\tconst rqrow = rq[ r ];\r\n\t\tconst qval = q[ r ];\r\n\t\trqrow.fill( 0 );\r\n\t\trqrow[ r ] = qval;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction invert( outMatrix, matrix ) {\r\n\r\n\tconst res = linearSolve.invert( matrix );\r\n\r\n\tconst tr = matrix[ 0 ].length;\r\n\tconst tc = matrix.length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = res[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction add( outMatrix, a, b ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] + b[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction subtract( outMatrix, a, b ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] - b[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction magnitudeSquared( matrix ) {\r\n\r\n\tlet sum = 0;\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tfor ( let r = 0; r < rows; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < cols; c ++ ) {\r\n\r\n\t\t\tsum += matrix[ r ][ c ] ** 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn sum;\r\n\r\n}\r\n\r\nfunction magnitude( matrix ) {\r\n\r\n\treturn Math.sqrt( magnitudeSquared( matrix ) );\r\n\r\n}\r\n\r\nfunction toString( matrix, dec = 3 ) {\r\n\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tlet str = '';\r\n\tfor ( let r = 0; r < rows; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < cols; c ++ ) {\r\n\r\n\t\t\tstr += matrix[ r ][ c ].toFixed( dec ) + ', ';\r\n\r\n\t\t}\r\n\r\n\t\tstr += '\\n';\r\n\r\n\t}\r\n\r\n\treturn str;\r\n\r\n}\r\n\r\nfunction log( matrix, dec ) {\r\n\r\n\tconsole.log( toString( matrix, dec ) );\r\n\r\n}\r\n\r\nexport const mat = {\r\n\ttranspose,\r\n\tidentity,\r\n\tscale,\r\n\tmultiply,\r\n\tcreate,\r\n\tcopy,\r\n\tclone,\r\n\tsolve,\r\n\tsvd,\r\n\tinvert,\r\n\tadd,\r\n\tsubtract,\r\n\tmagnitudeSquared,\r\n\tmagnitude,\r\n\ttoString,\r\n\tlog,\r\n};\r\n","import { vec3, vec4, mat4 } from 'gl-matrix';\nimport { accumulateClosureError, accumulateTargetError } from './utils/solver.js';\nimport { mat } from './utils/matrix.js';\nimport { getMatrixDifference } from './utils/glmatrix.js';\n\n// temp reusable variables\nconst targetRelativeToJointMatrix = new Float64Array( 16 );\nconst targetDeltaWorldMatrix = new Float64Array( 16 );\nconst tempDeltaWorldMatrix = new Float64Array( 16 );\nconst tempInverseMatrixWorld = new Float64Array( 16 );\nconst tempQuat = new Float64Array( 4 );\nconst tempPos = new Float64Array( 3 );\nconst tempQuat2 = new Float64Array( 4 );\nconst tempPos2 = new Float64Array( 3 );\n\nconst targetJoints = [];\nconst freeJoints = [];\nconst errorResultInfo = {\n\trowCount: 0,\n\tisConverged: false,\n\ttotalError: 0,\n};\nconst dofResultInfo = {\n\terrorRows: 0,\n\tfreeDoF: 0,\n\ttotalError: 0,\n};\n\nexport const SOLVE_STATUS = {\n\n\tCONVERGED: 0,\n\tSTALLED: 1,\n\tDIVERGED: 2,\n\tTIMEOUT: 3,\n\n};\n\nexport const SOLVE_STATUS_NAMES = Object.entries( SOLVE_STATUS ).sort( ( a, b ) => a[ 1 ] - b[ 1 ] ).map( el => el[ 0 ] );\n\nexport class ChainSolver {\n\n\tconstructor( chain ) {\n\n\t\tthis.chain = Array.from( chain );\n\n\t\t// list of targets we're trying to minimize in the chain\n\t\tthis.targets = null;\n\n\t\t// map of joint -> closures that the given joint affects\n\t\tthis.affectedClosures = null;\n\n\t\t// map of joint -> closure children that the given joint affects\n\t\tthis.affectedConnectedClosures = null;\n\n\t\t// map of joint -> that stores the amount of DoF that are locked after\n\t\t// hitting a joint limit.\n\t\t// Undefined or 0 if none are locked\n\t\tthis.lockedJointDoFCount = null;\n\n\t\t// map of joint -> list of locked DoF\n\t\tthis.lockedJointDoF = null;\n\n\t\t// map of joint -> previous joint angles for resetting joint angles on\n\t\t// divergence check.\n\t\tthis.prevDoFValues = null;\n\n\t\t// options -- these are set by the containing Solver.\n\t\tthis.maxIterations = - 1;\n\n\t\tthis.matrixPool = null;\n\n\t\tthis.useSVD = false;\n\n\t\tthis.translationConvergeThreshold = - 1;\n\t\tthis.rotationConvergeThreshold = - 1;\n\n\t\tthis.translationFactor = - 1;\n\t\tthis.rotationFactor = - 1;\n\n\t\tthis.translationStep = - 1;\n\t\tthis.rotationStep = - 1;\n\n\t\tthis.translationErrorClamp = - 1;\n\t\tthis.rotationErrorClamp = - 1;\n\n\t\tthis.stallThreshold = - 1;\n\t\tthis.dampingFactor = - 1;\n\t\tthis.divergeThreshold = - 1;\n\t\tthis.restPoseFactor = - 1;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\t// Find all joints with targets.\n\t\tconst chain = this.chain;\n\t\tconst targets = chain.filter( j => j.targetSet || j.isClosure );\n\n\t\tconst lockedJointDoF = new Map();\n\t\tconst lockedJointDoFCount = new Map();\n\t\tconst prevDoFValues = new Map();\n\n\t\tconst affectedClosures = new Map();\n\t\tconst affectedConnectedClosures = new Map();\n\t\tchain.forEach( j => {\n\n\t\t\t// Track which joints will have a direct affect on which targets move\n\t\t\t// for closure end effectors.\n\t\t\taffectedClosures.set( j, new Set() );\n\t\t\taffectedConnectedClosures.set( j, new Set() );\n\n\t\t\t// Initialize our array with all possible degrees of freedom\n\t\t\tlockedJointDoF.set( j, new Uint8Array( 6 ) );\n\t\t\tprevDoFValues.set( j, new Float64Array( 6 ) );\n\n\t\t} );\n\n\t\ttargets.forEach( target => {\n\n\t\t\tif ( target.isClosure ) {\n\n\t\t\t\tlet currJoint = target;\n\n\t\t\t\t// climb the joint tree and mark every joint as affecting this closure end.\n\t\t\t\twhile ( currJoint ) {\n\n\t\t\t\t\tif ( currJoint.isJoint ) {\n\n\t\t\t\t\t\taffectedClosures.get( currJoint ).add( target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrJoint = currJoint.parent;\n\n\t\t\t\t}\n\n\t\t\t\t// and mark the joints up the other chain as effecting the other connector link.\n\t\t\t\tcurrJoint = target.child;\n\t\t\t\twhile ( currJoint ) {\n\n\t\t\t\t\tif ( currJoint.isJoint ) {\n\n\t\t\t\t\t\taffectedConnectedClosures.get( currJoint ).add( target );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrJoint = currJoint.parent;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.targets = targets;\n\t\tthis.affectedClosures = affectedClosures;\n\t\tthis.affectedConnectedClosures = affectedConnectedClosures;\n\t\tthis.lockedJointDoF = lockedJointDoF;\n\t\tthis.lockedJointDoFCount = lockedJointDoFCount;\n\t\tthis.prevDoFValues = prevDoFValues;\n\n\t}\n\n\tsolve() {\n\n\t\tconst {\n\t\t\tdivergeThreshold,\n\t\t\tstallThreshold,\n\t\t\tchain,\n\t\t\trestPoseFactor,\n\t\t\tlockedJointDoFCount,\n\t\t\tprevDoFValues,\n\t\t\tuseSVD,\n\t\t\tmatrixPool,\n\t\t} = this;\n\n\t\tlet iterations = 0;\n\t\tlet prevErrorMagnitude = Infinity;\n\t\tlet status = - 1;\n\n\t\t// Clear out all the locked joints\n\t\tlockedJointDoFCount.clear();\n\n\t\t// TODO: instead of trying to use minimal euler angles we should try to represent joint\n\t\t// error as a quaternion in the quaternion vector.\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\n\n\t\t\tconst joint = chain[ i ];\n\t\t\tif ( joint.targetSet || joint.restPoseSet ) {\n\n\t\t\t\tjoint.tryMinimizeEulerAngles();\n\n\t\t\t}\n\n\t\t}\n\n\t\tdo {\n\n\t\t\tmatrixPool.releaseAll();\n\n\t\t\t// Make sure our matrices are all up to date\n\t\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\n\n\t\t\t\tconst joint = chain[ i ];\n\t\t\t\tjoint.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\t// TODO: this only needs to be recomputed if a joint was locked so maybe lets check that? We also\n\t\t\t// lock joints inside this function so maybe we can forgo that?\n\t\t\ttargetJoints.length = 0;\n\t\t\tfreeJoints.length = 0;\n\t\t\tthis.countUnconvergedVariables( freeJoints, targetJoints, dofResultInfo );\n\t\t\tconst { freeDoF, errorRows, totalError } = dofResultInfo;\n\n\t\t\t// Check if we've converged\n\t\t\tif ( errorRows === 0 ) {\n\n\t\t\t\tstatus = SOLVE_STATUS.CONVERGED;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// Check if we've diverged\n\t\t\tif ( totalError > prevErrorMagnitude + divergeThreshold ) {\n\n\t\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\n\n\t\t\t\t\tjoint.dofValues.set( dofValues );\n\t\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\n\n\t\t\t\t} );\n\n\n\t\t\t\tstatus = SOLVE_STATUS.DIVERGED;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevErrorMagnitude = totalError;\n\n\t\t\t// Check if we've hit max iterations\n\t\t\titerations ++;\n\t\t\tif ( iterations > this.maxIterations ) {\n\n\t\t\t\tstatus = SOLVE_STATUS.TIMEOUT;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// A * x = b\n\t\t\t// find x such that it yields b where is the clamped error we're trying to work towards\n\t\t\t// and A is the jacobian, and x is the delta joint angles.\n\n\t\t\tconst errorVector = matrixPool.get( errorRows, 1 );\n\t\t\tthis.fillErrorVector( targetJoints, errorVector );\n\n\t\t\tconst jacobian = matrixPool.get( errorRows, freeDoF );\n\t\t\tthis.fillJacobian( targetJoints, freeJoints, jacobian );\n\n\t\t\t// Solve for the pseudo inverse of the jacobian\n\t\t\tconst pseudoInverse = matrixPool.get( freeDoF, errorRows );\n\t\t\tlet failedSVD = false;\n\t\t\tif ( useSVD ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tconst m = errorRows;\n\t\t\t\t\tconst n = freeDoF;\n\t\t\t\t\tconst k = Math.min( m, n );\n\n\t\t\t\t\tconst u = matrixPool.get( m, k ); // m x k\n\t\t\t\t\tconst q = matrixPool.get( k, k ); // k x k\n\t\t\t\t\tconst v = matrixPool.get( n, k ); // ( k x n )^T -> ( n x k )\n\n\t\t\t\t\tmat.svd( u, q, v, jacobian );\n\n\t\t\t\t\tconst uTranspose = matrixPool.get( k, m );\n\t\t\t\t\tconst qInverse = matrixPool.get( k, k );\n\t\t\t\t\tmat.transpose( uTranspose, u );\n\n\t\t\t\t\t// if the diagonal value is close to 0 when taking the inverse\n\t\t\t\t\t// then set it to zero.\n\t\t\t\t\tfor ( let i = 0, l = q.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst val = q[ i ][ i ];\n\t\t\t\t\t\tlet inv;\n\t\t\t\t\t\tif ( Math.abs( val ) < 0.001 ) {\n\n\t\t\t\t\t\t\tinv = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tinv = 1 / val;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tqInverse[ i ][ i ] = inv;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// V * Qinv * Ut\n\t\t\t\t\tconst vqinv = matrixPool.get( n, k );\n\t\t\t\t\tmat.multiply( vqinv, v, qInverse );\n\t\t\t\t\tmat.multiply( pseudoInverse, vqinv, uTranspose );\n\n\t\t\t\t} catch ( err ) {\n\n\t\t\t\t\tfailedSVD = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! useSVD || failedSVD ) {\n\n\t\t\t\t// Use a transpose pseudo inverse approach: A^T * A * x = A^T * b with the damping term\n\t\t\t\t// J^T * J * x = J^T * e\n\t\t\t\t// x = J^T * ( J * J^T )^-1 * e\n\n\t\t\t\t// and with the adding damping\n\t\t\t\t// x = J^T * ( J * J^T + l^2 * I )^-1 * e\n\n\t\t\t\t// l^2 * I\n\t\t\t\tconst jacobianIdentityDamping = matrixPool.get( errorRows, errorRows );\n\t\t\t\tmat.identity( jacobianIdentityDamping );\n\t\t\t\tmat.scale( jacobianIdentityDamping, jacobianIdentityDamping, this.dampingFactor ** 2 );\n\n\t\t\t\t// J^T\n\t\t\t\tconst jacobianTranspose = matrixPool.get( freeDoF, errorRows );\n\t\t\t\tmat.transpose( jacobianTranspose, jacobian );\n\n\t\t\t\t// J * J^T\n\t\t\t\tconst jjt = matrixPool.get( errorRows, errorRows );\n\t\t\t\tmat.multiply( jjt, jacobian, jacobianTranspose );\n\n\t\t\t\t// J * J^T + l^2 * I\n\t\t\t\tconst jjti = matrixPool.get( errorRows, errorRows );\n\t\t\t\tmat.add( jjti, jjt, jacobianIdentityDamping );\n\n\t\t\t\t// ( J * J^T + l^2 * I )^-1\n\t\t\t\tconst jjtii = matrixPool.get( errorRows, errorRows );\n\t\t\t\tmat.invert( jjtii, jjti );\n\n\t\t\t\t// J^T * ( J * J^T + l^2 * I )^-1\n\t\t\t\tmat.multiply( pseudoInverse, jacobianTranspose, jjtii );\n\n\t\t\t}\n\n\t\t\t// x = deltaTheta = J^T * ( J * J^T + l^2 * I )^-1 * e\n\t\t\tconst deltaTheta = matrixPool.get( freeDoF, 1 );\n\t\t\tmat.multiply( deltaTheta, pseudoInverse, errorVector );\n\n\t\t\t// console.log( 'ERROR VECTOR', errorVector );\n\t\t\t// console.log( 'JACOBIAN', jacobian );\n\t\t\t// console.log( 'DELTA_THETA', deltaTheta );\n\n\t\t\tif ( restPoseFactor !== 0 ) {\n\n\t\t\t\t// Nullspace Projection\n\t\t\t\t// I - J^-1 * J is the orthogonal null space of J where J^-1 is the pseudoinverse\n\t\t\t\t// Multiplied by the rest position of each dof\n\t\t\t\t// ( I - J^-1 * J ) * restPose\n\t\t\t\tconst restPose = matrixPool.get( freeDoF, 1 );\n\t\t\t\tconst restPoseResult = matrixPool.get( freeDoF, 1 );\n\t\t\t\tlet colIndex = 0;\n\t\t\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst joint = freeJoints[ i ];\n\t\t\t\t\tconst lockedDoFCount = this.lockedJointDoFCount.get( joint ) || 0;\n\t\t\t\t\tconst isLocked = lockedDoFCount !== 0;\n\t\t\t\t\tconst lockedDoF = this.lockedJointDoF.get( joint );\n\n\t\t\t\t\tconst colCount = joint.rotationDoFCount + joint.translationDoFCount - lockedDoFCount;\n\t\t\t\t\tif ( joint.restPoseSet ) {\n\n\t\t\t\t\t\tconst dofList = joint.dof;\n\t\t\t\t\t\tconst dofValues = joint.dofValues;\n\t\t\t\t\t\tconst dofRestPose = joint.dofRestPose;\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\n\n\t\t\t\t\t\t\t// NOTE: this is reversed because in applyAngles we're having to negate the\n\t\t\t\t\t\t\t// delta angles for some reason atm\n\t\t\t\t\t\t\tconst dof = dofList[ d ];\n\n\t\t\t\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) continue;\n\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = dofValues[ dof ] - dofRestPose[ dof ];\n\t\t\t\t\t\t\tcolIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\n\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = 0;\n\t\t\t\t\t\t\tcolIndex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// J^-1 * J\n\t\t\t\tconst jij = matrixPool.get( freeDoF, freeDoF );\n\t\t\t\tmat.multiply( jij, pseudoInverse, jacobian );\n\n\t\t\t\t// ( I - J^-1 * J )\n\t\t\t\tconst ident = matrixPool.get( freeDoF, freeDoF );\n\t\t\t\tmat.identity( ident );\n\n\t\t\t\tconst nullSpaceProjection = matrixPool.get( freeDoF, freeDoF );\n\t\t\t\tmat.subtract( nullSpaceProjection, ident, jij );\n\n\t\t\t\t// ( I - J^-1 * J ) * restPose\n\t\t\t\tmat.multiply( restPoseResult, nullSpaceProjection, restPose );\n\n\t\t\t\tfor ( let r = 0; r < freeDoF; r ++ ) {\n\n\t\t\t\t\tconst val = restPoseResult[ r ][ 0 ];\n\t\t\t\t\tdeltaTheta[ r ][ 0 ] += val * restPoseFactor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check if our joints have not moved and returned stalled\n\t\t\tif ( stallThreshold > 0 ) {\n\n\t\t\t\tlet stalled = true;\n\t\t\t\tfor ( let i = 0, l = deltaTheta.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst delta = deltaTheta[ i ][ 0 ];\n\t\t\t\t\tif ( Math.abs( delta ) > stallThreshold ) {\n\n\t\t\t\t\t\tstalled = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( stalled ) {\n\n\t\t\t\t\tstatus = SOLVE_STATUS.STALLED;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Prep for a divergence check\n\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\n\n\t\t\t\tdofValues.set( joint.dofValues );\n\n\t\t\t} );\n\n\t\t\t// apply the latest joint angles and lock and joints that have\n\t\t\t// hit their joint limits.\n\t\t\tthis.applyJointAngles( freeJoints, deltaTheta );\n\n\t\t\t// there's still error and we're under the max iterations\n\n\t\t} while ( true );\n\n\t\ttargetJoints.length = 0;\n\t\tfreeJoints.length = 0;\n\t\treturn status;\n\n\t}\n\n\t// Apply the delta values from the solve to the free joints in the list\n\tapplyJointAngles( freeJoints, deltaTheta ) {\n\n\t\tconst {\n\t\t\tlockedJointDoF,\n\t\t\tlockedJointDoFCount,\n\t\t} = this;\n\n\t\tlet lockedJoint = false;\n\t\tlet dti = 0;\n\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\n\n\t\t\t// Apply the delta to every free joint\n\t\t\tconst joint = freeJoints[ i ];\n\t\t\tconst dofList = joint.dof;\n\t\t\tconst lockedDoF = lockedJointDoF.get( joint );\n\t\t\tconst isLocked = lockedJointDoFCount.has( joint );\n\n\t\t\tfor ( let d = 0, l = dofList.length; d < l; d ++ ) {\n\n\t\t\t\tconst dof = dofList[ d ];\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: why are we negating here?\n\t\t\t\tconst value = joint.getDoFValue( dof );\n\t\t\t\tconst hitLimit = joint.setDoFValue( dof, value - deltaTheta[ dti ][ 0 ] );\n\n\t\t\t\t// lock the joint if we hit a limit\n\t\t\t\tif ( hitLimit ) {\n\n\t\t\t\t\tif ( ! lockedJointDoFCount.has( joint ) ) {\n\n\t\t\t\t\t\tlockedJointDoFCount.set( joint, 0 );\n\t\t\t\t\t\tlockedDoF.fill( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst lockedCount = lockedJointDoFCount.get( joint );\n\t\t\t\t\tlockedJointDoFCount.set( joint, lockedCount + 1 );\n\t\t\t\t\tlockedDoF[ dof ] = 1;\n\t\t\t\t\tlockedJoint = true;\n\n\t\t\t\t}\n\n\t\t\t\tdti ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dti !== deltaTheta.length ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\treturn lockedJoint;\n\n\t}\n\n\t// generate the jacobian\n\t// The jacobian has one column for each free degree of freedom and a row for every\n\t// target degree of freedom we have. The entries are generated by adjusting every\n\t// DoF by some epsilon and storing how much it affected the target error.\n\tfillJacobian( targetJoints, freeJoints, outJacobian ) {\n\n\t\tconst {\n\t\t\ttranslationStep,\n\t\t\trotationStep,\n\t\t\tlockedJointDoF,\n\t\t\tlockedJointDoFCount,\n\t\t\ttranslationFactor,\n\t\t\trotationFactor,\n\t\t} = this;\n\n\t\t// TODO: abstract this\n\t\tconst affectedClosures = this.affectedClosures;\n\t\tconst affectedConnectedClosures = this.affectedConnectedClosures;\n\n\t\tlet colIndex = 0;\n\t\tfor ( let c = 0, tc = freeJoints.length; c < tc; c ++ ) {\n\n\t\t\t// TODO: If this is a goal we should skip adding it to the jacabian columns\n\t\t\tconst freeJoint = freeJoints[ c ];\n\t\t\tconst relevantClosures = affectedClosures.get( freeJoint );\n\t\t\tconst relevantConnectedClosures = affectedConnectedClosures.get( freeJoint );\n\t\t\tconst dofList = freeJoint.dof;\n\t\t\tconst colCount = freeJoint.translationDoFCount + freeJoint.rotationDoFCount;\n\n\t\t\tconst isLocked = lockedJointDoFCount.has( freeJoint );\n\t\t\tconst lockedDoF = lockedJointDoF.get( freeJoint );\n\n\t\t\t// get the world inverse of the free joint\n\t\t\tmat4.invert( tempInverseMatrixWorld, freeJoint.matrixWorld );\n\n\t\t\t// iterate over every degree of freedom in the joint\n\t\t\tfor ( let co = 0; co < colCount; co ++ ) {\n\n\t\t\t\tconst dof = dofList[ co ];\n\n\t\t\t\t// skip this joint if it's locked\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tlet rowIndex = 0;\n\n\t\t\t\t// generate the adjusted matrix based on the epsilon for the joint.\n\t\t\t\tlet delta = dof < 3 ? translationStep : rotationStep;\n\t\t\t\tif ( freeJoint.getDeltaWorldMatrix( dof, delta, tempDeltaWorldMatrix ) ) {\n\n\t\t\t\t\tdelta *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\t// Iterate over every target\n\t\t\t\tfor ( let r = 0, tr = targetJoints.length; r < tr; r ++ ) {\n\n\t\t\t\t\tconst targetJoint = targetJoints[ r ];\n\n\t\t\t\t\t// if it's a closure target\n\t\t\t\t\tif ( targetJoint.isClosure ) {\n\n\t\t\t\t\t\tif ( relevantClosures.has( targetJoint ) || relevantConnectedClosures.has( targetJoint ) ) {\n\n\t\t\t\t\t\t\t// TODO: If this is a Goal it only add 1 or 2 fields if only two axes are set. Quat is only\n\t\t\t\t\t\t\t// needed if 3 eulers are used.\n\t\t\t\t\t\t\t// TODO: these could be cached per target joint get the current error within the closure joint\n\n\t\t\t\t\t\t\t// Get the error from child towards the closure target\n\t\t\t\t\t\t\ttargetJoint.getClosureError( tempPos, tempQuat );\n\t\t\t\t\t\t\tif ( relevantConnectedClosures.has( targetJoint ) ) {\n\n\t\t\t\t\t\t\t\t// If this is affecting a link connected to a closure joint then adjust that child link by\n\t\t\t\t\t\t\t\t// the delta rotation.\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.child.matrixWorld );\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\n\n\t\t\t\t\t\t\t\t// Get the new error\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetJoint.matrixWorld, targetDeltaWorldMatrix, tempPos2, tempQuat2 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// If this is directly affecting a closure joint then adjust that child link by the delta\n\t\t\t\t\t\t\t\t// rotation.\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.matrixWorld );\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\n\n\t\t\t\t\t\t\t\t// Get the new error\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetDeltaWorldMatrix, targetJoint.child.matrixWorld, tempPos2, tempQuat2 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the amount that the rotation and translation error changed due to the\n\t\t\t\t\t\t\t// small DoF adjustment to serve as the derivative.\n\t\t\t\t\t\t\tvec3.subtract( tempPos, tempPos2, tempPos );\n\t\t\t\t\t\t\tvec3.scale( tempPos, tempPos, translationFactor / delta );\n\n\t\t\t\t\t\t\tvec4.subtract( tempQuat, tempQuat2, tempQuat );\n\t\t\t\t\t\t\tvec4.scale( tempQuat, tempQuat, rotationFactor / delta );\n\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\n\n\t\t\t\t\t\t\t\tconst { translationDoFCount, rotationDoFCount, dof } = targetJoint;\n\t\t\t\t\t\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst d = dof[ i ];\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = tempPos[ d ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( rotationDoFCount === 3 ) {\n\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 0 ][ colIndex ] = tempQuat[ 0 ];\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 1 ][ colIndex ] = tempQuat[ 1 ];\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 2 ][ colIndex ] = tempQuat[ 2 ];\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 3 ][ colIndex ] = tempQuat[ 3 ];\n\t\t\t\t\t\t\t\t\trowIndex += 4;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\trowIndex += translationDoFCount;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// set translation\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 0 ][ colIndex ] = tempPos[ 0 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 1 ][ colIndex ] = tempPos[ 1 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 2 ][ colIndex ] = tempPos[ 2 ];\n\n\t\t\t\t\t\t\t\t// set rotation\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 3 ][ colIndex ] = tempQuat[ 0 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 4 ][ colIndex ] = tempQuat[ 1 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 5 ][ colIndex ] = tempQuat[ 2 ];\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 6 ][ colIndex ] = tempQuat[ 3 ];\n\t\t\t\t\t\t\t\trowIndex += 7;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the target isn't relevant then there's no delta\n\t\t\t\t\t\t\tlet totalRows = 7;\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\n\n\t\t\t\t\t\t\t\ttotalRows = targetJoint.translationDoFCount;\n\t\t\t\t\t\t\t\tif ( targetJoint.rotationDoFCount === 3 ) {\n\n\t\t\t\t\t\t\t\t\ttotalRows += 4;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < totalRows; i ++ ) {\n\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trowIndex += totalRows;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if this joint has a target set and update the jacobian rows if it does\n\t\t\t\t\tif ( targetJoint.targetSet ) {\n\n\t\t\t\t\t\tconst rowCount = targetJoint.translationDoFCount + targetJoint.rotationDoFCount;\n\n\t\t\t\t\t\tif ( freeJoint === targetJoint ) {\n\n\t\t\t\t\t\t\t// if we're just dealing with a target dof joint then there can't be any influence\n\t\t\t\t\t\t\t// but otherwise the only joint that can have an effect on this error is the joint\n\t\t\t\t\t\t\t// itself.\n\t\t\t\t\t\t\t// TODO: Having noted that is this really necessary? Is there any way that this doesn't just\n\t\t\t\t\t\t\t// jump to the solution and lock? How can we afford some slack? With a low weight? Does that\n\t\t\t\t\t\t\t// get applied here?\n\t\t\t\t\t\t\t// TODO: If this joint happens to have three euler joints we need to use a quat here. Otherwise we\n\t\t\t\t\t\t\t// use the euler angles.\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\n\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + colIndex ][ colIndex ] = - 1;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\n\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trowIndex += rowCount;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcolIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( colIndex !== outJacobian[ 0 ].length ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t}\n\n\t// Fill in the error vector\n\tfillErrorVector( targetJoints, errorVector ) {\n\n\t\tlet rowIndex = 0;\n\t\tfor ( let i = 0, l = targetJoints.length; i < l; i ++ ) {\n\n\t\t\tconst joint = targetJoints[ i ];\n\t\t\tif ( joint.isClosure ) {\n\n\t\t\t\taccumulateClosureError( this, joint, rowIndex, errorVector, errorResultInfo );\n\t\t\t\trowIndex += errorResultInfo.rowCount;\n\n\t\t\t}\n\n\t\t\tif ( joint.targetSet ) {\n\n\t\t\t\taccumulateTargetError( this, joint, rowIndex, errorVector, errorResultInfo );\n\t\t\t\trowIndex += errorResultInfo.rowCount;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Count the unconverged targets in the chain and store them in targetJoints and store\n\t// any freeJoints in\n\tcountUnconvergedVariables( freeJoints, targetJoints, dofResultInfo ) {\n\n\t\tconst { lockedJointDoFCount } = this;\n\n\t\tconst chain = this.chain;\n\t\tlet totalError = 0;\n\t\tlet errorRows = 0;\n\t\tlet unconvergedRows = 0;\n\t\tlet freeDoF = 0;\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\n\n\t\t\tlet addToTargetList = false;\n\t\t\tconst joint = chain[ i ];\n\t\t\tconst lockedDoF = lockedJointDoFCount.get( joint ) || 0;\n\n\t\t\t// TODO: Should we check every variable against the convergence threshold or is\n\t\t\t// it better to check the magnitude?\n\n\t\t\t// TODO: We may be able to speed this up by using the square distance and length\n\t\t\t// to compare error.\n\n\t\t\t// TODO: If this is a goal we shouldnt add to the free dof because they won't be added\n\t\t\t// to the jacobian\n\n\t\t\t// If this is a closure joint then we need to make sure we're solving\n\t\t\t// for the other child end to meet this joint so this error is important.\n\t\t\tif ( joint.isClosure ) {\n\n\t\t\t\taccumulateClosureError( this, joint, errorRows, null, errorResultInfo );\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\n\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\n\n\t\t\t\t}\n\n\t\t\t\taddToTargetList = true;\n\t\t\t\terrorRows += errorResultInfo.rowCount;\n\n\t\t\t}\n\n\t\t\t// Check out far the joint is from the target dof value.\n\t\t\tconst dofList = joint.dof;\n\t\t\tif ( joint.targetSet ) {\n\n\t\t\t\taccumulateTargetError( this, joint, errorRows, null, errorResultInfo );\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\n\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\n\n\t\t\t\t}\n\n\t\t\t\taddToTargetList = true;\n\t\t\t\terrorRows += errorResultInfo.rowCount;\n\n\t\t\t}\n\n\t\t\tif ( ! joint.isGoal ) {\n\n\t\t\t\tfreeDoF += dofList.length - lockedDoF;\n\t\t\t\tfreeJoints.push( joint );\n\n\t\t\t}\n\n\t\t\tif ( addToTargetList ) {\n\n\t\t\t\ttargetJoints.push( joint );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if it turns out that everything is converged.\n\t\tif ( unconvergedRows === 0 ) {\n\n\t\t\terrorRows = 0;\n\n\t\t}\n\n\t\tdofResultInfo.errorRows = errorRows;\n\t\tdofResultInfo.freeDoF = freeDoF;\n\t\tdofResultInfo.totalError = totalError;\n\n\t}\n\n}\n","import { mat } from './utils/matrix.js';\r\n\r\nclass FixedMatrixPool {\r\n\r\n\tconstructor( row, col ) {\r\n\r\n\t\tconst matrices = [];\r\n\t\tlet index = 0;\r\n\r\n\t\tthis.get = function () {\r\n\r\n\t\t\tlet matrix = matrices[ index ];\r\n\t\t\tif ( ! matrix ) {\r\n\r\n\t\t\t\tmatrices[ index ] = matrix = mat.create( row, col );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex ++;\r\n\t\t\treturn matrix;\r\n\r\n\t\t};\r\n\r\n\t\tthis.releaseAll = function () {\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class MatrixPool {\r\n\r\n\tconstructor() {\r\n\r\n\t\tconst pools = {};\r\n\t\tconst poolArray = [];\r\n\t\tthis.get = function ( row, col ) {\r\n\r\n\t\t\tlet colPools = pools[ row ];\r\n\t\t\tif ( ! colPools ) {\r\n\r\n\t\t\t\tcolPools = pools[ row ] = {};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet pool = colPools[ col ];\r\n\t\t\tif ( ! pool ) {\r\n\r\n\t\t\t\tpool = colPools[ col ] = new FixedMatrixPool( row, col );\r\n\t\t\t\tpoolArray.push( pool );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn pool.get();\r\n\r\n\t\t};\r\n\r\n\t\tthis.releaseAll = function () {\r\n\r\n\t\t\tfor ( let i = 0, l = poolArray.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tpoolArray[ i ].releaseAll();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","import { ChainSolver } from './ChainSolver.js';\nimport { findRoots } from './utils/findRoots.js';\nimport { MatrixPool } from './MatrixPool.js';\n\nexport class Solver {\n\n\tconstructor( roots = [] ) {\n\n\t\tthis.matrixPool = new MatrixPool();\n\n\t\tthis.useSVD = true;\n\n\t\tthis.maxIterations = 5;\n\t\tthis.stallThreshold = 1e-4;\n\t\tthis.dampingFactor = 0.001;\n\t\tthis.divergeThreshold = 0.01;\n\t\tthis.restPoseFactor = 0.01;\n\n\t\tthis.translationConvergeThreshold = 1e-3;\n\t\tthis.rotationConvergeThreshold = 1e-5;\n\n\t\tthis.translationFactor = 1;\n\t\tthis.rotationFactor = 1;\n\n\t\tthis.translationStep = 1e-3;\n\t\tthis.rotationStep = 1e-3;\n\n\t\tthis.translationErrorClamp = 0.1;\n\t\tthis.rotationErrorClamp = 0.1;\n\n\t\tthis.roots = Array.isArray( roots ) ? [ ...roots ] : [ roots ];\n\t\tthis.solvers = null;\n\n\t\tthis.updateStructure();\n\n\t}\n\n\t// needs to be called whenever tree structure is updated\n\tupdateStructure() {\n\n\t\tconst roots = findRoots( this.roots );\n\t\tconst chains = [];\n\t\tconst traversal = new Set();\n\t\tconst allChainJoints = new Set();\n\t\tconst traverseChains = frame => {\n\n\t\t\t// If we found a joint then add it to the traversal list\n\t\t\tif ( frame.isJoint ) {\n\n\t\t\t\tconst joint = frame;\n\t\t\t\ttraversal.add( joint );\n\n\t\t\t\t// If we found a closure joint\n\t\t\t\tif ( joint.isClosure ) {\n\n\t\t\t\t\t// Traverse back up the tree until we find a common ancestor\n\t\t\t\t\t// and create a new chain\n\t\t\t\t\tconst chainSet = new Set();\n\t\t\t\t\tlet curr = joint.child;\n\t\t\t\t\twhile ( curr ) {\n\n\t\t\t\t\t\tif ( curr.isJoint ) {\n\n\t\t\t\t\t\t\tif ( traversal.has( curr ) ) {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tchainSet.add( curr );\n\t\t\t\t\t\t\t\tallChainJoints.add( curr );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurr = curr.parent;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttraversal.forEach( c => {\n\n\t\t\t\t\t\tchainSet.add( c );\n\t\t\t\t\t\tallChainJoints.add( c );\n\n\t\t\t\t\t} );\n\t\t\t\t\tchains.push( chainSet );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Continue traversing\n\t\t\tconst children = frame.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\ttraverseChains( children[ i ] );\n\n\t\t\t}\n\n\t\t\t// Remove the joint from our traversal set\n\t\t\ttraversal.delete( frame );\n\n\t\t};\n\n\t\t// find all chains in the roots\n\t\troots.forEach( traverseChains );\n\n\t\t// Merge interdependent chains\n\t\tconst independentChains = [];\n\t\twhile ( chains.length ) {\n\n\t\t\tconst currChain = chains.pop();\n\t\t\tindependentChains.push( currChain );\n\t\t\tfor ( let i = 0; i < chains.length; i ++ ) {\n\n\t\t\t\t// see if this chain is dependent on the current chain\n\t\t\t\t// and if so merge the chains.\n\t\t\t\tconst otherChain = chains[ i ];\n\n\t\t\t\tlet dependent = false;\n\t\t\t\totherChain.forEach( c => {\n\n\t\t\t\t\tdependent = dependent || currChain.has( c );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( dependent ) {\n\n\t\t\t\t\totherChain.forEach( c => currChain.add( c ) );\n\t\t\t\t\tchains.splice( i, 1 );\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Find any joints that aren't considered part of a solve chain so we\n\t\t// can just update them using forward kinematics.\n\t\tconst nonChainJoints = new Set();\n\t\troots.forEach( root => root.traverse( c => {\n\n\t\t\tif ( c.isJoint && c.dof.length > 0 && ! allChainJoints.has( c ) ) {\n\n\t\t\t\tnonChainJoints.add( c );\n\n\t\t\t}\n\n\t\t} ) );\n\n\t\t// Create the solvers for the chains\n\t\tthis.solvers = independentChains.map( c => new ChainSolver( c ) );\n\t\tthis.nonChainJoints = nonChainJoints;\n\n\t}\n\n\tsolve() {\n\n\t\tconst { solvers, nonChainJoints } = this;\n\n\t\t// update any non chain joints\n\t\tnonChainJoints.forEach( joint => {\n\n\t\t\tif ( joint.targetSet ) {\n\n\t\t\t\tjoint.dofValues.set( joint.dofTarget );\n\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst results = [];\n\t\tfor ( let i = 0, l = solvers.length; i < l; i ++ ) {\n\n\t\t\tconst s = solvers[ i ];\n\t\t\ts.matrixPool = this.matrixPool;\n\n\t\t\ts.useSVD = this.useSVD;\n\n\t\t\ts.maxIterations = this.maxIterations;\n\t\t\ts.stallThreshold = this.stallThreshold;\n\t\t\ts.dampingFactor = this.dampingFactor;\n\t\t\ts.divergeThreshold = this.divergeThreshold;\n\t\t\ts.restPoseFactor = this.restPoseFactor;\n\n\t\t\ts.translationConvergeThreshold = this.translationConvergeThreshold;\n\t\t\ts.rotationConvergeThreshold = this.rotationConvergeThreshold;\n\n\t\t\ts.translationFactor = this.translationFactor;\n\t\t\ts.rotationFactor = this.rotationFactor;\n\n\t\t\ts.translationStep = this.translationStep;\n\t\t\ts.rotationStep = this.rotationStep;\n\n\t\t\ts.translationErrorClamp = this.translationErrorClamp;\n\t\t\ts.rotationErrorClamp = this.rotationErrorClamp;\n\n\t\t\tconst result = s.solve();\n\t\t\tresults.push( result );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n}\n","import { Joint, DOF } from './Joint.js';\n\nexport class Goal extends Joint {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.isGoal = true;\n\t\tthis.setFreeDoF();\n\n\t}\n\n\tsetDoF( ...args ) {\n\n\t\t// We don't support rotation goals that only specify 1 or 2 free rotation axes.\n\t\tlet rotCount =\n\t\t\tNumber( args.includes( DOF.EX ) ) +\n\t\t\tNumber( args.includes( DOF.EY ) ) +\n\t\t\tNumber( args.includes( DOF.EZ ) );\n\n\t\tif ( rotCount !== 0 && rotCount !== 3 ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tsuper.setDoF( ...args );\n\n\t}\n\n\tsetGoalDoF( ...args ) {\n\n\t\tthis.setDoF( ...args );\n\n\t}\n\n\tsetFreeDoF( ...args ) {\n\n\t\tconst freeDoF = [\n\t\t\tDOF.X, DOF.Y, DOF.Z,\n\t\t\tDOF.EX, DOF.EY, DOF.EZ,\n\t\t].filter( d => ! args.includes( d ) );\n\t\tthis.setDoF( ...freeDoF );\n\n\t}\n\n\taddChild() {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n","import { Joint } from '../core/Joint.js';\r\nimport { Link } from '../core/Link.js';\r\nimport { Goal } from '../core/Goal.js';\r\n\r\n// Takes a list of interconnected frames and serializes them into a non cyclic json representation\r\nexport function serialize( frames ) {\r\n\r\n\tconst map = new Map();\r\n\tconst info = [];\r\n\r\n\t// Create the initial frame list along with a joint -> index map\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tconst frame = frames[ i ];\r\n\r\n\t\tconst {\r\n\t\t\tname,\r\n\t\t\tdof,\r\n\t\t\tdofValues,\r\n\t\t\tdofTarget,\r\n\t\t\tdofRestPose,\r\n\t\t\tminDoFLimit,\r\n\t\t\tmaxDoFLimit,\r\n\t\t\ttargetSet,\r\n\t\t\trestPoseSet,\r\n\t\t\tposition,\r\n\t\t\tquaternion,\r\n\t\t\tisClosure,\r\n\t\t} = frame;\r\n\r\n\t\tlet type = 'Link';\r\n\t\tif ( frame.isGoal ) {\r\n\r\n\t\t\ttype = 'Goal';\r\n\r\n\t\t} else if ( frame.isJoint ) {\r\n\r\n\t\t\ttype = 'Joint';\r\n\r\n\t\t}\r\n\r\n\t\tconst res = {\r\n\t\t\tdof: dof ? dof.slice() : null,\r\n\t\t\tdofValues: dofValues ? dofValues.slice() : null,\r\n\t\t\tdofTarget: dofTarget ? dofTarget.slice() : null,\r\n\t\t\tdofRestPose: dofRestPose ? dofRestPose.slice() : null,\r\n\t\t\tminDoFLimit: minDoFLimit ? minDoFLimit.slice() : null,\r\n\t\t\tmaxDoFLimit: maxDoFLimit ? maxDoFLimit.slice() : null,\r\n\t\t\ttargetSet,\r\n\t\t\trestPoseSet,\r\n\t\t\tisClosure,\r\n\r\n\t\t\tname,\r\n\t\t\tposition: position.slice(),\r\n\t\t\tquaternion: quaternion.slice(),\r\n\t\t\tchildren: null,\r\n\t\t\tclosureJoints: null,\r\n\t\t\tchild: null,\r\n\t\t\ttype,\r\n\t\t};\r\n\r\n\t\tinfo.push( res );\r\n\t\tmap.set( frame, i );\r\n\r\n\t}\r\n\r\n\t// Create the child and parent index references.\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tconst inf = info[ i ];\r\n\t\tconst frame = frames[ i ];\r\n\t\tinf.children = frame.children.map( c => map.get( c ) );\r\n\t\tif ( frame.isLink ) {\r\n\r\n\t\t\tinf.closureJoints = frame.closureJoints.map( c => map.get( c ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.isJoint && frame.child ) {\r\n\r\n\t\t\tinf.child = map.get( frame.child );\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.parent ) {\r\n\r\n\t\t\tinf.parent = map.get( frame.parent );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinf.parent = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn info;\r\n\r\n}\r\n\r\n// Deserialize the serialized representation of the graph\r\nexport function deserialize( data ) {\r\n\r\n\t// Create joints / links for every serialized version\r\n\tconst frames =\r\n\t\tdata.map( d => {\r\n\r\n\t\t\tconst {\r\n\t\t\t\ttype,\r\n\t\t\t\tname,\r\n\t\t\t\tposition,\r\n\t\t\t\tquaternion,\r\n\r\n\t\t\t\tdof,\r\n\t\t\t\tdofValues,\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t\ttargetSet,\r\n\t\t\t\trestPoseSet,\r\n\t\t\t\tisClosure,\r\n\t\t\t} = d;\r\n\r\n\t\t\tlet frame;\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'Goal':\r\n\t\t\t\tcase 'Joint':\r\n\t\t\t\t\tframe = type === 'Goal' ? new Goal() : new Joint();\r\n\r\n\t\t\t\t\tframe.setDoF( ...dof );\r\n\t\t\t\t\tframe.dofValues.set( dofValues );\r\n\t\t\t\t\tframe.dofTarget.set( dofTarget );\r\n\t\t\t\t\tframe.dofRestPose.set( dofRestPose );\r\n\t\t\t\t\tframe.minDoFLimit.set( minDoFLimit );\r\n\t\t\t\t\tframe.maxDoFLimit.set( maxDoFLimit );\r\n\r\n\t\t\t\t\tframe.targetSet = targetSet;\r\n\t\t\t\t\tframe.restPoseSet = restPoseSet;\r\n\t\t\t\t\tframe.isClosure = isClosure;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'Link':\r\n\t\t\t\t\tframe = new Link();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tframe.name = name;\r\n\t\t\tframe.position.set( position );\r\n\t\t\tframe.quaternion.set( quaternion );\r\n\t\t\treturn frame;\r\n\r\n\t\t} );\r\n\r\n\t// set the parent and child from the maps\r\n\tfor ( let i = 0; i < frames.length; i ++ ) {\r\n\r\n\t\tconst frame = frames[ i ];\r\n\t\tconst info = data[ i ];\r\n\r\n\t\tframe.parent = frames[ info.parent ] || null;\r\n\t\tframe.children.push( ...info.children.map( i => frames[ i ] ) );\r\n\t\tframe.setMatrixNeedsUpdate();\r\n\r\n\t\tif ( frame.isLink ) {\r\n\r\n\t\t\tframe.closureJoints.push( ...info.closureJoints.map( i => frames[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\tframe.child = info.child !== null ? frames[ info.child ] : null;\r\n\t\t\tframe.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn frames;\r\n\r\n}\r\n","export const JOINT_STRIDE = 304;\r\n\r\nexport const LINK_STRIDE = 56;\r\n\r\nexport function generateSharedBuffer( frames, useSharedArrayBuffer = true ) {\r\n\r\n\t// dofValues \t6 * 4\r\n\t// dofTarget \t6 * 4\r\n\t// dofRestPose \t6 * 4\r\n\t// minDoFLimit \t6 * 4\r\n\t// maxDoFLimit \t6 * 4\r\n\t// position \t3 * 4\r\n\t// quaternion \t4 * 4\r\n\t// targetSet \t1\r\n\t// restPoseSet \t1\r\n\t// --\r\n\t// total  \t\t150 bytes per joint\r\n\t// 4 byte aligned: 152\r\n\r\n\tlet arrayBuffer;\r\n\tif ( useSharedArrayBuffer ) {\r\n\r\n\t\tarrayBuffer = new SharedArrayBuffer( JOINT_STRIDE * frames.length );\r\n\r\n\t} else {\r\n\r\n\t\tarrayBuffer = new ArrayBuffer( JOINT_STRIDE * frames.length );\r\n\r\n\t}\r\n\r\n\tconst float64 = new Float32Array( arrayBuffer );\r\n\tconst byte8 = new Uint8Array( arrayBuffer );\r\n\tapplyToBuffer( frames, float64, byte8 );\r\n\treturn arrayBuffer;\r\n\r\n}\r\n\r\nexport function applyToBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyFrameToBuffer( frames[ i ], floatBuffer, byteBuffer, i * JOINT_STRIDE, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function applyFromBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyBufferToFrame( frames[ i ], floatBuffer, byteBuffer, JOINT_STRIDE * i, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the frame to the given buffer starting at the given byte offset. Joints take JOINT_STRIDE\r\n// bytes while links take LINK_STRIDE bytes.\r\nexport function copyFrameToBuffer(\r\n\tframe,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tconst {\r\n\t\t\tposition,\r\n\t\t\tquaternion,\r\n\t\t} = frame;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 0 + i ] = position[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 3 + i ] = quaternion[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t\ttargetSet,\r\n\t\t\t\trestPoseSet,\r\n\t\t\t} = frame;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 0 * 6 + i ] = dofTarget[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 1 * 6 + i ] = dofRestPose[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 2 * 6 + i ] = minDoFLimit[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 3 * 6 + i ] = maxDoFLimit[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteBuffer[ byteOffset + 148 ] = Number( targetSet );\r\n\t\t\tbyteBuffer[ byteOffset + 149 ] = Number( restPoseSet );\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && frame.isJoint ) {\r\n\r\n\t\tconst { dofValues } = frame;\r\n\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 7 + 4 * 6 + i ] = dofValues[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the given buffer to the given frame starting at the given byte offset.\r\nexport function copyBufferToFrame(\r\n\tjoint,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tjoint.setPosition(\r\n\t\t\tfloatBuffer[ floatOffset + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 2 ],\r\n\t\t);\r\n\t\tjoint.setQuaternion(\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 2 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 3 ],\r\n\t\t);\r\n\r\n\t\tif ( joint.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t} = joint;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tdofTarget[ i ] = floatBuffer[ floatOffset + 7 + 0 * 6 + i ];\r\n\t\t\t\tdofRestPose[ i ] = floatBuffer[ floatOffset + 7 + 1 * 6 + i ];\r\n\t\t\t\tminDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 2 * 6 + i ];\r\n\t\t\t\tmaxDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 3 * 6 + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tjoint.targetSet = Boolean( byteBuffer[ byteOffset + 148 ] );\r\n\t\t\tjoint.restPoseSet = Boolean( byteBuffer[ byteOffset + 149 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && joint.isJoint ) {\r\n\r\n\t\tconst { dofValues } = joint;\r\n\t\tlet changed = false;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tconst v = floatBuffer[ floatOffset + 7 + 4 * 6 + i ];\r\n\t\t\tif ( v !== dofValues[ i ] ) {\r\n\r\n\t\t\t\tdofValues[ i ] = v;\r\n\t\t\t\tchanged = true;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t\t// only update dof matrix if it changed\r\n\t\tif ( changed ) {\r\n\r\n\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { Solver } from '../core/Solver.js';\r\nimport { SOLVE_STATUS } from '../core/ChainSolver.js';\r\nimport { deserialize } from './serialize.js';\r\nimport { applyToBuffer, applyFromBuffer } from './utils.js';\r\n\r\nconst useSharedArrayBuffers = ( typeof SharedArrayBuffer ) !== 'undefined';\r\n\r\nlet solver = new Solver();\r\nlet solveHandle = - 1;\r\n\r\n// List of all frames in the graph\r\nlet frames = null;\r\n\r\n// Buffer variants\r\nlet buffer = null;\r\nlet floatBuffer = null;\r\nlet byteBuffer = null;\r\n\r\nglobal.onmessage = function ( { data: e } ) {\r\n\r\n\tconst { type, data } = e;\r\n\tswitch ( type ) {\r\n\r\n\t\t// The ik graph needs to be updated with all the deserialized\r\n\t\tcase 'updateStructure':\r\n\t\t\tframes = deserialize( data.serialized );\r\n\t\t\tsolver.roots = frames.filter( f => f.parent === null );\r\n\t\t\tsolver.updateStructure();\r\n\r\n\t\t\tbuffer = data.buffer;\r\n\t\t\tbyteBuffer = new Uint8Array( buffer );\r\n\t\t\tfloatBuffer = new Float32Array( buffer );\r\n\t\t\tbreak;\r\n\r\n\t\t// update the frame state from buffer when not using shared array buffers\r\n\t\tcase 'updateFrameState':\r\n\t\t\tbyteBuffer.set( new Uint8Array( data.buffer ) );\r\n\t\t\tbreak;\r\n\r\n\t\t// Update the settings of the solver\r\n\t\tcase 'updateSolverSettings':\r\n\t\t\tObject.assign( solver, data );\r\n\t\t\tbreak;\r\n\r\n\t\t// Start the solve loop\r\n\t\tcase 'startSolve':\r\n\t\t\tif ( solveHandle === - 1 ) {\r\n\r\n\t\t\t\tupdateSolve();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t// Stop the solve loop\r\n\t\tcase 'endSolve':\r\n\t\t\tif ( solveHandle !== - 1 ) {\r\n\r\n\t\t\t\tclearTimeout( solveHandle );\r\n\t\t\t\tsolveHandle = - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// The iterative solve loop\r\nfunction updateSolve() {\r\n\r\n\t// Copy any frame updates from the main thread\r\n\tapplyFromBuffer( frames, floatBuffer, byteBuffer, false, true );\r\n\r\n\t// Solve 1 iteration taking the most severe chain result\r\n\tconst status = solver.solve();\r\n\r\n\t// Copy the new DoF back to the shared buffer\r\n\tapplyToBuffer( frames, floatBuffer, byteBuffer, true, false );\r\n\r\n\tif ( status.find( r => r === SOLVE_STATUS.TIMEOUT ) ) {\r\n\r\n\t\t// yield so we can react to messages\r\n\t\tsolveHandle = setTimeout( updateSolve );\r\n\r\n\t} else {\r\n\r\n\t\tsolveHandle = - 1;\r\n\r\n\t}\r\n\r\n\t// send a copy of the buffer back if not using shared array buffers\r\n\tif ( useSharedArrayBuffers ) {\r\n\r\n\t\tthis.postMessage( {\r\n\r\n\t\t\ttype: 'updateSolve',\r\n\t\t\tdata: {\r\n\t\t\t\tstatus,\r\n\t\t\t},\r\n\r\n\t\t} );\r\n\r\n\t} else {\r\n\r\n\t\tconst resultsBuffer = buffer.slice();\r\n\t\tthis.postMessage( {\r\n\r\n\t\t\ttype: 'updateSolve',\r\n\t\t\tdata: {\r\n\t\t\t\tstatus,\r\n\t\t\t\tbuffer: resultsBuffer,\r\n\t\t\t},\r\n\r\n\t\t}, [ resultsBuffer ] );\r\n\r\n\t}\r\n\r\n}\r\n"]}