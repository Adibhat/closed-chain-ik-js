{"version":3,"sources":["../node_modules/linear-solve/gauss-jordan.js","../node_modules/svd-js/build-umd/svd-js.min.js","../src/core/utils/matrix.js","../src/core/MatrixPool.js","../src/core/utils/solver.js","../src/core/ChainSolver.js","../src/core/Solver.js","../src/core/Goal.js","../src/worker/serialize.js","../src/worker/utils.js","../src/worker/workerSolver.worker.js"],"names":["transpose","outMatrix","a","tr","length","tc","r","c","identity","scale","matrix","scalar","multiply","b","Error","m","n","k","sum","i","ti","create","row","col","result","Array","Float64Array","copy","sourceMatrix","clone","rows","resultMatrix","solve","vector","res","linearSolve","l","set","svd","ru","rq","rv","u","v","q","urows","vrows","qrows","rqrow","qval","fill","invert","add","subtract","magnitudeSquared","cols","magnitude","Math","sqrt","toString","dec","str","toFixed","log","console","mat","FixedMatrixPool","matrices","index","get","releaseAll","MatrixPool","pools","poolArray","colPools","pool","push","tempPos","tempQuat","tempEuler","accumulateClosureError","solver","joint","startIndex","errorVector","isConverged","rowCount","totalError","translationConvergeThreshold","rotationConvergeThreshold","translationErrorClamp","rotationErrorClamp","translationFactor","rotationFactor","translationDoFCount","rotationDoFCount","dofFlags","dof","getClosureError","isGoal","posMag","vec3","rotMag","vec4","d","accumulateTargetError","lockedJointDoFCount","lockedJointDoF","dofTarget","dofValues","dofList","posDelta","distance","rotDelta","DOF","EX","EY","EZ","lockedDoFCount","lockedDoF","isLocked","rowIndex","eulerMag","matrixPool","targetRelativeToJointMatrix","targetDeltaWorldMatrix","tempDeltaWorldMatrix","tempInverseMatrixWorld","tempQuat2","tempPos2","targetJoints","freeJoints","errorResultInfo","dofResultInfo","errorRows","freeDoF","SOLVE_STATUS","CONVERGED","STALLED","DIVERGED","TIMEOUT","SOLVE_STATUS_NAMES","Object","entries","sort","map","el","ChainSolver","chain","from","targets","affectedClosures","affectedConnectedClosures","prevDoFValues","maxIterations","useSVD","translationStep","rotationStep","stallThreshold","dampingFactor","divergeThreshold","restPoseFactor","init","filter","j","targetSet","isClosure","Map","forEach","Set","Uint8Array","target","currJoint","isJoint","parent","child","iterations","prevErrorMagnitude","Infinity","status","clear","restPoseSet","tryMinimizeEulerAngles","updateMatrixWorld","countUnconvergedVariables","setMatrixDoFNeedsUpdate","fillErrorVector","jacobian","fillJacobian","pseudoInverse","min","vt","ut","qinv","val","inv","abs","vqinv","jacobianIdentityDamping","jacobianTranspose","jjt","jjti","jjtii","deltaTheta","restPose","restPoseResult","colIndex","colCount","dofRestPose","jij","ident","nullSpaceProjection","stalled","delta","applyJointAngles","lockedJoint","dti","has","value","getDoFValue","hitLimit","setDoFValue","lockedCount","outJacobian","freeJoint","relevantClosures","relevantConnectedClosures","matrixWorld","co","getDeltaWorldMatrix","targetJoint","totalRows","unconvergedRows","addToTargetList","Solver","roots","isArray","solvers","updateStructure","chains","traversal","allChainJoints","traverseChains","frame","curr","chainSet","children","delete","independentChains","currChain","pop","otherChain","dependent","splice","nonChainJoints","root","traverse","results","s","Joint","Goal","args","setFreeDoF","rotCount","Number","includes","setDoF","X","Y","Z","serialize","frames","info","name","minDoFLimit","maxDoFLimit","position","quaternion","type","slice","closureJoints","inf","isLink","deserialize","data","Link","setMatrixNeedsUpdate","JOINT_STRIDE","LINK_STRIDE","generateSharedBuffer","arrayBuffer","SharedArrayBuffer","applyToBuffer","Float32Array","floatBuffer","byteBuffer","copyDoFValues","copyJointSettings","copyFrameToBuffer","applyFromBuffer","copyBufferToFrame","byteOffset","floatOffset","setPosition","setQuaternion","Boolean","changed","solveHandle","buffer","updateSolve","find","setTimeout","postMessage","global","onmessage","e","serialized","f","assign","clearTimeout"],"mappings":"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AAA,OAAA,GAAA,EAAA,EAAA,MAAA,IAAA,UAAA,yBAAA,IAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,MAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,IAAA,MAAA,GAAA,KAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,IAAA,MAAA,GAAA,KAAA,GAAA,IAAA,EAAA,EAAA,IAAA,MAAA,GAAA,KAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,KAAA,IAAA,EAAA,GAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IAAA,GAAA,EAAA,EAAA,GAAA,KAAA,EAAA,EAAA,EAAA,KAAA,KAAA,IAAA,KAAA,KAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,KAAA,IAAA,EAAA,GAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,MAAA,CAAA,IAAA,GAAA,EAAA,EAAA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,KAAA,IAAA,KAAA,KAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,IAAA,GAAA,EAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,OAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,CAAA,GAAA,MAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,OAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,GAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,IAAA,IAAA,EAAA,EAAA,EAAA,GAAA,IAAA,CAAA,IAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,CAAA,GAAA,KAAA,IAAA,EAAA,KAAA,EAAA,CAAA,GAAA,EAAA,MAAA,GAAA,KAAA,IAAA,EAAA,EAAA,KAAA,EAAA,MAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,KAAA,KAAA,IAAA,IAAA,IAAA,IAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAAA,KAAA,KAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,EAAA,CAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,IAAA,EAAA,GAAA,GAAA,MAAA,IAAA,EAAA,EAAA,GAAA,KAAA,EAAA,EAAA,EAAA,IAAA,IAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,MAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,KAAA,KAAA,EAAA,EAAA,GAAA,IAAA,EAAA,IAAA,EAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAAA,CAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KAAA,KAAA,EAAA,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","file":"workerSolver.worker.316d40ac.js","sourceRoot":"..\\example","sourcesContent":["/**\n * Gauss-Jordan elimination\n */\n\nvar linear = (function(){\n/**\n * Used internally to solve systems\n * If you want to solve A.x = B,\n * choose data=A and mirror=B.\n * mirror can be either an array representing a vector\n * or an array of arrays representing a matrix.\n */\nfunction Mat(data, mirror) {\n  // Clone the original matrix\n  this.data = new Array(data.length);\n  for (var i=0, cols=data[0].length; i<data.length; i++) {\n    this.data[i] = new Array(cols);\n    for(var j=0; j<cols; j++) {\n      this.data[i][j] = data[i][j];\n    }\n  }\n\n  if (mirror) {\n    if (typeof mirror[0] !== \"object\") {\n      for (var i=0; i<mirror.length; i++) {\n        mirror[i] = [mirror[i]];\n      }\n    }\n    this.mirror = new Mat(mirror);\n  }\n}\n\n/**\n * Swap lines i and j in the matrix\n */\nMat.prototype.swap = function (i, j) {\n  if (this.mirror) this.mirror.swap(i,j);\n  var tmp = this.data[i];\n  this.data[i] = this.data[j];\n  this.data[j] = tmp;\n}\n\n/**\n * Multiply line number i by l\n */\nMat.prototype.multline = function (i, l) {\n  if (this.mirror) this.mirror.multline(i,l);\n  var line = this.data[i];\n  for (var k=line.length-1; k>=0; k--) {\n    line[k] *= l;\n  }\n}\n\n/**\n * Add line number j multiplied by l to line number i\n */\nMat.prototype.addmul = function (i, j, l) {\n  if (this.mirror) this.mirror.addmul(i,j,l);\n  var lineI = this.data[i], lineJ = this.data[j];\n  for (var k=lineI.length-1; k>=0; k--) {\n    lineI[k] = lineI[k] + l*lineJ[k];\n  }\n}\n\n/**\n * Tests if line number i is composed only of zeroes\n */\nMat.prototype.hasNullLine = function (i) {\n  for (var j=0; j<this.data[i].length; j++) {\n    if (this.data[i][j] !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nMat.prototype.gauss = function() {\n  var pivot = 0,\n      lines = this.data.length,\n      columns = this.data[0].length,\n      nullLines = [];\n\n  for (var j=0; j<columns; j++) {\n    // Find the line on which there is the maximum value of column j\n    var maxValue = 0, maxLine = 0;\n    for (var k=pivot; k<lines; k++) {\n      var val = this.data[k][j];\n      if (Math.abs(val) > Math.abs(maxValue)) {\n        maxLine = k;\n        maxValue = val;\n      } \n    }\n    if (maxValue === 0) {\n      // The matrix is not invertible. The system may still have solutions.\n      nullLines.push(pivot);\n    } else {\n      // The value of the pivot is maxValue\n      this.multline(maxLine, 1/maxValue);\n      this.swap(maxLine, pivot);\n      for (var i=0; i<lines; i++) {\n        if (i !== pivot) {\n          this.addmul(i, pivot, -this.data[i][j]);\n        }\n      }\n    }\n    pivot++;\n  }\n\n  // Check that the system has null lines where it should\n  for (var i=0; i<nullLines.length; i++) {\n    if (!this.mirror.hasNullLine(nullLines[i])) {\n      throw new Error(\"singular matrix\");\n    }\n  }\n  return this.mirror.data;\n}\n\n/**\n * Solves A.x = b\n * @param A\n * @param b\n * @return x\n */\nexports.solve = function solve(A, b) {\n  var result = new Mat(A,b).gauss();\n  if (result.length > 0 && result[0].length === 1) {\n    // Convert Nx1 matrices to simple javascript arrays\n    for (var i=0; i<result.length; i++) result[i] = result[i][0];\n  }\n  return result;\n}\n\nfunction identity(n) {\n  var id = new Array(n);\n  for (var i=0; i<n; i++) {\n    id[i] = new Array(n);\n    for (var j=0; j<n; j++) {\n      id[i][j] = (i === j) ? 1 : 0;\n    }\n  }\n  return id;\n}\n\n/**\n * invert a matrix\n */\nexports.invert = function invert(A) {\n  return new Mat(A, identity(A.length)).gauss();\n}\n\nreturn exports;\n})();\n\nif (typeof module.exports === \"object\") module.exports = linear;\n","!function(r,f){\"object\"==typeof exports&&\"undefined\"!=typeof module?f(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],f):f((r=\"undefined\"!=typeof globalThis?globalThis:r||self).SVDJS={})}(this,function(r){\"use strict\";r.SVD=function(r,f,o,e,t){if(f=void 0===f||f,o=void 0===o||o,t=1e-64/(e=e||Math.pow(2,-52)),!r)throw new TypeError(\"Matrix a is not defined\");var i,a,n,s,h,l,M,d,p,b,u,w,y=r[0].length,q=r.length;if(q<y)throw new TypeError(\"Invalid matrix: m < n\");for(var v=[],c=[],x=[],g=\"f\"===f?q:y,m=b=M=0;m<q;m++)c[m]=new Array(g).fill(0);for(m=0;m<y;m++)x[m]=new Array(y).fill(0);var S,T=new Array(y).fill(0);for(m=0;m<q;m++)for(i=0;i<y;i++)c[m][i]=r[m][i];for(m=0;m<y;m++){for(v[m]=M,p=0,n=m+1,i=m;i<q;i++)p+=Math.pow(c[i][m],2);if(p<t)M=0;else for(d=(l=c[m][m])*(M=l<0?Math.sqrt(p):-Math.sqrt(p))-p,c[m][m]=l-M,i=n;i<y;i++){for(p=0,a=m;a<q;a++)p+=c[a][m]*c[a][i];for(l=p/d,a=m;a<q;a++)c[a][i]=c[a][i]+l*c[a][m]}for(T[m]=M,p=0,i=n;i<y;i++)p+=Math.pow(c[m][i],2);if(p<t)M=0;else{for(d=(l=c[m][m+1])*(M=l<0?Math.sqrt(p):-Math.sqrt(p))-p,c[m][m+1]=l-M,i=n;i<y;i++)v[i]=c[m][i]/d;for(i=n;i<q;i++){for(p=0,a=n;a<y;a++)p+=c[i][a]*c[m][a];for(a=n;a<y;a++)c[i][a]=c[i][a]+p*v[a]}}b<(u=Math.abs(T[m])+Math.abs(v[m]))&&(b=u)}if(o)for(m=y-1;0<=m;m--){if(0!==M){for(d=c[m][m+1]*M,i=n;i<y;i++)x[i][m]=c[m][i]/d;for(i=n;i<y;i++){for(p=0,a=n;a<y;a++)p+=c[m][a]*x[a][i];for(a=n;a<y;a++)x[a][i]=x[a][i]+p*x[a][m]}}for(i=n;i<y;i++)x[m][i]=0,x[i][m]=0;x[m][m]=1,M=v[m],n=m}if(f){if(\"f\"===f)for(m=y;m<q;m++){for(i=y;i<q;i++)c[m][i]=0;c[m][m]=1}for(m=y-1;0<=m;m--){for(n=m+1,M=T[m],i=n;i<g;i++)c[m][i]=0;if(0!==M){for(d=c[m][m]*M,i=n;i<g;i++){for(p=0,a=n;a<q;a++)p+=c[a][m]*c[a][i];for(l=p/d,a=m;a<q;a++)c[a][i]=c[a][i]+l*c[a][m]}for(i=m;i<q;i++)c[i][m]=c[i][m]/M}else for(i=m;i<q;i++)c[i][m]=0;c[m][m]=c[m][m]+1}}for(e*=b,a=y-1;0<=a;a--)for(var k=0;k<50;k++){for(S=!1,n=a;0<=n;n--){if(Math.abs(v[n])<=e){S=!0;break}if(Math.abs(T[n-1])<=e)break}if(!S)for(h=0,s=n-(p=1),m=n;m<a+1&&(l=p*v[m],v[m]=h*v[m],!(Math.abs(l)<=e));m++)if(M=T[m],T[m]=Math.sqrt(l*l+M*M),h=M/(d=T[m]),p=-l/d,f)for(i=0;i<q;i++)u=c[i][s],w=c[i][m],c[i][s]=u*h+w*p,c[i][m]=-u*p+w*h;if(w=T[a],n===a){if(w<0&&(T[a]=-w,o))for(i=0;i<y;i++)x[i][a]=-x[i][a];break}for(b=T[n],l=(((u=T[a-1])-w)*(u+w)+((M=v[a-1])-(d=v[a]))*(M+d))/(2*d*u),M=Math.sqrt(l*l+1),l=((b-w)*(b+w)+d*(u/(l<0?l-M:l+M)-d))/b,m=n+(p=h=1);m<a+1;m++){if(M=v[m],u=T[m],d=p*M,M*=h,w=Math.sqrt(l*l+d*d),l=b*(h=l/(v[m-1]=w))+M*(p=d/w),M=-b*p+M*h,d=u*p,u*=h,o)for(i=0;i<y;i++)b=x[i][m-1],w=x[i][m],x[i][m-1]=b*h+w*p,x[i][m]=-b*p+w*h;if(w=Math.sqrt(l*l+d*d),l=(h=l/(T[m-1]=w))*M+(p=d/w)*u,b=-p*M+h*u,f)for(i=0;i<q;i++)u=c[i][m-1],w=c[i][m],c[i][m-1]=u*h+w*p,c[i][m]=-u*p+w*h}v[n]=0,v[a]=l,T[a]=b}for(m=0;m<y;m++)T[m]<e&&(T[m]=0);return{u:c,q:T,v:x}},r.VERSION=\"1.1.1\",Object.defineProperty(r,\"__esModule\",{value:!0})});\n","import linearSolve from 'linear-solve';\r\nimport { SVD } from 'svd-js';\r\n\r\nfunction transpose( outMatrix, a ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ c ][ r ] = a[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction identity( outMatrix ) {\r\n\r\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = r === c ? 1 : 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction scale( outMatrix, matrix, scalar ) {\r\n\r\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = matrix[ r ][ c ] * scalar;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction multiply( outMatrix, a, b ) {\r\n\r\n\tif ( a === b ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n\t// a is m x n\r\n\t// b is n x k\r\n\t// outMatrix is m x k\r\n\r\n\t// m = a rows\r\n\t// n = a cols or b rows\r\n\t// k = b cols\r\n\r\n\tconst m = a.length;\r\n\tconst n = b.length;\r\n\tconst k = b[ 0 ].length;\r\n\r\n\t// iterate over m\r\n\tfor ( let r = 0, tr = m; r < tr; r ++ ) {\r\n\r\n\t\t// iterate over k\r\n\t\tfor ( let c = 0, tc = k; c < tc; c ++ ) {\r\n\r\n\t\t\tlet sum = 0;\r\n\r\n\t\t\t// iterate over n\r\n\t\t\tfor ( let i = 0, ti = n; i < ti; i ++ ) {\r\n\r\n\t\t\t\tsum += a[ r ][ i ] * b[ i ][ c ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutMatrix[ r ][ c ] = sum;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction create( row, col ) {\r\n\r\n\tconst result = new Array( row );\r\n\tfor ( let i = 0; i < row; i ++ ) {\r\n\r\n\t\tresult[ i ] = new Float64Array( col );\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction copy( outMatrix, sourceMatrix ) {\r\n\r\n\tconst tr = sourceMatrix.length;\r\n\tconst tc = sourceMatrix[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = sourceMatrix[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction clone( matrix ) {\r\n\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tconst resultMatrix = create( rows, cols );\r\n\tcopy( resultMatrix, matrix );\r\n\treturn resultMatrix;\r\n\r\n}\r\n\r\nfunction solve( outMatrix, matrix, vector ) {\r\n\r\n\tconst res = linearSolve.solve( matrix, vector );\r\n\tfor ( let i = 0, l = res.length; i < l; i ++ ) {\r\n\r\n\t\toutMatrix[ i ].set( res[ i ] );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction svd( ru, rq, rv, matrix ) {\r\n\r\n\tconst { u, v, q } = SVD( matrix );\r\n\r\n\tconst urows = u.length;\r\n\tfor ( let r = 0; r < urows; r ++ ) {\r\n\r\n\t\tru[ r ].set( u[ r ] );\r\n\r\n\t}\r\n\r\n\tconst vrows = v.length;\r\n\tfor ( let r = 0; r < vrows; r ++ ) {\r\n\r\n\t\trv[ r ].set( v[ r ] );\r\n\r\n\t}\r\n\r\n\tconst qrows = q.length;\r\n\tfor ( let r = 0; r < qrows; r ++ ) {\r\n\r\n\t\tconst rqrow = rq[ r ];\r\n\t\tconst qval = q[ r ];\r\n\t\trqrow.fill( 0 );\r\n\t\trqrow[ r ] = qval;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction invert( outMatrix, matrix ) {\r\n\r\n\tconst res = linearSolve.invert( matrix );\r\n\r\n\tconst tr = matrix[ 0 ].length;\r\n\tconst tc = matrix.length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = res[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction add( outMatrix, a, b ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] + b[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction subtract( outMatrix, a, b ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] - b[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction magnitudeSquared( matrix ) {\r\n\r\n\tlet sum = 0;\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tfor ( let r = 0; r < rows; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < cols; c ++ ) {\r\n\r\n\t\t\tsum += matrix[ r ][ c ] ** 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn sum;\r\n\r\n}\r\n\r\nfunction magnitude( matrix ) {\r\n\r\n\treturn Math.sqrt( magnitudeSquared( matrix ) );\r\n\r\n}\r\n\r\nfunction toString( matrix, dec = 3 ) {\r\n\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tlet str = '';\r\n\tfor ( let r = 0; r < rows; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < cols; c ++ ) {\r\n\r\n\t\t\tstr += matrix[ r ][ c ].toFixed( dec ) + ', ';\r\n\r\n\t\t}\r\n\r\n\t\tstr += '\\n';\r\n\r\n\t}\r\n\r\n\treturn str;\r\n\r\n}\r\n\r\nfunction log( matrix, dec ) {\r\n\r\n\tconsole.log( toString( matrix, dec ) );\r\n\r\n}\r\n\r\nexport const mat = {\r\n\ttranspose,\r\n\tidentity,\r\n\tscale,\r\n\tmultiply,\r\n\tcreate,\r\n\tcopy,\r\n\tclone,\r\n\tsolve,\r\n\tsvd,\r\n\tinvert,\r\n\tadd,\r\n\tsubtract,\r\n\tmagnitudeSquared,\r\n\tmagnitude,\r\n\ttoString,\r\n\tlog,\r\n};\r\n","import { mat } from './utils/matrix.js';\r\n\r\nclass FixedMatrixPool {\r\n\r\n\tconstructor( row, col ) {\r\n\r\n\t\tconst matrices = [];\r\n\t\tlet index = 0;\r\n\r\n\t\tthis.get = function () {\r\n\r\n\t\t\tlet matrix = matrices[ index ];\r\n\t\t\tif ( ! matrix ) {\r\n\r\n\t\t\t\tmatrices[ index ] = matrix = mat.create( row, col );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex ++;\r\n\t\t\treturn matrix;\r\n\r\n\t\t};\r\n\r\n\t\tthis.releaseAll = function () {\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class MatrixPool {\r\n\r\n\tconstructor() {\r\n\r\n\t\tconst pools = {};\r\n\t\tconst poolArray = [];\r\n\t\tthis.get = function ( row, col ) {\r\n\r\n\t\t\tlet colPools = pools[ row ];\r\n\t\t\tif ( ! colPools ) {\r\n\r\n\t\t\t\tcolPools = pools[ row ] = {};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet pool = colPools[ col ];\r\n\t\t\tif ( ! pool ) {\r\n\r\n\t\t\t\tpool = colPools[ col ] = new FixedMatrixPool( row, col );\r\n\t\t\t\tpoolArray.push( pool );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn pool.get();\r\n\r\n\t\t};\r\n\r\n\t\tthis.releaseAll = function () {\r\n\r\n\t\t\tfor ( let i = 0, l = poolArray.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tpoolArray[ i ].releaseAll();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","import { vec3, vec4 } from 'gl-matrix';\r\nimport { DOF } from '../Joint.js';\r\n\r\nconst tempPos = new Float64Array( 3 );\r\nconst tempQuat = new Float64Array( 4 );\r\nconst tempEuler = new Float64Array( 3 );\r\nexport function accumulateClosureError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\tdofFlags,\r\n\t\tdof,\r\n\t} = joint;\r\n\r\n\t// Get the error from child towards the closure target\r\n\tjoint.getClosureError( tempPos, tempQuat );\r\n\r\n\tlet rowCount = 7;\r\n\tif ( joint.isGoal ) {\r\n\r\n\t\ttempPos[ 0 ] *= dofFlags[ 0 ];\r\n\t\ttempPos[ 1 ] *= dofFlags[ 1 ];\r\n\t\ttempPos[ 2 ] *= dofFlags[ 2 ];\r\n\t\trowCount = translationDoFCount;\r\n\r\n\t\tif ( rotationDoFCount === 0 ) {\r\n\r\n\t\t\ttempQuat[ 0 ] = 0;\r\n\t\t\ttempQuat[ 1 ] = 0;\r\n\t\t\ttempQuat[ 2 ] = 0;\r\n\t\t\ttempQuat[ 3 ] = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trowCount += 4;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tlet isConverged = false;\r\n\tlet totalError = 0;\r\n\tconst posMag = vec3.length( tempPos );\r\n\tconst rotMag = vec4.length( tempQuat );\r\n\tif (\r\n\t\tposMag < translationConvergeThreshold &&\r\n\t\trotMag < rotationConvergeThreshold\r\n\t) {\r\n\r\n\t\tisConverged = true;\r\n\r\n\t}\r\n\r\n\ttotalError += posMag + rotMag;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tif ( posMag > translationErrorClamp ) {\r\n\r\n\t\t\tvec3.scale( tempPos, tempPos, translationErrorClamp / posMag );\r\n\r\n\t\t}\r\n\r\n\t\tvec4.scale( tempPos, tempPos, translationFactor );\r\n\r\n\t\tif ( rotMag > rotationErrorClamp ) {\r\n\r\n\t\t\tvec4.scale( tempQuat, tempQuat, rotationErrorClamp / rotMag );\r\n\r\n\t\t}\r\n\r\n\t\tvec4.scale( tempQuat, tempQuat, rotationFactor );\r\n\r\n\t\tif ( joint.isGoal ) {\r\n\r\n\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\r\n\r\n\t\t\t\tconst d = dof[ i ];\r\n\t\t\t\terrorVector[ startIndex + i ][ 0 ] = tempPos[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joint.rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 0 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 1 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 2 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 3 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\terrorVector[ startIndex + 0 ][ 0 ] = tempPos[ 0 ];\r\n\t\t\terrorVector[ startIndex + 1 ][ 0 ] = tempPos[ 1 ];\r\n\t\t\terrorVector[ startIndex + 2 ][ 0 ] = tempPos[ 2 ];\r\n\r\n\t\t\terrorVector[ startIndex + 3 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\terrorVector[ startIndex + 4 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\terrorVector[ startIndex + 5 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\terrorVector[ startIndex + 6 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tresult.totalError = totalError;\r\n\tresult.isConverged = isConverged;\r\n\tresult.rowCount = rowCount;\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function accumulateTargetError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\t// Find whether or not the target has converged or not\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\tlockedJointDoFCount,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\tlockedJointDoF,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\tdofTarget,\r\n\t\tdofValues,\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t\tdofList,\r\n\t} = joint;\r\n\r\n\t// get the position delta\r\n\tconst posDelta = vec3.distance( dofValues, dofTarget );\r\n\r\n\t// TODO: if three euler angles are being used we should set this to a quaternion to measure\r\n\t// error rather than euler angles. We should instead just always use quaternions for targets\r\n\t// for now.\r\n\t// Before running this solver we try to ensure the target and restPose are minimized\r\n\tlet rotDelta =\r\n\t\tdofTarget[ DOF.EX ] - dofValues[ DOF.EX ] +\r\n\t\tdofTarget[ DOF.EY ] - dofValues[ DOF.EY ] +\r\n\t\tdofTarget[ DOF.EZ ] - dofValues[ DOF.EZ ];\r\n\r\n\t// Get the row count\r\n\tconst lockedDoFCount = lockedJointDoFCount.get( joint ) || 0;\r\n\tresult.rowCount = translationDoFCount + rotationDoFCount - lockedDoFCount;\r\n\tresult.isConverged = posDelta < translationConvergeThreshold && rotDelta < rotationConvergeThreshold;\r\n\tresult.totalError = posDelta + rotDelta;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tconst lockedDoF = lockedJointDoF.get( joint );\r\n\t\tconst isLocked = lockedDoFCount !== 0;\r\n\r\n\t\tlet rowIndex = 0;\r\n\r\n\t\t// error from current state to target\r\n\t\ttempPos[ 0 ] = dofTarget[ 0 ] - dofValues[ 0 ];\r\n\t\ttempPos[ 1 ] = dofTarget[ 1 ] - dofValues[ 1 ];\r\n\t\ttempPos[ 2 ] = dofTarget[ 2 ] - dofValues[ 2 ];\r\n\r\n\t\t// clamp the position delta to the max error step\r\n\t\tconst posMag = vec3.length( tempPos );\r\n\t\tvec3.scale( tempPos, tempPos, translationFactor * translationErrorClamp / posMag );\r\n\t\tfor ( let i = 0, l = translationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempPos[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// get the euler differences\r\n\t\t// before running this solver we minimize the euler targets\r\n\t\ttempEuler[ 0 ] = joint.dofTarget[ 3 ] - joint.dofValues[ 3 ];\r\n\t\ttempEuler[ 1 ] = joint.dofTarget[ 4 ] - joint.dofValues[ 4 ];\r\n\t\ttempEuler[ 2 ] = joint.dofTarget[ 5 ] - joint.dofValues[ 5 ];\r\n\r\n\t\t// clamp the euler difference to the error step magnitude\r\n\t\tconst eulerMag = vec3.length( tempEuler );\r\n\t\tvec3.scale( tempEuler, tempEuler, rotationFactor * rotationErrorClamp / eulerMag );\r\n\t\tfor ( let i = translationDoFCount, l = translationDoFCount + rotationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempEuler[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { vec3, vec4, mat4 } from 'gl-matrix';\r\nimport { MatrixPool } from './MatrixPool.js';\r\nimport { accumulateClosureError, accumulateTargetError } from './utils/solver.js';\r\nimport { mat } from './utils/matrix.js';\r\nimport { getMatrixDifference } from './utils/glmatrix.js';\r\n\r\n// global stores\r\nconst matrixPool = new MatrixPool();\r\n\r\n// temp reusable variables\r\nconst targetRelativeToJointMatrix = new Float64Array( 16 );\r\nconst targetDeltaWorldMatrix = new Float64Array( 16 );\r\nconst tempDeltaWorldMatrix = new Float64Array( 16 );\r\nconst tempInverseMatrixWorld = new Float64Array( 16 );\r\nconst tempQuat = new Float64Array( 4 );\r\nconst tempPos = new Float64Array( 3 );\r\nconst tempQuat2 = new Float64Array( 4 );\r\nconst tempPos2 = new Float64Array( 3 );\r\n\r\nconst targetJoints = [];\r\nconst freeJoints = [];\r\nconst errorResultInfo = {\r\n\trowCount: 0,\r\n\tisConverged: false,\r\n\ttotalError: 0,\r\n};\r\nconst dofResultInfo = {\r\n\terrorRows: 0,\r\n\tfreeDoF: 0,\r\n\ttotalError: 0,\r\n};\r\n\r\nexport const SOLVE_STATUS = {\r\n\r\n\tCONVERGED: 0,\r\n\tSTALLED: 1,\r\n\tDIVERGED: 2,\r\n\tTIMEOUT: 3,\r\n\r\n};\r\n\r\nexport const SOLVE_STATUS_NAMES = Object.entries( SOLVE_STATUS ).sort( ( a, b ) => a[ 1 ] - b[ 1 ] ).map( el => el[ 0 ] );\r\n\r\nexport class ChainSolver {\r\n\r\n\tconstructor( chain ) {\r\n\r\n\t\tthis.chain = Array.from( chain );\r\n\r\n\t\t// list of targets we're trying to minimize in the chain\r\n\t\tthis.targets = null;\r\n\r\n\t\t// map of joint -> closures that the given jointa affects\r\n\t\tthis.affectedClosures = null;\r\n\r\n\t\t// map of joint -> closure children that the given joint affects\r\n\t\tthis.affectedConnectedClosures = null;\r\n\r\n\t\t// map of joint -> that stores the amount of DoF that are locked after\r\n\t\t// hitting a joint limit.\r\n\t\t// Undefined or 0 if none are locked\r\n\t\tthis.lockedJointDoFCount = null;\r\n\r\n\t\t// map of joint -> list of locked DoF\r\n\t\tthis.lockedJointDoF = null;\r\n\r\n\t\t// map of joint -> previous joint angles for resetting joint angles on\r\n\t\t// divergence check.\r\n\t\tthis.prevDoFValues = null;\r\n\r\n\t\t// options -- these are set by the containing Solver.\r\n\t\tthis.maxIterations = - 1;\r\n\r\n\t\tthis.useSVD = false;\r\n\r\n\t\tthis.translationConvergeThreshold = - 1;\r\n\t\tthis.rotationConvergeThreshold = - 1;\r\n\r\n\t\tthis.translationFactor = - 1;\r\n\t\tthis.rotationFactor = - 1;\r\n\r\n\t\tthis.translationStep = - 1;\r\n\t\tthis.rotationStep = - 1;\r\n\r\n\t\tthis.translationErrorClamp = - 1;\r\n\t\tthis.rotationErrorClamp = - 1;\r\n\r\n\t\tthis.stallThreshold = - 1;\r\n\t\tthis.dampingFactor = - 1;\r\n\t\tthis.divergeThreshold = - 1;\r\n\t\tthis.restPoseFactor = - 1;\r\n\r\n\t\tthis.init();\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\r\n\t\t// Find all joints with targets.\r\n\t\tconst chain = this.chain;\r\n\t\tconst targets = chain.filter( j => j.targetSet || j.isClosure );\r\n\r\n\t\tconst lockedJointDoF = new Map();\r\n\t\tconst lockedJointDoFCount = new Map();\r\n\t\tconst prevDoFValues = new Map();\r\n\r\n\t\tconst affectedClosures = new Map();\r\n\t\tconst affectedConnectedClosures = new Map();\r\n\t\tchain.forEach( j => {\r\n\r\n\t\t\t// Track which joints will have a direct affect on which targets move\r\n\t\t\t// for closure end effectors.\r\n\t\t\taffectedClosures.set( j, new Set() );\r\n\t\t\taffectedConnectedClosures.set( j, new Set() );\r\n\r\n\t\t\t// Initialize our array with all possible degrees of freedom\r\n\t\t\tlockedJointDoF.set( j, new Uint8Array( 6 ) );\r\n\t\t\tprevDoFValues.set( j, new Float64Array( 6 ) );\r\n\r\n\t\t} );\r\n\r\n\t\ttargets.forEach( target => {\r\n\r\n\t\t\tif ( target.isClosure ) {\r\n\r\n\t\t\t\tlet currJoint = target;\r\n\r\n\t\t\t\t// climb the joint tree and mark every joint as affecting this closure end.\r\n\t\t\t\twhile ( currJoint ) {\r\n\r\n\t\t\t\t\tif ( currJoint.isJoint ) {\r\n\r\n\t\t\t\t\t\taffectedClosures.get( currJoint ).add( target );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrJoint = currJoint.parent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// and mark the joints up the other chain as effecting the other connector link.\r\n\t\t\t\tcurrJoint = target.child;\r\n\t\t\t\twhile ( currJoint ) {\r\n\r\n\t\t\t\t\tif ( currJoint.isJoint ) {\r\n\r\n\t\t\t\t\t\taffectedConnectedClosures.get( currJoint ).add( target );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrJoint = currJoint.parent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tthis.targets = targets;\r\n\t\tthis.affectedClosures = affectedClosures;\r\n\t\tthis.affectedConnectedClosures = affectedConnectedClosures;\r\n\t\tthis.lockedJointDoF = lockedJointDoF;\r\n\t\tthis.lockedJointDoFCount = lockedJointDoFCount;\r\n\t\tthis.prevDoFValues = prevDoFValues;\r\n\r\n\t}\r\n\r\n\tsolve() {\r\n\r\n\t\tconst {\r\n\t\t\tdivergeThreshold,\r\n\t\t\tstallThreshold,\r\n\t\t\tchain,\r\n\t\t\trestPoseFactor,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t\tprevDoFValues,\r\n\t\t\tuseSVD,\r\n\t\t} = this;\r\n\r\n\t\tlet iterations = 0;\r\n\t\tlet prevErrorMagnitude = Infinity;\r\n\t\tlet status = - 1;\r\n\r\n\t\t// Clear out all the locked joints\r\n\t\tlockedJointDoFCount.clear();\r\n\r\n\t\t// TODO: instead of trying to use minimal euler angles we should try to represent joint\r\n\t\t// error as a quaternion in the quaternion vector.\r\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst joint = chain[ i ];\r\n\t\t\tif ( joint.targetSet || joint.restPoseSet ) {\r\n\r\n\t\t\t\tjoint.tryMinimizeEulerAngles();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdo {\r\n\r\n\t\t\tmatrixPool.releaseAll();\r\n\r\n\t\t\t// Make sure our matrices are all up to date\r\n\t\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst joint = chain[ i ];\r\n\t\t\t\tjoint.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: this only needs to be recomputed if a joint was locked so maybe lets check that? We also\r\n\t\t\t// lock joints inside this function so maybe we can forgo that?\r\n\t\t\ttargetJoints.length = 0;\r\n\t\t\tfreeJoints.length = 0;\r\n\t\t\tthis.countUnconvergedVariables( freeJoints, targetJoints, dofResultInfo );\r\n\t\t\tconst { freeDoF, errorRows, totalError } = dofResultInfo;\r\n\r\n\t\t\t// Check if we've converged\r\n\t\t\tif ( errorRows === 0 ) {\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.CONVERGED;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check if we've diverged\r\n\t\t\tif ( totalError > prevErrorMagnitude + divergeThreshold ) {\r\n\r\n\t\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\r\n\r\n\t\t\t\t\tjoint.dofValues.set( dofValues );\r\n\t\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t\t\t} );\r\n\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.DIVERGED;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevErrorMagnitude = totalError;\r\n\r\n\t\t\t// Check if we've hit max iterations\r\n\t\t\titerations ++;\r\n\t\t\tif ( iterations > this.maxIterations ) {\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.TIMEOUT;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// A * x = b\r\n\t\t\t// find x such that it yields b where is the clamped error we're trying to work towards\r\n\t\t\t// and A is the jacobian, and x is the delta joint angles.\r\n\r\n\t\t\tconst errorVector = matrixPool.get( errorRows, 1 );\r\n\t\t\tthis.fillErrorVector( targetJoints, errorVector );\r\n\r\n\t\t\tconst jacobian = matrixPool.get( errorRows, freeDoF );\r\n\t\t\tthis.fillJacobian( targetJoints, freeJoints, jacobian );\r\n\r\n\t\t\t// Solve for the pseudo inverse of the jacobian\r\n\t\t\tconst pseudoInverse = matrixPool.get( freeDoF, errorRows );\r\n\t\t\tif ( useSVD ) {\r\n\r\n\t\t\t\tconst m = errorRows;\r\n\t\t\t\tconst n = freeDoF;\r\n\t\t\t\tconst k = Math.min( m, n );\r\n\r\n\t\t\t\tconst u = matrixPool.get( m, k ); // m x k\r\n\t\t\t\tconst q = matrixPool.get( k, k ); // k x k\r\n\t\t\t\tconst v = matrixPool.get( n, k ); // ( k x n )^T -> ( n x k )\r\n\r\n\t\t\t\tmat.svd( u, q, v, jacobian );\r\n\r\n\t\t\t\tconst vt = matrixPool.get( k, n );\r\n\t\t\t\tconst ut = matrixPool.get( k, m );\r\n\t\t\t\tconst qinv = matrixPool.get( k, k );\r\n\t\t\t\tmat.transpose( vt, v );\r\n\t\t\t\tmat.transpose( ut, u );\r\n\r\n\t\t\t\t// if the diagonal value is close to 0 when taking the inverse\r\n\t\t\t\t// then set it to zero.\r\n\t\t\t\tfor ( let i = 0, l = q.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst val = q[ i ][ i ];\r\n\t\t\t\t\tlet inv;\r\n\t\t\t\t\tif ( Math.abs( val ) < 0.001 ) {\r\n\r\n\t\t\t\t\t\tinv = 0;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tinv = 1 / val;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tqinv[ i ][ i ] = inv;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// V * Qinv * Ut\r\n\t\t\t\tconst vqinv = matrixPool.get( n, k );\r\n\t\t\t\tmat.multiply( vqinv, v, qinv );\r\n\t\t\t\tmat.multiply( pseudoInverse, vqinv, ut );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Use a transpose pseudo inverse approach: A^T * A * x = A^T * b with the damping term\r\n\t\t\t\t// J^T * J * x = J^T * e\r\n\t\t\t\t// x = J^T * ( J * J^T )^-1 * e\r\n\r\n\t\t\t\t// and with the adding damping\r\n\t\t\t\t// x = J^T * ( J * J^T + l^2 * I )^-1 * e\r\n\r\n\t\t\t\t// l^2 * I\r\n\t\t\t\tconst jacobianIdentityDamping = matrixPool.get( errorRows, errorRows );\r\n\t\t\t\tmat.identity( jacobianIdentityDamping );\r\n\t\t\t\tmat.scale( jacobianIdentityDamping, jacobianIdentityDamping, this.dampingFactor ** 2 );\r\n\r\n\t\t\t\t// J^T\r\n\t\t\t\tconst jacobianTranspose = matrixPool.get( freeDoF, errorRows );\r\n\t\t\t\tmat.transpose( jacobianTranspose, jacobian );\r\n\r\n\t\t\t\t// J * J^T\r\n\t\t\t\tconst jjt = matrixPool.get( errorRows, errorRows );\r\n\t\t\t\tmat.multiply( jjt, jacobian, jacobianTranspose );\r\n\r\n\t\t\t\t// J * J^T + l^2 * I\r\n\t\t\t\tconst jjti = matrixPool.get( errorRows, errorRows );\r\n\t\t\t\tmat.add( jjti, jjt, jacobianIdentityDamping );\r\n\r\n\t\t\t\t// ( J * J^T + l^2 * I )^-1\r\n\t\t\t\tconst jjtii = matrixPool.get( errorRows, errorRows );\r\n\t\t\t\tmat.invert( jjtii, jjti );\r\n\r\n\t\t\t\t// J^T * ( J * J^T + l^2 * I )^-1\r\n\t\t\t\tmat.multiply( pseudoInverse, jacobianTranspose, jjtii );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// x = deltaTheta = J^T * ( J * J^T + l^2 * I )^-1 * e\r\n\t\t\tconst deltaTheta = matrixPool.get( freeDoF, 1 );\r\n\t\t\tmat.multiply( deltaTheta, pseudoInverse, errorVector );\r\n\r\n\t\t\t// console.log( 'ERROR VECTOR', errorVector );\r\n\t\t\t// console.log( 'JACOBIAN', jacobian );\r\n\t\t\t// console.log( 'DELTA_THETA', deltaTheta );\r\n\r\n\t\t\tif ( restPoseFactor !== 0 ) {\r\n\r\n\t\t\t\t// Nullspace Projection\r\n\t\t\t\t// I - J^-1 * J is the orthogonal null space of J where J^-1 is the pseudoinverse\r\n\t\t\t\t// Multiplied by the rest position of each dof\r\n\t\t\t\t// ( I - J^-1 * J ) * restPose\r\n\t\t\t\tconst restPose = matrixPool.get( freeDoF, 1 );\r\n\t\t\t\tconst restPoseResult = matrixPool.get( freeDoF, 1 );\r\n\t\t\t\tlet colIndex = 0;\r\n\t\t\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst joint = freeJoints[ i ];\r\n\t\t\t\t\tconst lockedDoFCount = this.lockedJointDoFCount.get( joint ) || 0;\r\n\t\t\t\t\tconst isLocked = lockedDoFCount !== 0;\r\n\t\t\t\t\tconst lockedDoF = this.lockedJointDoF.get( joint );\r\n\r\n\t\t\t\t\tconst colCount = joint.rotationDoFCount + joint.translationDoFCount - lockedDoFCount;\r\n\t\t\t\t\tif ( joint.restPoseSet ) {\r\n\r\n\t\t\t\t\t\tconst dofList = joint.dof;\r\n\t\t\t\t\t\tconst dofValues = joint.dofValues;\r\n\t\t\t\t\t\tconst dofRestPose = joint.dofRestPose;\r\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\r\n\r\n\t\t\t\t\t\t\t// NOTE: this is reversed because in applyAngles we're having to negate the\r\n\t\t\t\t\t\t\t// delta angles for some reason atm\r\n\t\t\t\t\t\t\tconst dof = dofList[ d ];\r\n\r\n\t\t\t\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) continue;\r\n\r\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = dofValues[ dof ] - dofRestPose[ dof ];\r\n\t\t\t\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\r\n\r\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = 0;\r\n\t\t\t\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// J^-1 * J\r\n\t\t\t\tconst jij = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.multiply( jij, pseudoInverse, jacobian );\r\n\r\n\t\t\t\t// ( I - J^-1 * J )\r\n\t\t\t\tconst ident = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.identity( ident );\r\n\r\n\t\t\t\tconst nullSpaceProjection = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.subtract( nullSpaceProjection, ident, jij );\r\n\r\n\t\t\t\t// ( I - J^-1 * J ) * restPose\r\n\t\t\t\tmat.multiply( restPoseResult, nullSpaceProjection, restPose );\r\n\r\n\t\t\t\tfor ( let r = 0; r < freeDoF; r ++ ) {\r\n\r\n\t\t\t\t\tconst val = restPoseResult[ r ][ 0 ];\r\n\t\t\t\t\tdeltaTheta[ r ][ 0 ] += val * restPoseFactor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check if our joints have not moved and returned stalled\r\n\t\t\tif ( stallThreshold > 0 ) {\r\n\r\n\t\t\t\tlet stalled = true;\r\n\t\t\t\tfor ( let i = 0, l = deltaTheta.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst delta = deltaTheta[ i ][ 0 ];\r\n\t\t\t\t\tif ( Math.abs( delta ) > stallThreshold ) {\r\n\r\n\t\t\t\t\t\tstalled = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( stalled ) {\r\n\r\n\t\t\t\t\tstatus = SOLVE_STATUS.STALLED;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Prep for a divergence check\r\n\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\r\n\r\n\t\t\t\tdofValues.set( joint.dofValues );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\t// apply the latest joint angles and lock and joints that have\r\n\t\t\t// hit their joint limits.\r\n\t\t\tthis.applyJointAngles( freeJoints, deltaTheta );\r\n\r\n\t\t\t// there's still error and we're under the max iterations\r\n\r\n\t\t} while ( true );\r\n\r\n\t\ttargetJoints.length = 0;\r\n\t\tfreeJoints.length = 0;\r\n\t\treturn status;\r\n\r\n\t}\r\n\r\n\t// Apply the delta values from the solve to the free joints in the list\r\n\tapplyJointAngles( freeJoints, deltaTheta ) {\r\n\r\n\t\tconst {\r\n\t\t\tlockedJointDoF,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t} = this;\r\n\r\n\t\tlet lockedJoint = false;\r\n\t\tlet dti = 0;\r\n\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\t// Apply the delta to every free joint\r\n\t\t\tconst joint = freeJoints[ i ];\r\n\t\t\tconst dofList = joint.dof;\r\n\t\t\tconst lockedDoF = lockedJointDoF.get( joint );\r\n\t\t\tconst isLocked = lockedJointDoFCount.has( joint );\r\n\r\n\t\t\tfor ( let d = 0, l = dofList.length; d < l; d ++ ) {\r\n\r\n\t\t\t\tconst dof = dofList[ d ];\r\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: why are we negating here?\r\n\t\t\t\tconst value = joint.getDoFValue( dof );\r\n\t\t\t\tconst hitLimit = joint.setDoFValue( dof, value - deltaTheta[ dti ][ 0 ] );\r\n\r\n\t\t\t\t// lock the joint if we hit a limit\r\n\t\t\t\tif ( hitLimit ) {\r\n\r\n\t\t\t\t\tif ( ! lockedJointDoFCount.has( joint ) ) {\r\n\r\n\t\t\t\t\t\tlockedJointDoFCount.set( joint, 0 );\r\n\t\t\t\t\t\tlockedDoF.fill( 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst lockedCount = lockedJointDoFCount.get( joint );\r\n\t\t\t\t\tlockedJointDoFCount.set( joint, lockedCount + 1 );\r\n\t\t\t\t\tlockedDoF[ dof ] = 1;\r\n\t\t\t\t\tlockedJoint = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dti !== deltaTheta.length ) {\r\n\r\n\t\t\tthrow new Error();\r\n\r\n\t\t}\r\n\r\n\t\treturn lockedJoint;\r\n\r\n\t}\r\n\r\n\t// generate the jacobian\r\n\t// The jacobian has one column for each free degree of freedom and a row for every\r\n\t// target degree of freedom we have. The entries are generated by adjusting every\r\n\t// DoF by some epsilon and storing how much it affected the target error.\r\n\tfillJacobian( targetJoints, freeJoints, outJacobian ) {\r\n\r\n\t\tconst {\r\n\t\t\ttranslationStep,\r\n\t\t\trotationStep,\r\n\t\t\tlockedJointDoF,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t\ttranslationFactor,\r\n\t\t\trotationFactor,\r\n\t\t} = this;\r\n\r\n\t\t// TODO: abstract this\r\n\t\tconst affectedClosures = this.affectedClosures;\r\n\t\tconst affectedConnectedClosures = this.affectedConnectedClosures;\r\n\r\n\t\tlet colIndex = 0;\r\n\t\tfor ( let c = 0, tc = freeJoints.length; c < tc; c ++ ) {\r\n\r\n\t\t\t// TODO: If this is a goal we should skip adding it to the jacabian columns\r\n\t\t\tconst freeJoint = freeJoints[ c ];\r\n\t\t\tconst relevantClosures = affectedClosures.get( freeJoint );\r\n\t\t\tconst relevantConnectedClosures = affectedConnectedClosures.get( freeJoint );\r\n\t\t\tconst dofList = freeJoint.dof;\r\n\t\t\tconst colCount = freeJoint.translationDoFCount + freeJoint.rotationDoFCount;\r\n\r\n\t\t\tconst isLocked = lockedJointDoFCount.has( freeJoint );\r\n\t\t\tconst lockedDoF = lockedJointDoF.get( freeJoint );\r\n\r\n\t\t\t// get the world inverse of the free joint\r\n\t\t\tmat4.invert( tempInverseMatrixWorld, freeJoint.matrixWorld );\r\n\r\n\t\t\t// iterate over every degree of freedom in the joint\r\n\t\t\tfor ( let co = 0; co < colCount; co ++ ) {\r\n\r\n\t\t\t\tconst dof = dofList[ co ];\r\n\r\n\t\t\t\t// skip this joint if it's locked\r\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rowIndex = 0;\r\n\r\n\t\t\t\t// generate the adjusted matrix based on the epsilon for the joint.\r\n\t\t\t\tlet delta = dof < 3 ? translationStep : rotationStep;\r\n\t\t\t\tif ( freeJoint.getDeltaWorldMatrix( dof, delta, tempDeltaWorldMatrix ) ) {\r\n\r\n\t\t\t\t\tdelta *= - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Iterate over every target\r\n\t\t\t\tfor ( let r = 0, tr = targetJoints.length; r < tr; r ++ ) {\r\n\r\n\t\t\t\t\tconst targetJoint = targetJoints[ r ];\r\n\r\n\t\t\t\t\t// if it's a closure target\r\n\t\t\t\t\tif ( targetJoint.isClosure ) {\r\n\r\n\t\t\t\t\t\tif ( relevantClosures.has( targetJoint ) || relevantConnectedClosures.has( targetJoint ) ) {\r\n\r\n\t\t\t\t\t\t\t// TODO: If this is a Goal it only add 1 or 2 fields if only two axes are set. Quat is only\r\n\t\t\t\t\t\t\t// needed if 3 eulers are used.\r\n\t\t\t\t\t\t\t// TODO: these could be cached per target joint get the current error within the closure joint\r\n\r\n\t\t\t\t\t\t\t// Get the error from child towards the closure target\r\n\t\t\t\t\t\t\ttargetJoint.getClosureError( tempPos, tempQuat );\r\n\t\t\t\t\t\t\tif ( relevantConnectedClosures.has( targetJoint ) ) {\r\n\r\n\t\t\t\t\t\t\t\t// If this is affecting a link connected to a closure joint then adjust that child link by\r\n\t\t\t\t\t\t\t\t// the delta rotation.\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.child.matrixWorld );\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\r\n\r\n\t\t\t\t\t\t\t\t// Get the new error\r\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetJoint.matrixWorld, targetDeltaWorldMatrix, tempPos2, tempQuat2 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// If this is directly affecting a closure joint then adjust that child link by the delta\r\n\t\t\t\t\t\t\t\t// rotation.\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.matrixWorld );\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\r\n\r\n\t\t\t\t\t\t\t\t// Get the new error\r\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetDeltaWorldMatrix, targetJoint.child.matrixWorld, tempPos2, tempQuat2 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Get the amount that the rotation and translation error changed due to the\r\n\t\t\t\t\t\t\t// small DoF adjustment to serve as the derivative.\r\n\t\t\t\t\t\t\tvec3.subtract( tempPos, tempPos2, tempPos );\r\n\t\t\t\t\t\t\tvec3.scale( tempPos, tempPos, translationFactor / delta );\r\n\r\n\t\t\t\t\t\t\tvec4.subtract( tempQuat, tempQuat2, tempQuat );\r\n\t\t\t\t\t\t\tvec4.scale( tempQuat, tempQuat, rotationFactor / delta );\r\n\r\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\r\n\r\n\t\t\t\t\t\t\t\tconst { translationDoFCount, rotationDoFCount, dof } = targetJoint;\r\n\t\t\t\t\t\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst d = dof[ i ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = tempPos[ d ];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif ( rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 0 ][ colIndex ] = tempQuat[ 0 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 1 ][ colIndex ] = tempQuat[ 1 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 2 ][ colIndex ] = tempQuat[ 2 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 3 ][ colIndex ] = tempQuat[ 3 ];\r\n\t\t\t\t\t\t\t\t\trowIndex += 4;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\trowIndex += translationDoFCount;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// set translation\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 0 ][ colIndex ] = tempPos[ 0 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 1 ][ colIndex ] = tempPos[ 1 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 2 ][ colIndex ] = tempPos[ 2 ];\r\n\r\n\t\t\t\t\t\t\t\t// set rotation\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 3 ][ colIndex ] = tempQuat[ 0 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 4 ][ colIndex ] = tempQuat[ 1 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 5 ][ colIndex ] = tempQuat[ 2 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 6 ][ colIndex ] = tempQuat[ 3 ];\r\n\t\t\t\t\t\t\t\trowIndex += 7;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// if the target isn't relevant then there's no delta\r\n\t\t\t\t\t\t\tlet totalRows = 7;\r\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\r\n\r\n\t\t\t\t\t\t\t\ttotalRows = targetJoint.translationDoFCount;\r\n\t\t\t\t\t\t\t\tif ( targetJoint.rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttotalRows += 4;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < totalRows; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\trowIndex += totalRows;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check if this joint has a target set and update the jacobian rows if it does\r\n\t\t\t\t\tif ( targetJoint.targetSet ) {\r\n\r\n\t\t\t\t\t\tconst rowCount = targetJoint.translationDoFCount + targetJoint.rotationDoFCount;\r\n\r\n\t\t\t\t\t\tif ( freeJoint === targetJoint ) {\r\n\r\n\t\t\t\t\t\t\t// if we're just dealing with a target dof joint then there can't be any influence\r\n\t\t\t\t\t\t\t// but otherwise the only joint that can have an effect on this error is the joint\r\n\t\t\t\t\t\t\t// itself.\r\n\t\t\t\t\t\t\t// TODO: Having noted that is this really necessary? Is there any way that this doesn't just\r\n\t\t\t\t\t\t\t// jump to the solution and lock? How can we afford some slack? With a low weight? Does that\r\n\t\t\t\t\t\t\t// get applied here?\r\n\t\t\t\t\t\t\t// TODO: If this joint happens to have three euler joints we need to use a quat here. Otherwise we\r\n\t\t\t\t\t\t\t// use the euler angles.\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + colIndex ][ colIndex ] = - 1;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\trowIndex += rowCount;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( colIndex !== outJacobian[ 0 ].length ) {\r\n\r\n\t\t\tthrow new Error();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Fill in the error vector\r\n\tfillErrorVector( targetJoints, errorVector ) {\r\n\r\n\t\tlet rowIndex = 0;\r\n\t\tfor ( let i = 0, l = targetJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst joint = targetJoints[ i ];\r\n\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\taccumulateClosureError( this, joint, rowIndex, errorVector, errorResultInfo );\r\n\t\t\t\trowIndex += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\taccumulateTargetError( this, joint, rowIndex, errorVector, errorResultInfo );\r\n\t\t\t\trowIndex += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Count the unconverged targets in the chain and store them in targetJoints and store\r\n\t// any freeJoints in\r\n\tcountUnconvergedVariables( freeJoints, targetJoints, dofResultInfo ) {\r\n\r\n\t\tconst { lockedJointDoFCount } = this;\r\n\r\n\t\tconst chain = this.chain;\r\n\t\tlet totalError = 0;\r\n\t\tlet errorRows = 0;\r\n\t\tlet unconvergedRows = 0;\r\n\t\tlet freeDoF = 0;\r\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\tlet addToTargetList = false;\r\n\t\t\tconst joint = chain[ i ];\r\n\t\t\tconst lockedDoF = lockedJointDoFCount.get( joint ) || 0;\r\n\r\n\t\t\t// TODO: Should we check every variable against the convergence threshold or is\r\n\t\t\t// it better to check the magnitude?\r\n\r\n\t\t\t// TODO: We may be able to speed this up by using the square distance and length\r\n\t\t\t// to compare error.\r\n\r\n\t\t\t// TODO: If this is a goal we shouldnt add to the free dof because they won't be added\r\n\t\t\t// to the jacobian\r\n\r\n\t\t\t// If this is a closure joint then we need to make sure we're solving\r\n\t\t\t// for the other child end to meet this joint so this error is important.\r\n\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\taccumulateClosureError( this, joint, errorRows, null, errorResultInfo );\r\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\r\n\r\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\r\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddToTargetList = true;\r\n\t\t\t\terrorRows += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check out far the joint is from the target dof value.\r\n\t\t\tconst dofList = joint.dof;\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\taccumulateTargetError( this, joint, errorRows, null, errorResultInfo );\r\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\r\n\r\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\r\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddToTargetList = true;\r\n\t\t\t\terrorRows += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! joint.isGoal ) {\r\n\r\n\t\t\t\tfreeDoF += dofList.length - lockedDoF;\r\n\t\t\t\tfreeJoints.push( joint );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( addToTargetList ) {\r\n\r\n\t\t\t\ttargetJoints.push( joint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// if it turns out that everything is converged.\r\n\t\tif ( unconvergedRows === 0 ) {\r\n\r\n\t\t\terrorRows = 0;\r\n\r\n\t\t}\r\n\r\n\t\tdofResultInfo.errorRows = errorRows;\r\n\t\tdofResultInfo.freeDoF = freeDoF;\r\n\t\tdofResultInfo.totalError = totalError;\r\n\r\n\t}\r\n\r\n}\r\n","import { ChainSolver } from './ChainSolver.js';\r\nimport { findRoots } from './utils/findRoots.js';\r\n\r\nexport class Solver {\r\n\r\n\tconstructor( roots = [] ) {\r\n\r\n\t\tthis.useSVD = true;\r\n\r\n\t\tthis.maxIterations = 5;\r\n\t\tthis.stallThreshold = 1e-4;\r\n\t\tthis.dampingFactor = 0.001;\r\n\t\tthis.divergeThreshold = 0.01;\r\n\t\tthis.restPoseFactor = 0.01;\r\n\r\n\t\tthis.translationConvergeThreshold = 1e-3;\r\n\t\tthis.rotationConvergeThreshold = 1e-5;\r\n\r\n\t\tthis.translationFactor = 1;\r\n\t\tthis.rotationFactor = 1;\r\n\r\n\t\tthis.translationStep = 1e-3;\r\n\t\tthis.rotationStep = 1e-3;\r\n\r\n\t\tthis.translationErrorClamp = 0.1;\r\n\t\tthis.rotationErrorClamp = 0.1;\r\n\r\n\t\tthis.roots = Array.isArray( roots ) ? [ ...roots ] : [ roots ];\r\n\t\tthis.solvers = null;\r\n\r\n\t\tthis.updateStructure();\r\n\r\n\t}\r\n\r\n\t// needs to be called whenever tree structure is updated\r\n\tupdateStructure() {\r\n\r\n\t\tconst roots = findRoots( this.roots );\r\n\t\tconst chains = [];\r\n\t\tconst traversal = new Set();\r\n\t\tconst allChainJoints = new Set();\r\n\t\tconst traverseChains = frame => {\r\n\r\n\t\t\t// If we found a joint then add it to the traversal list\r\n\t\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\t\tconst joint = frame;\r\n\t\t\t\ttraversal.add( joint );\r\n\r\n\t\t\t\t// If we found a closure joint\r\n\t\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\t\t// Traverse back up the tree until we find a common ancestor\r\n\t\t\t\t\t// and create a new chain\r\n\t\t\t\t\tconst chainSet = new Set();\r\n\t\t\t\t\tlet curr = joint.child;\r\n\t\t\t\t\twhile ( curr ) {\r\n\r\n\t\t\t\t\t\tif ( curr.isJoint ) {\r\n\r\n\t\t\t\t\t\t\tif ( traversal.has( curr ) ) {\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tchainSet.add( curr );\r\n\t\t\t\t\t\t\t\tallChainJoints.add( curr );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurr = curr.parent;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttraversal.forEach( c => {\r\n\r\n\t\t\t\t\t\tchainSet.add( c );\r\n\t\t\t\t\t\tallChainJoints.add( c );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tchains.push( chainSet );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Continue traversing\r\n\t\t\tconst children = frame.children;\r\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\ttraverseChains( children[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Remove the joint from our traversal set\r\n\t\t\ttraversal.delete( frame );\r\n\r\n\t\t};\r\n\r\n\t\t// find all chains in the roots\r\n\t\troots.forEach( traverseChains );\r\n\r\n\t\t// Merge interdependent chains\r\n\t\tconst independentChains = [];\r\n\t\twhile ( chains.length ) {\r\n\r\n\t\t\tconst currChain = chains.pop();\r\n\t\t\tindependentChains.push( currChain );\r\n\t\t\tfor ( let i = 0; i < chains.length; i ++ ) {\r\n\r\n\t\t\t\t// see if this chain is dependent on the current chain\r\n\t\t\t\t// and if so merge the chains.\r\n\t\t\t\tconst otherChain = chains[ i ];\r\n\r\n\t\t\t\tlet dependent = false;\r\n\t\t\t\totherChain.forEach( c => {\r\n\r\n\t\t\t\t\tdependent = dependent || currChain.has( c );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tif ( dependent ) {\r\n\r\n\t\t\t\t\totherChain.forEach( c => currChain.add( c ) );\r\n\t\t\t\t\tchains.splice( i, 1 );\r\n\t\t\t\t\ti --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Find any joints that aren't considered part of a solve chain so we\r\n\t\t// can just update them using forward kinematics.\r\n\t\tconst nonChainJoints = new Set();\r\n\t\troots.forEach( root => root.traverse( c => {\r\n\r\n\t\t\tif ( c.isJoint && c.dof.length > 0 && ! allChainJoints.has( c ) ) {\r\n\r\n\t\t\t\tnonChainJoints.add( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t} ) );\r\n\r\n\t\t// Create the solvers for the chains\r\n\t\tthis.solvers = independentChains.map( c => new ChainSolver( c ) );\r\n\t\tthis.nonChainJoints = nonChainJoints;\r\n\r\n\t}\r\n\r\n\tsolve() {\r\n\r\n\t\tconst { solvers, nonChainJoints } = this;\r\n\r\n\t\t// update any non chain joints\r\n\t\tnonChainJoints.forEach( joint => {\r\n\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\tjoint.dofValues.set( joint.dofTarget );\r\n\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tconst results = [];\r\n\t\tfor ( let i = 0, l = solvers.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst s = solvers[ i ];\r\n\t\t\ts.maxIterations = this.maxIterations;\r\n\t\t\ts.stallThreshold = this.stallThreshold;\r\n\t\t\ts.dampingFactor = this.dampingFactor;\r\n\t\t\ts.divergeThreshold = this.divergeThreshold;\r\n\t\t\ts.restPoseFactor = this.restPoseFactor;\r\n\r\n\t\t\ts.translationConvergeThreshold = this.translationConvergeThreshold;\r\n\t\t\ts.rotationConvergeThreshold = this.rotationConvergeThreshold;\r\n\r\n\t\t\ts.translationFactor = this.translationFactor;\r\n\t\t\ts.rotationFactor = this.rotationFactor;\r\n\r\n\t\t\ts.translationStep = this.translationStep;\r\n\t\t\ts.rotationStep = this.rotationStep;\r\n\r\n\t\t\ts.translationErrorClamp = this.translationErrorClamp;\r\n\t\t\ts.rotationErrorClamp = this.rotationErrorClamp;\r\n\r\n\t\t\tconst result = s.solve();\r\n\t\t\tresults.push( result );\r\n\r\n\t\t}\r\n\r\n\t\treturn results;\r\n\r\n\t}\r\n\r\n}\r\n","import { Joint, DOF } from './Joint.js';\n\nexport class Goal extends Joint {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.isGoal = true;\n\t\tthis.setFreeDoF();\n\n\t}\n\n\tsetDoF( ...args ) {\n\n\t\t// We don't support rotation goals that only specify 1 or 2 free rotation axes.\n\t\tlet rotCount =\n\t\t\tNumber( args.includes( DOF.EX ) ) +\n\t\t\tNumber( args.includes( DOF.EY ) ) +\n\t\t\tNumber( args.includes( DOF.EZ ) );\n\n\t\tif ( rotCount !== 0 && rotCount !== 3 ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tsuper.setDoF( ...args );\n\n\t}\n\n\tsetGoalDoF( ...args ) {\n\n\t\tthis.setDoF( ...args );\n\n\t}\n\n\tsetFreeDoF( ...args ) {\n\n\t\tconst freeDoF = [\n\t\t\tDOF.X, DOF.Y, DOF.Z,\n\t\t\tDOF.EX, DOF.EY, DOF.EZ,\n\t\t].filter( d => ! args.includes( d ) );\n\t\tthis.setDoF( ...freeDoF );\n\n\t}\n\n\taddChild() {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n","import { Joint } from '../core/Joint.js';\r\nimport { Link } from '../core/Link.js';\r\nimport { Goal } from '../core/Goal.js';\r\n\r\n// Takes a list of interconnected frames and serializes them into a non cyclic json representation\r\nexport function serialize( frames ) {\r\n\r\n\tconst map = new Map();\r\n\tconst info = [];\r\n\r\n\t// Create the initial frame list along with a joint -> index map\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tconst frame = frames[ i ];\r\n\r\n\t\tconst {\r\n\t\t\tname,\r\n\t\t\tdof,\r\n\t\t\tdofValues,\r\n\t\t\tdofTarget,\r\n\t\t\tdofRestPose,\r\n\t\t\tminDoFLimit,\r\n\t\t\tmaxDoFLimit,\r\n\t\t\ttargetSet,\r\n\t\t\trestPoseSet,\r\n\t\t\tposition,\r\n\t\t\tquaternion,\r\n\t\t\tisClosure,\r\n\t\t} = frame;\r\n\r\n\t\tlet type = 'Link';\r\n\t\tif ( frame.isGoal ) {\r\n\r\n\t\t\ttype = 'Goal';\r\n\r\n\t\t} else if ( frame.isJoint ) {\r\n\r\n\t\t\ttype = 'Joint';\r\n\r\n\t\t}\r\n\r\n\t\tconst res = {\r\n\t\t\tdof: dof ? dof.slice() : null,\r\n\t\t\tdofValues: dofValues ? dofValues.slice() : null,\r\n\t\t\tdofTarget: dofTarget ? dofTarget.slice() : null,\r\n\t\t\tdofRestPose: dofRestPose ? dofRestPose.slice() : null,\r\n\t\t\tminDoFLimit: minDoFLimit ? minDoFLimit.slice() : null,\r\n\t\t\tmaxDoFLimit: maxDoFLimit ? maxDoFLimit.slice() : null,\r\n\t\t\ttargetSet,\r\n\t\t\trestPoseSet,\r\n\t\t\tisClosure,\r\n\r\n\t\t\tname,\r\n\t\t\tposition: position.slice(),\r\n\t\t\tquaternion: quaternion.slice(),\r\n\t\t\tchildren: null,\r\n\t\t\tclosureJoints: null,\r\n\t\t\tchild: null,\r\n\t\t\ttype,\r\n\t\t};\r\n\r\n\t\tinfo.push( res );\r\n\t\tmap.set( frame, i );\r\n\r\n\t}\r\n\r\n\t// Create the child and parent index references.\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tconst inf = info[ i ];\r\n\t\tconst frame = frames[ i ];\r\n\t\tinf.children = frame.children.map( c => map.get( c ) );\r\n\t\tif ( frame.isLink ) {\r\n\r\n\t\t\tinf.closureJoints = frame.closureJoints.map( c => map.get( c ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.isJoint && frame.child ) {\r\n\r\n\t\t\tinf.child = map.get( frame.child );\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.parent ) {\r\n\r\n\t\t\tinf.parent = map.get( frame.parent );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinf.parent = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn info;\r\n\r\n}\r\n\r\n// Deserialize the serialized representation of the graph\r\nexport function deserialize( data ) {\r\n\r\n\t// Create joints / links for every serialized version\r\n\tconst frames =\r\n\t\tdata.map( d => {\r\n\r\n\t\t\tconst {\r\n\t\t\t\ttype,\r\n\t\t\t\tname,\r\n\t\t\t\tposition,\r\n\t\t\t\tquaternion,\r\n\r\n\t\t\t\tdof,\r\n\t\t\t\tdofValues,\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t\ttargetSet,\r\n\t\t\t\trestPoseSet,\r\n\t\t\t\tisClosure,\r\n\t\t\t} = d;\r\n\r\n\t\t\tlet frame;\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'Goal':\r\n\t\t\t\tcase 'Joint':\r\n\t\t\t\t\tframe = type === 'Goal' ? new Goal() : new Joint();\r\n\r\n\t\t\t\t\tframe.setDoF( ...dof );\r\n\t\t\t\t\tframe.dofValues.set( dofValues );\r\n\t\t\t\t\tframe.dofTarget.set( dofTarget );\r\n\t\t\t\t\tframe.dofRestPose.set( dofRestPose );\r\n\t\t\t\t\tframe.minDoFLimit.set( minDoFLimit );\r\n\t\t\t\t\tframe.maxDoFLimit.set( maxDoFLimit );\r\n\r\n\t\t\t\t\tframe.targetSet = targetSet;\r\n\t\t\t\t\tframe.restPoseSet = restPoseSet;\r\n\t\t\t\t\tframe.isClosure = isClosure;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'Link':\r\n\t\t\t\t\tframe = new Link();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tframe.name = name;\r\n\t\t\tframe.position.set( position );\r\n\t\t\tframe.quaternion.set( quaternion );\r\n\t\t\treturn frame;\r\n\r\n\t\t} );\r\n\r\n\t// set the parent and child from the maps\r\n\tfor ( let i = 0; i < frames.length; i ++ ) {\r\n\r\n\t\tconst frame = frames[ i ];\r\n\t\tconst info = data[ i ];\r\n\r\n\t\tframe.parent = frames[ info.parent ] || null;\r\n\t\tframe.children.push( ...info.children.map( i => frames[ i ] ) );\r\n\t\tframe.setMatrixNeedsUpdate();\r\n\r\n\t\tif ( frame.isLink ) {\r\n\r\n\t\t\tframe.closureJoints.push( ...info.closureJoints.map( i => frames[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\tframe.child = info.child !== null ? frames[ info.child ] : null;\r\n\t\t\tframe.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn frames;\r\n\r\n}\r\n","export const JOINT_STRIDE = 304;\r\n\r\nexport const LINK_STRIDE = 56;\r\n\r\nexport function generateSharedBuffer( frames ) {\r\n\r\n\t// dofValues \t6 * 4\r\n\t// dofTarget \t6 * 4\r\n\t// dofRestPose \t6 * 4\r\n\t// minDoFLimit \t6 * 4\r\n\t// maxDoFLimit \t6 * 4\r\n\t// position \t3 * 4\r\n\t// quaternion \t4 * 4\r\n\t// targetSet \t1\r\n\t// restPoseSet \t1\r\n\t// --\r\n\t// total  \t\t150 bytes per joint\r\n\t// 4 byte aligned: 152\r\n\r\n\tconst arrayBuffer = new SharedArrayBuffer( JOINT_STRIDE * frames.length );\r\n\tconst float64 = new Float32Array( arrayBuffer );\r\n\tconst byte8 = new Uint8Array( arrayBuffer );\r\n\tapplyToBuffer( frames, float64, byte8 );\r\n\treturn arrayBuffer;\r\n\r\n}\r\n\r\nexport function applyToBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyFrameToBuffer( frames[ i ], floatBuffer, byteBuffer, i * JOINT_STRIDE, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function applyFromBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyBufferToFrame( frames[ i ], floatBuffer, byteBuffer, JOINT_STRIDE * i, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the frame to the given buffer starting at the given byte offset. Joints take JOINT_STRIDE\r\n// bytes while links take LINK_STRIDE bytes.\r\nexport function copyFrameToBuffer(\r\n\tframe,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tconst {\r\n\t\t\tposition,\r\n\t\t\tquaternion,\r\n\t\t} = frame;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 0 + i ] = position[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 3 + i ] = quaternion[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t\ttargetSet,\r\n\t\t\t\trestPoseSet,\r\n\t\t\t} = frame;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 0 * 6 + i ] = dofTarget[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 1 * 6 + i ] = dofRestPose[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 2 * 6 + i ] = minDoFLimit[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 3 * 6 + i ] = maxDoFLimit[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteBuffer[ byteOffset + 148 ] = Number( targetSet );\r\n\t\t\tbyteBuffer[ byteOffset + 149 ] = Number( restPoseSet );\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && frame.isJoint ) {\r\n\r\n\t\tconst { dofValues } = frame;\r\n\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 7 + 4 * 6 + i ] = dofValues[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the given buffer to the given frame starting at the given byte offset.\r\nexport function copyBufferToFrame(\r\n\tjoint,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tjoint.setPosition(\r\n\t\t\tfloatBuffer[ floatOffset + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 2 ],\r\n\t\t);\r\n\t\tjoint.setQuaternion(\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 2 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 3 ],\r\n\t\t);\r\n\r\n\t\tif ( joint.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t} = joint;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tdofTarget[ i ] = floatBuffer[ floatOffset + 7 + 0 * 6 + i ];\r\n\t\t\t\tdofRestPose[ i ] = floatBuffer[ floatOffset + 7 + 1 * 6 + i ];\r\n\t\t\t\tminDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 2 * 6 + i ];\r\n\t\t\t\tmaxDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 3 * 6 + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tjoint.targetSet = Boolean( byteBuffer[ byteOffset + 148 ] );\r\n\t\t\tjoint.restPoseSet = Boolean( byteBuffer[ byteOffset + 149 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && joint.isJoint ) {\r\n\r\n\t\tconst { dofValues } = joint;\r\n\t\tlet changed = false;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tconst v = floatBuffer[ floatOffset + 7 + 4 * 6 + i ];\r\n\t\t\tif ( v !== dofValues[ i ] ) {\r\n\r\n\t\t\t\tdofValues[ i ] = v;\r\n\t\t\t\tchanged = true;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t\t// only update dof matrix if it changed\r\n\t\tif ( changed ) {\r\n\r\n\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { Solver } from '../core/Solver.js';\nimport { SOLVE_STATUS } from '../core/ChainSolver.js';\nimport { deserialize } from './serialize.js';\nimport { applyToBuffer, applyFromBuffer } from './utils.js';\n\nlet solver = new Solver();\nlet solveHandle = - 1;\n\n// List of all frames in the graph\nlet frames = null;\n\n// Buffer variants\nlet buffer = null;\nlet floatBuffer = null;\nlet byteBuffer = null;\n\nglobal.onmessage = function ( { data: e } ) {\n\n\tconst { type, data } = e;\n\tswitch ( type ) {\n\n\t\t// The ik graph needs to be updated with all the deserialized\n\t\tcase 'updateStructure':\n\t\t\tframes = deserialize( data.serialized );\n\t\t\tsolver.roots = frames.filter( f => f.parent === null );\n\t\t\tsolver.updateStructure();\n\n\t\t\tbuffer = data.buffer;\n\t\t\tbyteBuffer = new Uint8Array( buffer );\n\t\t\tfloatBuffer = new Float32Array( buffer );\n\t\t\tbreak;\n\n\t\t// Update the settings of the solver\n\t\tcase 'updateSolverSettings':\n\t\t\tObject.assign( solver, data );\n\t\t\tbreak;\n\n\t\t// Start the solve loop\n\t\tcase 'startSolve':\n\t\t\tif ( solveHandle === - 1 ) {\n\n\t\t\t\tupdateSolve();\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t// Stop the solve loop\n\t\tcase 'endSolve':\n\t\t\tif ( solveHandle !== - 1 ) {\n\n\t\t\t\tclearTimeout( solveHandle );\n\t\t\t\tsolveHandle = - 1;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t}\n\n};\n\n// The iterative solve loop\nfunction updateSolve() {\n\n\t// Copy any frame updates from the main thread\n\tapplyFromBuffer( frames, floatBuffer, byteBuffer, false, true );\n\n\t// Solve 1 iteration taking the most severe chain result\n\tconst result = solver.solve();\n\n\t// Copy the new DoF back to the shared buffer\n\tapplyToBuffer( frames, floatBuffer, byteBuffer, true, false );\n\n\tif ( result.find( r => r === SOLVE_STATUS.TIMEOUT ) ) {\n\n\t\t// yield so we can react to messages\n\t\tsolveHandle = setTimeout( updateSolve );\n\n\t} else {\n\n\t\tsolveHandle = - 1;\n\n\t}\n\n\tthis.postMessage( {\n\n\t\ttype: 'updateSolve',\n\t\tdata: result,\n\n\t} );\n\n}\n"]}