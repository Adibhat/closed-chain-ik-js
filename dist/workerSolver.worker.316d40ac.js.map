{"version":3,"sources":["../node_modules/linear-solve/gauss-jordan.js","../src/core/utils/matrix.js","../src/core/MatrixPool.js","../src/core/utils/solver.js","../src/core/ChainSolver.js","../src/core/Solver.js","../src/core/Goal.js","../src/worker/serialize.js","../src/worker/utils.js","../src/worker/workerSolver.worker.js"],"names":["transpose","outMatrix","a","tr","length","tc","r","c","identity","scale","matrix","scalar","multiply","b","Error","m","n","k","sum","i","ti","create","row","col","result","Array","Float64Array","copy","sourceMatrix","clone","rows","resultMatrix","solve","vector","res","linearSolve","l","invert","add","subtract","magnitudeSquared","cols","magnitude","Math","sqrt","toString","dec","str","toFixed","log","console","mat","FixedMatrixPool","matrices","index","get","releaseAll","MatrixPool","pools","poolArray","colPools","pool","push","tempPos","tempQuat","tempEuler","accumulateClosureError","solver","joint","startIndex","errorVector","isConverged","rowCount","totalError","translationConvergeThreshold","rotationConvergeThreshold","translationErrorClamp","rotationErrorClamp","translationFactor","rotationFactor","translationDoFCount","rotationDoFCount","dofFlags","dof","getClosureError","isGoal","posMag","vec3","rotMag","vec4","d","accumulateTargetError","lockedJointDoFCount","lockedJointDoF","dofTarget","dofValues","dofList","posDelta","distance","rotDelta","DOF","EX","EY","EZ","lockedDoFCount","lockedDoF","isLocked","rowIndex","eulerMag","matrixPool","targetRelativeToJointMatrix","targetDeltaWorldMatrix","tempDeltaWorldMatrix","tempInverseMatrixWorld","tempQuat2","tempPos2","targetJoints","freeJoints","errorResultInfo","dofResultInfo","errorRows","freeDoF","SOLVE_STATUS","CONVERGED","STALLED","DIVERGED","TIMEOUT","SOLVE_STATUS_NAMES","Object","entries","sort","map","el","ChainSolver","chain","from","targets","affectedClosures","affectedConnectedClosures","prevDoFValues","maxIterations","translationStep","rotationStep","stallThreshold","dampingFactor","divergeThreshold","restPoseFactor","init","filter","j","targetSet","isClosure","Map","forEach","set","Set","Uint8Array","target","currJoint","isJoint","parent","child","iterations","prevErrorMagnitude","Infinity","status","clear","restPoseSet","tryMinimizeEulerAngles","updateMatrixWorld","countUnconvergedVariables","setMatrixDoFNeedsUpdate","fillErrorVector","jacobian","fillJacobian","jacobianIdentityDamping","jacobianTranspose","jjt","jjti","jjtii","pseudoInverse","deltaTheta","restPose","restPoseResult","colIndex","colCount","dofRestPose","jij","jiji","stalled","delta","abs","applyJointAngles","lockedJoint","dti","has","value","getDoFValue","hitLimit","setDoFValue","fill","lockedCount","outJacobian","freeJoint","relevantClosures","relevantConnectedClosures","matrixWorld","co","getDeltaWorldMatrix","targetJoint","totalRows","unconvergedRows","addToTargetList","Solver","roots","isArray","solvers","updateStructure","chains","traversal","allChainJoints","traverseChains","frame","curr","chainSet","children","delete","independentChains","currChain","pop","otherChain","dependent","splice","nonChainJoints","root","traverse","results","s","Joint","Goal","args","setFreeDoF","rotCount","Number","includes","setDoF","X","Y","Z","serialize","frames","info","name","minDoFLimit","maxDoFLimit","position","quaternion","type","slice","inf","deserialize","data","Link","setMatrixNeedsUpdate","JOINT_STRIDE","LINK_STRIDE","generateSharedBuffer","arrayBuffer","SharedArrayBuffer","applyToBuffer","Float32Array","floatBuffer","byteBuffer","copyDoFValues","copyJointSettings","copyFrameToBuffer","applyFromBuffer","copyBufferToFrame","byteOffset","floatOffset","setPosition","setQuaternion","Boolean","changed","v","solveHandle","buffer","updateSolve","setTimeout","postMessage","global","onmessage","e","serialized","f","assign","clearTimeout"],"mappings":"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","file":"workerSolver.worker.316d40ac.js","sourceRoot":"..\\example","sourcesContent":["/**\n * Gauss-Jordan elimination\n */\n\nvar linear = (function(){\n/**\n * Used internally to solve systems\n * If you want to solve A.x = B,\n * choose data=A and mirror=B.\n * mirror can be either an array representing a vector\n * or an array of arrays representing a matrix.\n */\nfunction Mat(data, mirror) {\n  // Clone the original matrix\n  this.data = new Array(data.length);\n  for (var i=0, cols=data[0].length; i<data.length; i++) {\n    this.data[i] = new Array(cols);\n    for(var j=0; j<cols; j++) {\n      this.data[i][j] = data[i][j];\n    }\n  }\n\n  if (mirror) {\n    if (typeof mirror[0] !== \"object\") {\n      for (var i=0; i<mirror.length; i++) {\n        mirror[i] = [mirror[i]];\n      }\n    }\n    this.mirror = new Mat(mirror);\n  }\n}\n\n/**\n * Swap lines i and j in the matrix\n */\nMat.prototype.swap = function (i, j) {\n  if (this.mirror) this.mirror.swap(i,j);\n  var tmp = this.data[i];\n  this.data[i] = this.data[j];\n  this.data[j] = tmp;\n}\n\n/**\n * Multiply line number i by l\n */\nMat.prototype.multline = function (i, l) {\n  if (this.mirror) this.mirror.multline(i,l);\n  var line = this.data[i];\n  for (var k=line.length-1; k>=0; k--) {\n    line[k] *= l;\n  }\n}\n\n/**\n * Add line number j multiplied by l to line number i\n */\nMat.prototype.addmul = function (i, j, l) {\n  if (this.mirror) this.mirror.addmul(i,j,l);\n  var lineI = this.data[i], lineJ = this.data[j];\n  for (var k=lineI.length-1; k>=0; k--) {\n    lineI[k] = lineI[k] + l*lineJ[k];\n  }\n}\n\n/**\n * Tests if line number i is composed only of zeroes\n */\nMat.prototype.hasNullLine = function (i) {\n  for (var j=0; j<this.data[i].length; j++) {\n    if (this.data[i][j] !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nMat.prototype.gauss = function() {\n  var pivot = 0,\n      lines = this.data.length,\n      columns = this.data[0].length,\n      nullLines = [];\n\n  for (var j=0; j<columns; j++) {\n    // Find the line on which there is the maximum value of column j\n    var maxValue = 0, maxLine = 0;\n    for (var k=pivot; k<lines; k++) {\n      var val = this.data[k][j];\n      if (Math.abs(val) > Math.abs(maxValue)) {\n        maxLine = k;\n        maxValue = val;\n      } \n    }\n    if (maxValue === 0) {\n      // The matrix is not invertible. The system may still have solutions.\n      nullLines.push(pivot);\n    } else {\n      // The value of the pivot is maxValue\n      this.multline(maxLine, 1/maxValue);\n      this.swap(maxLine, pivot);\n      for (var i=0; i<lines; i++) {\n        if (i !== pivot) {\n          this.addmul(i, pivot, -this.data[i][j]);\n        }\n      }\n    }\n    pivot++;\n  }\n\n  // Check that the system has null lines where it should\n  for (var i=0; i<nullLines.length; i++) {\n    if (!this.mirror.hasNullLine(nullLines[i])) {\n      throw new Error(\"singular matrix\");\n    }\n  }\n  return this.mirror.data;\n}\n\n/**\n * Solves A.x = b\n * @param A\n * @param b\n * @return x\n */\nexports.solve = function solve(A, b) {\n  var result = new Mat(A,b).gauss();\n  if (result.length > 0 && result[0].length === 1) {\n    // Convert Nx1 matrices to simple javascript arrays\n    for (var i=0; i<result.length; i++) result[i] = result[i][0];\n  }\n  return result;\n}\n\nfunction identity(n) {\n  var id = new Array(n);\n  for (var i=0; i<n; i++) {\n    id[i] = new Array(n);\n    for (var j=0; j<n; j++) {\n      id[i][j] = (i === j) ? 1 : 0;\n    }\n  }\n  return id;\n}\n\n/**\n * invert a matrix\n */\nexports.invert = function invert(A) {\n  return new Mat(A, identity(A.length)).gauss();\n}\n\nreturn exports;\n})();\n\nif (typeof module.exports === \"object\") module.exports = linear;\n","import linearSolve from 'linear-solve';\r\n\r\nfunction transpose( outMatrix, a ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ c ][ r ] = a[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction identity( outMatrix ) {\r\n\r\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = r === c ? 1 : 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction scale( outMatrix, matrix, scalar ) {\r\n\r\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = matrix[ r ][ c ] * scalar;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction multiply( outMatrix, a, b ) {\r\n\r\n\tif ( a === b ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n\t// a is m x n\r\n\t// b is n x k\r\n\t// outMatrix is m x k\r\n\r\n\t// m = a rows\r\n\t// n = a cols or b rows\r\n\t// k = b cols\r\n\r\n\tconst m = a.length;\r\n\tconst n = b.length;\r\n\tconst k = b[ 0 ].length;\r\n\r\n\t// iterate over m\r\n\tfor ( let r = 0, tr = m; r < tr; r ++ ) {\r\n\r\n\t\t// iterate over k\r\n\t\tfor ( let c = 0, tc = k; c < tc; c ++ ) {\r\n\r\n\t\t\tlet sum = 0;\r\n\r\n\t\t\t// iterate over n\r\n\t\t\tfor ( let i = 0, ti = n; i < ti; i ++ ) {\r\n\r\n\t\t\t\tsum += a[ r ][ i ] * b[ i ][ c ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutMatrix[ r ][ c ] = sum;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction create( row, col ) {\r\n\r\n\tconst result = new Array( row );\r\n\tfor ( let i = 0; i < row; i ++ ) {\r\n\r\n\t\tresult[ i ] = new Float64Array( col );\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction copy( outMatrix, sourceMatrix ) {\r\n\r\n\tconst tr = sourceMatrix.length;\r\n\tconst tc = sourceMatrix[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = sourceMatrix[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction clone( matrix ) {\r\n\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tconst resultMatrix = create( rows, cols );\r\n\tcopy( resultMatrix, matrix );\r\n\treturn resultMatrix;\r\n\r\n}\r\n\r\nfunction solve( outMatrix, matrix, vector ) {\r\n\r\n\tconst res = linearSolve.solve( matrix, vector );\r\n\tfor ( let i = 0, l = res.length; i < l; i ++ ) {\r\n\r\n\t\toutMatrix[ i ][ 0 ] = res[ i ];\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction invert( outMatrix, matrix ) {\r\n\r\n\tconst res = linearSolve.invert( matrix );\r\n\r\n\tconst tr = matrix[ 0 ].length;\r\n\tconst tc = matrix.length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = res[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction add( outMatrix, a, b ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] + b[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction subtract( outMatrix, a, b ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] - b[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction magnitudeSquared( matrix ) {\r\n\r\n\tlet sum = 0;\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tfor ( let r = 0; r < rows; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < cols; c ++ ) {\r\n\r\n\t\t\tsum += matrix[ r ][ c ] ** 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn sum;\r\n\r\n}\r\n\r\nfunction magnitude( matrix ) {\r\n\r\n\treturn Math.sqrt( magnitudeSquared( matrix ) );\r\n\r\n}\r\n\r\nfunction toString( matrix, dec = 3 ) {\r\n\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tlet str = '';\r\n\tfor ( let r = 0; r < rows; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < cols; c ++ ) {\r\n\r\n\t\t\tstr += matrix[ r ][ c ].toFixed( dec ) + ', ';\r\n\r\n\t\t}\r\n\r\n\t\tstr += '\\n';\r\n\r\n\t}\r\n\r\n\treturn str;\r\n\r\n}\r\n\r\nfunction log( matrix, dec ) {\r\n\r\n\tconsole.log( toString( matrix, dec ) );\r\n\r\n}\r\n\r\nexport const mat = {\r\n\ttranspose,\r\n\tidentity,\r\n\tscale,\r\n\tmultiply,\r\n\tcreate,\r\n\tcopy,\r\n\tclone,\r\n\tsolve,\r\n\tinvert,\r\n\tadd,\r\n\tsubtract,\r\n\tmagnitudeSquared,\r\n\tmagnitude,\r\n\ttoString,\r\n\tlog,\r\n};\r\n","import { mat } from './utils/matrix.js';\r\n\r\nclass FixedMatrixPool {\r\n\r\n\tconstructor( row, col ) {\r\n\r\n\t\tconst matrices = [];\r\n\t\tlet index = 0;\r\n\r\n\t\tthis.get = function () {\r\n\r\n\t\t\tlet matrix = matrices[ index ];\r\n\t\t\tif ( ! matrix ) {\r\n\r\n\t\t\t\tmatrices[ index ] = matrix = mat.create( row, col );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex ++;\r\n\t\t\treturn matrix;\r\n\r\n\t\t};\r\n\r\n\t\tthis.releaseAll = function () {\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class MatrixPool {\r\n\r\n\tconstructor() {\r\n\r\n\t\tconst pools = {};\r\n\t\tconst poolArray = [];\r\n\t\tthis.get = function ( row, col ) {\r\n\r\n\t\t\tlet colPools = pools[ row ];\r\n\t\t\tif ( ! colPools ) {\r\n\r\n\t\t\t\tcolPools = pools[ row ] = {};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet pool = colPools[ col ];\r\n\t\t\tif ( ! pool ) {\r\n\r\n\t\t\t\tpool = colPools[ col ] = new FixedMatrixPool( row, col );\r\n\t\t\t\tpoolArray.push( pool );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn pool.get();\r\n\r\n\t\t};\r\n\r\n\t\tthis.releaseAll = function () {\r\n\r\n\t\t\tfor ( let i = 0, l = poolArray.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tpoolArray[ i ].releaseAll();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","import { vec3, vec4 } from 'gl-matrix';\r\nimport { DOF } from '../Joint.js';\r\n\r\nconst tempPos = new Float64Array( 3 );\r\nconst tempQuat = new Float64Array( 4 );\r\nconst tempEuler = new Float64Array( 3 );\r\nexport function accumulateClosureError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\tdofFlags,\r\n\t\tdof,\r\n\t} = joint;\r\n\r\n\t// Get the error from child towards the closure target\r\n\tjoint.getClosureError( tempPos, tempQuat );\r\n\r\n\tlet rowCount = 7;\r\n\tif ( joint.isGoal ) {\r\n\r\n\t\ttempPos[ 0 ] *= dofFlags[ 0 ];\r\n\t\ttempPos[ 1 ] *= dofFlags[ 1 ];\r\n\t\ttempPos[ 2 ] *= dofFlags[ 2 ];\r\n\t\trowCount = translationDoFCount;\r\n\r\n\t\tif ( rotationDoFCount === 0 ) {\r\n\r\n\t\t\ttempQuat[ 0 ] = 0;\r\n\t\t\ttempQuat[ 1 ] = 0;\r\n\t\t\ttempQuat[ 2 ] = 0;\r\n\t\t\ttempQuat[ 3 ] = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trowCount += 4;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tlet isConverged = false;\r\n\tlet totalError = 0;\r\n\tconst posMag = vec3.length( tempPos );\r\n\tconst rotMag = vec4.length( tempQuat );\r\n\tif (\r\n\t\tposMag < translationConvergeThreshold &&\r\n\t\trotMag < rotationConvergeThreshold\r\n\t) {\r\n\r\n\t\tisConverged = true;\r\n\r\n\t}\r\n\r\n\ttotalError += posMag + rotMag;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tif ( posMag > translationErrorClamp ) {\r\n\r\n\t\t\tvec3.scale( tempPos, tempPos, translationErrorClamp / posMag );\r\n\r\n\t\t}\r\n\r\n\t\tvec4.scale( tempPos, tempPos, translationFactor );\r\n\r\n\t\tif ( rotMag > rotationErrorClamp ) {\r\n\r\n\t\t\tvec4.scale( tempQuat, tempQuat, rotationErrorClamp / rotMag );\r\n\r\n\t\t}\r\n\r\n\t\tvec4.scale( tempQuat, tempQuat, rotationFactor );\r\n\r\n\t\tif ( joint.isGoal ) {\r\n\r\n\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\r\n\r\n\t\t\t\tconst d = dof[ i ];\r\n\t\t\t\terrorVector[ startIndex + i ][ 0 ] = tempPos[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joint.rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 0 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 1 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 2 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 3 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\terrorVector[ startIndex + 0 ][ 0 ] = tempPos[ 0 ];\r\n\t\t\terrorVector[ startIndex + 1 ][ 0 ] = tempPos[ 1 ];\r\n\t\t\terrorVector[ startIndex + 2 ][ 0 ] = tempPos[ 2 ];\r\n\r\n\t\t\terrorVector[ startIndex + 3 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\terrorVector[ startIndex + 4 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\terrorVector[ startIndex + 5 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\terrorVector[ startIndex + 6 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tresult.totalError = totalError;\r\n\tresult.isConverged = isConverged;\r\n\tresult.rowCount = rowCount;\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function accumulateTargetError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\t// Find whether or not the target has converged or not\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\tlockedJointDoFCount,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\tlockedJointDoF,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\tdofTarget,\r\n\t\tdofValues,\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t\tdofList,\r\n\t} = joint;\r\n\r\n\t// get the position delta\r\n\tconst posDelta = vec3.distance( dofValues, dofTarget );\r\n\r\n\t// TODO: if three euler angles are being used we should set this to a quaternion to measure\r\n\t// error rather than euler angles. We should instead just always use quaternions for targets\r\n\t// for now.\r\n\t// Before running this solver we try to ensure the target and restPose are minimized\r\n\tlet rotDelta =\r\n\t\tdofTarget[ DOF.EX ] - dofValues[ DOF.EX ] +\r\n\t\tdofTarget[ DOF.EY ] - dofValues[ DOF.EY ] +\r\n\t\tdofTarget[ DOF.EZ ] - dofValues[ DOF.EZ ];\r\n\r\n\t// Get the row count\r\n\tconst lockedDoFCount = lockedJointDoFCount.get( joint ) || 0;\r\n\tresult.rowCount = translationDoFCount + rotationDoFCount - lockedDoFCount;\r\n\tresult.isConverged = posDelta < translationConvergeThreshold && rotDelta < rotationConvergeThreshold;\r\n\tresult.totalError = posDelta + rotDelta;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tconst lockedDoF = lockedJointDoF.get( joint );\r\n\t\tconst isLocked = lockedDoFCount !== 0;\r\n\r\n\t\tlet rowIndex = 0;\r\n\r\n\t\t// error from current state to target\r\n\t\ttempPos[ 0 ] = dofTarget[ 0 ] - dofValues[ 0 ];\r\n\t\ttempPos[ 1 ] = dofTarget[ 1 ] - dofValues[ 1 ];\r\n\t\ttempPos[ 2 ] = dofTarget[ 2 ] - dofValues[ 2 ];\r\n\r\n\t\t// clamp the position delta to the max error step\r\n\t\tconst posMag = vec3.length( tempPos );\r\n\t\tvec3.scale( tempPos, tempPos, translationFactor * translationErrorClamp / posMag );\r\n\t\tfor ( let i = 0, l = translationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempPos[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// get the euler differences\r\n\t\t// before running this solver we minimize the euler targets\r\n\t\ttempEuler[ 0 ] = joint.dofTarget[ 3 ] - joint.dofValues[ 3 ];\r\n\t\ttempEuler[ 1 ] = joint.dofTarget[ 4 ] - joint.dofValues[ 4 ];\r\n\t\ttempEuler[ 2 ] = joint.dofTarget[ 5 ] - joint.dofValues[ 5 ];\r\n\r\n\t\t// clamp the euler difference to the error step magnitude\r\n\t\tconst eulerMag = vec3.length( tempEuler );\r\n\t\tvec3.scale( tempEuler, tempEuler, rotationFactor * rotationErrorClamp / eulerMag );\r\n\t\tfor ( let i = translationDoFCount, l = translationDoFCount + rotationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempEuler[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { vec3, vec4, mat4 } from 'gl-matrix';\r\nimport { MatrixPool } from './MatrixPool.js';\r\nimport { accumulateClosureError, accumulateTargetError } from './utils/solver.js';\r\nimport { mat } from './utils/matrix.js';\r\nimport { getMatrixDifference } from './utils/glmatrix.js';\r\n\r\n// global stores\r\nconst matrixPool = new MatrixPool();\r\n\r\n// temp reusable variables\r\nconst targetRelativeToJointMatrix = new Float64Array( 16 );\r\nconst targetDeltaWorldMatrix = new Float64Array( 16 );\r\nconst tempDeltaWorldMatrix = new Float64Array( 16 );\r\nconst tempInverseMatrixWorld = new Float64Array( 16 );\r\nconst tempQuat = new Float64Array( 4 );\r\nconst tempPos = new Float64Array( 3 );\r\nconst tempQuat2 = new Float64Array( 4 );\r\nconst tempPos2 = new Float64Array( 3 );\r\n\r\nconst targetJoints = [];\r\nconst freeJoints = [];\r\nconst errorResultInfo = {\r\n\trowCount: 0,\r\n\tisConverged: false,\r\n\ttotalError: 0,\r\n};\r\nconst dofResultInfo = {\r\n\terrorRows: 0,\r\n\tfreeDoF: 0,\r\n\ttotalError: 0,\r\n};\r\n\r\nexport const SOLVE_STATUS = {\r\n\r\n\tCONVERGED: 0,\r\n\tSTALLED: 1,\r\n\tDIVERGED: 2,\r\n\tTIMEOUT: 3,\r\n\r\n};\r\n\r\nexport const SOLVE_STATUS_NAMES = Object.entries( SOLVE_STATUS ).sort( ( a, b ) => a[ 1 ] - b[ 1 ] ).map( el => el[ 0 ] );\r\n\r\nexport class ChainSolver {\r\n\r\n\tconstructor( chain ) {\r\n\r\n\t\tthis.chain = Array.from( chain );\r\n\r\n\t\t// list of targets we're trying to minimize in the chain\r\n\t\tthis.targets = null;\r\n\r\n\t\t// map of joint -> closures that the given jointa affects\r\n\t\tthis.affectedClosures = null;\r\n\r\n\t\t// map of joint -> closure children that the given joint affects\r\n\t\tthis.affectedConnectedClosures = null;\r\n\r\n\t\t// map of joint -> that stores the amount of DoF that are locked after\r\n\t\t// hitting a joint limit.\r\n\t\t// Undefined or 0 if none are locked\r\n\t\tthis.lockedJointDoFCount = null;\r\n\r\n\t\t// map of joint -> list of locked DoF\r\n\t\tthis.lockedJointDoF = null;\r\n\r\n\t\t// map of joint -> previous joint angles for resetting joint angles on\r\n\t\t// divergence check.\r\n\t\tthis.prevDoFValues = null;\r\n\r\n\t\t// options -- these are set by the containing Solver.\r\n\t\tthis.maxIterations = - 1;\r\n\r\n\t\tthis.translationConvergeThreshold = - 1;\r\n\t\tthis.rotationConvergeThreshold = - 1;\r\n\r\n\t\tthis.translationFactor = - 1;\r\n\t\tthis.rotationFactor = - 1;\r\n\r\n\t\tthis.translationStep = - 1;\r\n\t\tthis.rotationStep = - 1;\r\n\r\n\t\tthis.translationErrorClamp = - 1;\r\n\t\tthis.rotationErrorClamp = - 1;\r\n\r\n\t\tthis.stallThreshold = - 1;\r\n\t\tthis.dampingFactor = - 1;\r\n\t\tthis.divergeThreshold = - 1;\r\n\t\tthis.restPoseFactor = - 1;\r\n\r\n\t\tthis.init();\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\r\n\t\t// Find all joints with targets.\r\n\t\tconst chain = this.chain;\r\n\t\tconst targets = chain.filter( j => j.targetSet || j.isClosure );\r\n\r\n\t\tconst lockedJointDoF = new Map();\r\n\t\tconst lockedJointDoFCount = new Map();\r\n\t\tconst prevDoFValues = new Map();\r\n\r\n\t\tconst affectedClosures = new Map();\r\n\t\tconst affectedConnectedClosures = new Map();\r\n\t\tchain.forEach( j => {\r\n\r\n\t\t\t// Track which joints will have a direct affect on which targets move\r\n\t\t\t// for closure end effectors.\r\n\t\t\taffectedClosures.set( j, new Set() );\r\n\t\t\taffectedConnectedClosures.set( j, new Set() );\r\n\r\n\t\t\t// Initialize our array with all possible degrees of freedom\r\n\t\t\tlockedJointDoF.set( j, new Uint8Array( 6 ) );\r\n\t\t\tprevDoFValues.set( j, new Float64Array( 6 ) );\r\n\r\n\t\t} );\r\n\r\n\t\ttargets.forEach( target => {\r\n\r\n\t\t\tif ( target.isClosure ) {\r\n\r\n\t\t\t\tlet currJoint = target;\r\n\r\n\t\t\t\t// climb the joint tree and mark every joint as affecting this closure end.\r\n\t\t\t\twhile ( currJoint ) {\r\n\r\n\t\t\t\t\tif ( currJoint.isJoint ) {\r\n\r\n\t\t\t\t\t\taffectedClosures.get( currJoint ).add( target );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrJoint = currJoint.parent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// and mark the joints up the other chain as effecting the other connector link.\r\n\t\t\t\tcurrJoint = target.child;\r\n\t\t\t\twhile ( currJoint ) {\r\n\r\n\t\t\t\t\tif ( currJoint.isJoint ) {\r\n\r\n\t\t\t\t\t\taffectedConnectedClosures.get( currJoint ).add( target );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrJoint = currJoint.parent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tthis.targets = targets;\r\n\t\tthis.affectedClosures = affectedClosures;\r\n\t\tthis.affectedConnectedClosures = affectedConnectedClosures;\r\n\t\tthis.lockedJointDoF = lockedJointDoF;\r\n\t\tthis.lockedJointDoFCount = lockedJointDoFCount;\r\n\t\tthis.prevDoFValues = prevDoFValues;\r\n\r\n\t}\r\n\r\n\tsolve() {\r\n\r\n\t\tconst {\r\n\t\t\tdivergeThreshold,\r\n\t\t\tstallThreshold,\r\n\t\t\tchain,\r\n\t\t\trestPoseFactor,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t\tprevDoFValues,\r\n\t\t} = this;\r\n\r\n\t\tlet iterations = 0;\r\n\t\tlet prevErrorMagnitude = Infinity;\r\n\t\tlet status = - 1;\r\n\r\n\t\t// Clear out all the locked joints\r\n\t\tlockedJointDoFCount.clear();\r\n\r\n\t\t// TODO: instead of trying to use minimal euler angles we should try to represent joint\r\n\t\t// error as a quaternion in the quaternion vector.\r\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst joint = chain[ i ];\r\n\t\t\tif ( joint.targetSet || joint.restPoseSet ) {\r\n\r\n\t\t\t\tjoint.tryMinimizeEulerAngles();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdo {\r\n\r\n\t\t\tmatrixPool.releaseAll();\r\n\r\n\t\t\t// Make sure our matrices are all up to date\r\n\t\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst joint = chain[ i ];\r\n\t\t\t\tjoint.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: this only needs to be recomputed if a joint was locked so maybe lets check that? We also\r\n\t\t\t// lock joints inside this function so maybe we can forgo that?\r\n\t\t\ttargetJoints.length = 0;\r\n\t\t\tfreeJoints.length = 0;\r\n\t\t\tthis.countUnconvergedVariables( freeJoints, targetJoints, dofResultInfo );\r\n\t\t\tconst { freeDoF, errorRows, totalError } = dofResultInfo;\r\n\r\n\t\t\t// Check if we've converged\r\n\t\t\tif ( errorRows === 0 ) {\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.CONVERGED;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check if we've diverged\r\n\t\t\tif ( totalError > prevErrorMagnitude + divergeThreshold ) {\r\n\r\n\t\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\r\n\r\n\t\t\t\t\tjoint.dofValues.set( dofValues );\r\n\t\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t\t\t} );\r\n\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.DIVERGED;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevErrorMagnitude = totalError;\r\n\r\n\t\t\t// Check if we've hit max iterations\r\n\t\t\titerations ++;\r\n\t\t\tif ( iterations > this.maxIterations ) {\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.TIMEOUT;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// A * x = b\r\n\t\t\t// find x such that it yields b where is the clamped error we're trying to work towards\r\n\t\t\t// and A is the jacobian, and x is the delta joint angles.\r\n\r\n\t\t\tconst errorVector = matrixPool.get( errorRows, 1 );\r\n\t\t\tthis.fillErrorVector( targetJoints, errorVector );\r\n\r\n\t\t\tconst jacobian = matrixPool.get( errorRows, freeDoF );\r\n\t\t\tthis.fillJacobian( targetJoints, freeJoints, jacobian );\r\n\r\n\t\t\t// TODO: try to solve with SVD method -- do we really need to? Why not just always use the transpose method?\r\n\r\n\t\t\t// Use a transpose pseudo inverse approach: A^T * A * x = A^T * b with the damping term\r\n\t\t\t// J^T * J * x = J^T * e\r\n\t\t\t// x = J^T * ( J * J^T )^-1 * e\r\n\r\n\t\t\t// and with the adding damping\r\n\t\t\t// x = J^T * ( J * J^T + l^2 * I )^-1 * e\r\n\r\n\t\t\t// l^2 * I\r\n\t\t\tconst jacobianIdentityDamping = matrixPool.get( errorRows, errorRows );\r\n\t\t\tmat.identity( jacobianIdentityDamping );\r\n\t\t\tmat.scale( jacobianIdentityDamping, jacobianIdentityDamping, this.dampingFactor ** 2 );\r\n\r\n\t\t\t// J^T\r\n\t\t\tconst jacobianTranspose = matrixPool.get( freeDoF, errorRows );\r\n\t\t\tmat.transpose( jacobianTranspose, jacobian );\r\n\r\n\t\t\t// J * J^T\r\n\t\t\tconst jjt = matrixPool.get( errorRows, errorRows );\r\n\t\t\tmat.multiply( jjt, jacobian, jacobianTranspose );\r\n\r\n\t\t\t// J * J^T + l^2 * I\r\n\t\t\tconst jjti = matrixPool.get( errorRows, errorRows );\r\n\t\t\tmat.add( jjti, jjt, jacobianIdentityDamping );\r\n\r\n\t\t\t// ( J * J^T + l^2 * I )^-1\r\n\t\t\tconst jjtii = matrixPool.get( errorRows, errorRows );\r\n\t\t\tmat.invert( jjtii, jjti );\r\n\r\n\t\t\t// J^T * ( J * J^T + l^2 * I )^-1\r\n\t\t\tconst pseudoInverse = matrixPool.get( freeDoF, errorRows );\r\n\t\t\tmat.multiply( pseudoInverse, jacobianTranspose, jjtii );\r\n\r\n\t\t\t// x = deltaTheta = J^T * ( J * J^T + l^2 * I )^-1 * e\r\n\t\t\tconst deltaTheta = matrixPool.get( freeDoF, 1 );\r\n\t\t\tmat.multiply( deltaTheta, pseudoInverse, errorVector );\r\n\r\n\t\t\t// console.log( 'ERROR VECTOR', errorVector );\r\n\t\t\t// console.log( 'JACOBIAN', jacobian );\r\n\t\t\t// console.log( 'DELTA_THETA', deltaTheta );\r\n\r\n\t\t\tif ( restPoseFactor !== 0 ) {\r\n\r\n\t\t\t\t// Nullspace Projection\r\n\t\t\t\t// I - J^-1 * J is the orthogonal null space of J where J^-1 is the pseudoinverse\r\n\t\t\t\t// Multiplied by the rest position of each dof\r\n\t\t\t\t// ( I - J^-1 * J ) * restPose\r\n\t\t\t\tconst restPose = matrixPool.get( freeDoF, 1 );\r\n\t\t\t\tconst restPoseResult = matrixPool.get( freeDoF, 1 );\r\n\t\t\t\tlet colIndex = 0;\r\n\t\t\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst joint = freeJoints[ i ];\r\n\t\t\t\t\tconst lockedDoFCount = this.lockedJointDoFCount.get( joint ) || 0;\r\n\t\t\t\t\tconst isLocked = lockedDoFCount !== 0;\r\n\t\t\t\t\tconst lockedDoF = this.lockedJointDoF.get( joint );\r\n\r\n\t\t\t\t\tconst colCount = joint.rotationDoFCount + joint.translationDoFCount - lockedDoFCount;\r\n\t\t\t\t\tif ( joint.restPoseSet ) {\r\n\r\n\t\t\t\t\t\tconst dofList = joint.dof;\r\n\t\t\t\t\t\tconst dofValues = joint.dofValues;\r\n\t\t\t\t\t\tconst dofRestPose = joint.dofRestPose;\r\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\r\n\r\n\t\t\t\t\t\t\t// NOTE: this is reversed because in applyAngles we're having to negate the\r\n\t\t\t\t\t\t\t// delta angles for some reason atm\r\n\t\t\t\t\t\t\tconst dof = dofList[ d ];\r\n\r\n\t\t\t\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) continue;\r\n\r\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = dofValues[ dof ] - dofRestPose[ dof ];\r\n\t\t\t\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\r\n\r\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = 0;\r\n\t\t\t\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// J^-1 * J\r\n\t\t\t\tconst jij = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.multiply( jij, pseudoInverse, jacobian );\r\n\r\n\t\t\t\t// ( I - J^-1 * J )\r\n\t\t\t\tconst jiji = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.identity( jiji );\r\n\t\t\t\tmat.subtract( jiji, jiji, jij );\r\n\r\n\t\t\t\t// ( I - J^-1 * J ) * restPose\r\n\t\t\t\tmat.multiply( restPoseResult, jiji, restPose );\r\n\r\n\t\t\t\tfor ( let r = 0; r < freeDoF; r ++ ) {\r\n\r\n\t\t\t\t\tdeltaTheta[ r ][ 0 ] += restPose[ r ][ 0 ] * restPoseFactor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check if our joints have not moved and returned stalled\r\n\t\t\tif ( stallThreshold > 0 ) {\r\n\r\n\t\t\t\tlet stalled = true;\r\n\t\t\t\tfor ( let i = 0, l = deltaTheta.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst delta = deltaTheta[ i ][ 0 ];\r\n\t\t\t\t\tif ( Math.abs( delta ) > stallThreshold ) {\r\n\r\n\t\t\t\t\t\tstalled = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( stalled ) {\r\n\r\n\t\t\t\t\tstatus = SOLVE_STATUS.STALLED;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Prep for a divergence check\r\n\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\r\n\r\n\t\t\t\tdofValues.set( joint.dofValues );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\t// apply the latest joint angles and lock and joints that have\r\n\t\t\t// hit their joint limits.\r\n\t\t\tthis.applyJointAngles( freeJoints, deltaTheta );\r\n\r\n\t\t\t// there's still error and we're under the max iterations\r\n\r\n\t\t} while ( true );\r\n\r\n\t\ttargetJoints.length = 0;\r\n\t\tfreeJoints.length = 0;\r\n\t\treturn status;\r\n\r\n\t}\r\n\r\n\t// Apply the delta values from the solve to the free joints in the list\r\n\tapplyJointAngles( freeJoints, deltaTheta ) {\r\n\r\n\t\tconst {\r\n\t\t\tlockedJointDoF,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t} = this;\r\n\r\n\t\tlet lockedJoint = false;\r\n\t\tlet dti = 0;\r\n\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\t// Apply the delta to every free joint\r\n\t\t\tconst joint = freeJoints[ i ];\r\n\t\t\tconst dofList = joint.dof;\r\n\t\t\tconst lockedDoF = lockedJointDoF.get( joint );\r\n\t\t\tconst isLocked = lockedJointDoFCount.has( joint );\r\n\r\n\t\t\tfor ( let d = 0, l = dofList.length; d < l; d ++ ) {\r\n\r\n\t\t\t\tconst dof = dofList[ d ];\r\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: why are we negating here?\r\n\t\t\t\tconst value = joint.getDoFValue( dof );\r\n\t\t\t\tconst hitLimit = joint.setDoFValue( dof, value - deltaTheta[ dti ][ 0 ] );\r\n\r\n\t\t\t\t// lock the joint if we hit a limit\r\n\t\t\t\tif ( hitLimit ) {\r\n\r\n\t\t\t\t\tif ( ! lockedJointDoFCount.has( joint ) ) {\r\n\r\n\t\t\t\t\t\tlockedJointDoFCount.set( joint, 0 );\r\n\t\t\t\t\t\tlockedDoF.fill( 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst lockedCount = lockedJointDoFCount.get( joint );\r\n\t\t\t\t\tlockedJointDoFCount.set( joint, lockedCount + 1 );\r\n\t\t\t\t\tlockedDoF[ dof ] = 1;\r\n\t\t\t\t\tlockedJoint = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dti !== deltaTheta.length ) {\r\n\r\n\t\t\tthrow new Error();\r\n\r\n\t\t}\r\n\r\n\t\treturn lockedJoint;\r\n\r\n\t}\r\n\r\n\t// generate the jacobian\r\n\t// The jacobian has one column for each free degree of freedom and a row for every\r\n\t// target degree of freedom we have. The entries are generated by adjusting every\r\n\t// DoF by some epsilon and storing how much it affected the target error.\r\n\tfillJacobian( targetJoints, freeJoints, outJacobian ) {\r\n\r\n\t\tconst {\r\n\t\t\ttranslationStep,\r\n\t\t\trotationStep,\r\n\t\t\tlockedJointDoF,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t\ttranslationFactor,\r\n\t\t\trotationFactor,\r\n\t\t} = this;\r\n\r\n\t\t// TODO: abstract this\r\n\t\tconst affectedClosures = this.affectedClosures;\r\n\t\tconst affectedConnectedClosures = this.affectedConnectedClosures;\r\n\r\n\t\tlet colIndex = 0;\r\n\t\tfor ( let c = 0, tc = freeJoints.length; c < tc; c ++ ) {\r\n\r\n\t\t\t// TODO: If this is a goal we should skip adding it to the jacabian columns\r\n\t\t\tconst freeJoint = freeJoints[ c ];\r\n\t\t\tconst relevantClosures = affectedClosures.get( freeJoint );\r\n\t\t\tconst relevantConnectedClosures = affectedConnectedClosures.get( freeJoint );\r\n\t\t\tconst dofList = freeJoint.dof;\r\n\t\t\tconst colCount = freeJoint.translationDoFCount + freeJoint.rotationDoFCount;\r\n\r\n\t\t\tconst isLocked = lockedJointDoFCount.has( freeJoint );\r\n\t\t\tconst lockedDoF = lockedJointDoF.get( freeJoint );\r\n\r\n\t\t\t// get the world inverse of the free joint\r\n\t\t\tmat4.invert( tempInverseMatrixWorld, freeJoint.matrixWorld );\r\n\r\n\t\t\t// iterate over every degree of freedom in the joint\r\n\t\t\tfor ( let co = 0; co < colCount; co ++ ) {\r\n\r\n\t\t\t\tconst dof = dofList[ co ];\r\n\r\n\t\t\t\t// skip this joint if it's locked\r\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rowIndex = 0;\r\n\r\n\t\t\t\t// generate the adjusted matrix based on the epsilon for the joint.\r\n\t\t\t\tlet delta = dof < 3 ? translationStep : rotationStep;\r\n\t\t\t\tif ( freeJoint.getDeltaWorldMatrix( dof, delta, tempDeltaWorldMatrix ) ) {\r\n\r\n\t\t\t\t\tdelta *= - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Iterate over every target\r\n\t\t\t\tfor ( let r = 0, tr = targetJoints.length; r < tr; r ++ ) {\r\n\r\n\t\t\t\t\tconst targetJoint = targetJoints[ r ];\r\n\r\n\t\t\t\t\t// if it's a closure target\r\n\t\t\t\t\tif ( targetJoint.isClosure ) {\r\n\r\n\t\t\t\t\t\tif ( relevantClosures.has( targetJoint ) || relevantConnectedClosures.has( targetJoint ) ) {\r\n\r\n\t\t\t\t\t\t\t// TODO: If this is a Goal it only add 1 or 2 fields if only two axes are set. Quat is only\r\n\t\t\t\t\t\t\t// needed if 3 eulers are used.\r\n\t\t\t\t\t\t\t// TODO: these could be cached per target joint get the current error within the closure joint\r\n\r\n\t\t\t\t\t\t\t// Get the error from child towards the closure target\r\n\t\t\t\t\t\t\ttargetJoint.getClosureError( tempPos, tempQuat );\r\n\t\t\t\t\t\t\tif ( relevantConnectedClosures.has( targetJoint ) ) {\r\n\r\n\t\t\t\t\t\t\t\t// If this is affecting a link connected to a closure joint then adjust that child link by\r\n\t\t\t\t\t\t\t\t// the delta rotation.\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.child.matrixWorld );\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\r\n\r\n\t\t\t\t\t\t\t\t// Get the new error\r\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetJoint.matrixWorld, targetDeltaWorldMatrix, tempPos2, tempQuat2 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// If this is directly affecting a closure joint then adjust that child link by the delta\r\n\t\t\t\t\t\t\t\t// rotation.\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.matrixWorld );\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\r\n\r\n\t\t\t\t\t\t\t\t// Get the new error\r\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetDeltaWorldMatrix, targetJoint.child.matrixWorld, tempPos2, tempQuat2 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Get the amount that the rotation and translation error changed due to the\r\n\t\t\t\t\t\t\t// small DoF adjustment to serve as the derivative.\r\n\t\t\t\t\t\t\tvec3.subtract( tempPos, tempPos2, tempPos );\r\n\t\t\t\t\t\t\tvec3.scale( tempPos, tempPos, translationFactor / delta );\r\n\r\n\t\t\t\t\t\t\tvec4.subtract( tempQuat, tempQuat2, tempQuat );\r\n\t\t\t\t\t\t\tvec4.scale( tempQuat, tempQuat, rotationFactor / delta );\r\n\r\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\r\n\r\n\t\t\t\t\t\t\t\tconst { translationDoFCount, rotationDoFCount, dof } = targetJoint;\r\n\t\t\t\t\t\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst d = dof[ i ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = tempPos[ d ];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif ( rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 0 ][ colIndex ] = tempQuat[ 0 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 1 ][ colIndex ] = tempQuat[ 1 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 2 ][ colIndex ] = tempQuat[ 2 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 3 ][ colIndex ] = tempQuat[ 3 ];\r\n\t\t\t\t\t\t\t\t\trowIndex += 4;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\trowIndex += translationDoFCount;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// set translation\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 0 ][ colIndex ] = tempPos[ 0 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 1 ][ colIndex ] = tempPos[ 1 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 2 ][ colIndex ] = tempPos[ 2 ];\r\n\r\n\t\t\t\t\t\t\t\t// set rotation\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 3 ][ colIndex ] = tempQuat[ 0 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 4 ][ colIndex ] = tempQuat[ 1 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 5 ][ colIndex ] = tempQuat[ 2 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 6 ][ colIndex ] = tempQuat[ 3 ];\r\n\t\t\t\t\t\t\t\trowIndex += 7;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// if the target isn't relevant then there's no delta\r\n\t\t\t\t\t\t\tlet totalRows = 7;\r\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\r\n\r\n\t\t\t\t\t\t\t\ttotalRows = targetJoint.translationDoFCount;\r\n\t\t\t\t\t\t\t\tif ( targetJoint.rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttotalRows += 4;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < totalRows; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\trowIndex += totalRows;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check if this joint has a target set and update the jacobian rows if it does\r\n\t\t\t\t\tif ( targetJoint.targetSet ) {\r\n\r\n\t\t\t\t\t\tconst rowCount = targetJoint.translationDoFCount + targetJoint.rotationDoFCount;\r\n\r\n\t\t\t\t\t\tif ( freeJoint === targetJoint ) {\r\n\r\n\t\t\t\t\t\t\t// if we're just dealing with a target dof joint then there can't be any influence\r\n\t\t\t\t\t\t\t// but otherwise the only joint that can have an effect on this error is the joint\r\n\t\t\t\t\t\t\t// itself.\r\n\t\t\t\t\t\t\t// TODO: Having noted that is this really necessary? Is there any way that this doesn't just\r\n\t\t\t\t\t\t\t// jump to the solution and lock? How can we afford some slack? With a low weight? Does that\r\n\t\t\t\t\t\t\t// get applied here?\r\n\t\t\t\t\t\t\t// TODO: If this joint happens to have three euler joints we need to use a quat here. Otherwise we\r\n\t\t\t\t\t\t\t// use the euler angles.\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + colIndex ][ colIndex ] = - 1;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\trowIndex += rowCount;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( colIndex !== outJacobian[ 0 ].length ) {\r\n\r\n\t\t\tthrow new Error();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Fill in the error vector\r\n\tfillErrorVector( targetJoints, errorVector ) {\r\n\r\n\t\tlet rowIndex = 0;\r\n\t\tfor ( let i = 0, l = targetJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst joint = targetJoints[ i ];\r\n\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\taccumulateClosureError( this, joint, rowIndex, errorVector, errorResultInfo );\r\n\t\t\t\trowIndex += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\taccumulateTargetError( this, joint, rowIndex, errorVector, errorResultInfo );\r\n\t\t\t\trowIndex += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Count the unconverged targets in the chain and store them in targetJoints and store\r\n\t// any freeJoints in\r\n\tcountUnconvergedVariables( freeJoints, targetJoints, dofResultInfo ) {\r\n\r\n\t\tconst { lockedJointDoFCount } = this;\r\n\r\n\t\tconst chain = this.chain;\r\n\t\tlet totalError = 0;\r\n\t\tlet errorRows = 0;\r\n\t\tlet unconvergedRows = 0;\r\n\t\tlet freeDoF = 0;\r\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\tlet addToTargetList = false;\r\n\t\t\tconst joint = chain[ i ];\r\n\t\t\tconst lockedDoF = lockedJointDoFCount.get( joint ) || 0;\r\n\r\n\t\t\t// TODO: Should we check every variable against the convergence threshold or is\r\n\t\t\t// it better to check the magnitude?\r\n\r\n\t\t\t// TODO: We may be able to speed this up by using the square distance and length\r\n\t\t\t// to compare error.\r\n\r\n\t\t\t// TODO: If this is a goal we shouldnt add to the free dof because they won't be added\r\n\t\t\t// to the jacobian\r\n\r\n\t\t\t// If this is a closure joint then we need to make sure we're solving\r\n\t\t\t// for the other child end to meet this joint so this error is important.\r\n\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\taccumulateClosureError( this, joint, errorRows, null, errorResultInfo );\r\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\r\n\r\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\r\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddToTargetList = true;\r\n\t\t\t\terrorRows += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check out far the joint is from the target dof value.\r\n\t\t\tconst dofList = joint.dof;\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\taccumulateTargetError( this, joint, errorRows, null, errorResultInfo );\r\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\r\n\r\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\r\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddToTargetList = true;\r\n\t\t\t\terrorRows += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! joint.isGoal ) {\r\n\r\n\t\t\t\tfreeDoF += dofList.length - lockedDoF;\r\n\t\t\t\tfreeJoints.push( joint );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( addToTargetList ) {\r\n\r\n\t\t\t\ttargetJoints.push( joint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// if it turns out that everything is converged.\r\n\t\tif ( unconvergedRows === 0 ) {\r\n\r\n\t\t\terrorRows = 0;\r\n\r\n\t\t}\r\n\r\n\t\tdofResultInfo.errorRows = errorRows;\r\n\t\tdofResultInfo.freeDoF = freeDoF;\r\n\t\tdofResultInfo.totalError = totalError;\r\n\r\n\t}\r\n\r\n}\r\n","import { ChainSolver } from './ChainSolver.js';\r\n\r\nexport class Solver {\r\n\r\n\tconstructor( roots = [] ) {\r\n\r\n\t\tthis.maxIterations = 5;\r\n\t\tthis.stallThreshold = 1e-4;\r\n\t\tthis.dampingFactor = 0.001;\r\n\t\tthis.divergeThreshold = 0.01;\r\n\t\tthis.restPoseFactor = 0.01;\r\n\r\n\t\tthis.translationConvergeThreshold = 1e-3;\r\n\t\tthis.rotationConvergeThreshold = 1e-5;\r\n\r\n\t\tthis.translationFactor = 1;\r\n\t\tthis.rotationFactor = 1;\r\n\r\n\t\tthis.translationStep = 1e-3;\r\n\t\tthis.rotationStep = 1e-3;\r\n\r\n\t\tthis.translationErrorClamp = 0.1;\r\n\t\tthis.rotationErrorClamp = 0.1;\r\n\r\n\t\tthis.roots = Array.isArray( roots ) ? [ ...roots ] : [ roots ];\r\n\t\tthis.solvers = null;\r\n\r\n\t\tthis.updateStructure();\r\n\r\n\t}\r\n\r\n\t// needs to be called whenever tree structure is updated\r\n\tupdateStructure() {\r\n\r\n\t\tconst roots = this.roots;\r\n\t\tconst chains = [];\r\n\t\tconst traversal = new Set();\r\n\t\tconst allChainJoints = new Set();\r\n\t\tconst traverseChains = frame => {\r\n\r\n\t\t\t// If we found a joint then add it to the traversal list\r\n\t\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\t\tconst joint = frame;\r\n\t\t\t\ttraversal.add( joint );\r\n\r\n\t\t\t\t// If we found a closure joint\r\n\t\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\t\t// Traverse back up the tree until we find a common ancestor\r\n\t\t\t\t\t// and create a new chain\r\n\t\t\t\t\tconst chainSet = new Set();\r\n\t\t\t\t\tlet curr = joint.child;\r\n\t\t\t\t\twhile ( curr ) {\r\n\r\n\t\t\t\t\t\tif ( curr.isJoint ) {\r\n\r\n\t\t\t\t\t\t\tif ( traversal.has( curr ) ) {\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tchainSet.add( curr );\r\n\t\t\t\t\t\t\t\tallChainJoints.add( curr );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurr = curr.parent;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttraversal.forEach( c => {\r\n\r\n\t\t\t\t\t\tchainSet.add( c );\r\n\t\t\t\t\t\tallChainJoints.add( c );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tchains.push( chainSet );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Continue traversing\r\n\t\t\tconst children = frame.children;\r\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\ttraverseChains( children[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Remove the joint from our traversal set\r\n\t\t\ttraversal.delete( frame );\r\n\r\n\t\t};\r\n\r\n\t\t// find all chains in the roots\r\n\t\troots.forEach( traverseChains );\r\n\r\n\t\t// Merge interdependent chains\r\n\t\tconst independentChains = [];\r\n\t\twhile ( chains.length ) {\r\n\r\n\t\t\tconst currChain = chains.pop();\r\n\t\t\tindependentChains.push( currChain );\r\n\t\t\tfor ( let i = 0; i < chains.length; i ++ ) {\r\n\r\n\t\t\t\t// see if this chain is dependent on the current chain\r\n\t\t\t\t// and if so merge the chains.\r\n\t\t\t\tconst otherChain = chains[ i ];\r\n\r\n\t\t\t\tlet dependent = false;\r\n\t\t\t\totherChain.forEach( c => {\r\n\r\n\t\t\t\t\tdependent = dependent || currChain.has( c );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tif ( dependent ) {\r\n\r\n\t\t\t\t\totherChain.forEach( c => currChain.add( c ) );\r\n\t\t\t\t\tchains.splice( i, 1 );\r\n\t\t\t\t\ti --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Find any joints that aren't considered part of a solve chain so we\r\n\t\t// can just update them using forward kinematics.\r\n\t\tconst nonChainJoints = new Set();\r\n\t\troots.forEach( root => root.traverse( c => {\r\n\r\n\t\t\tif ( c.isJoint && c.dof.length > 0 && ! allChainJoints.has( c ) ) {\r\n\r\n\t\t\t\tnonChainJoints.add( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t} ) );\r\n\r\n\t\t// Create the solvers for the chains\r\n\t\tthis.solvers = independentChains.map( c => new ChainSolver( c ) );\r\n\t\tthis.nonChainJoints = nonChainJoints;\r\n\r\n\t}\r\n\r\n\tsolve() {\r\n\r\n\t\tconst { solvers, nonChainJoints } = this;\r\n\r\n\t\t// update any non chain joints\r\n\t\tnonChainJoints.forEach( joint => {\r\n\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\tjoint.dofValues.set( joint.dofTarget );\r\n\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tconst results = [];\r\n\t\tfor ( let i = 0, l = solvers.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst s = solvers[ i ];\r\n\t\t\ts.maxIterations = this.maxIterations;\r\n\t\t\ts.stallThreshold = this.stallThreshold;\r\n\t\t\ts.dampingFactor = this.dampingFactor;\r\n\t\t\ts.divergeThreshold = this.divergeThreshold;\r\n\t\t\ts.restPoseFactor = this.restPoseFactor;\r\n\r\n\t\t\ts.translationConvergeThreshold = this.translationConvergeThreshold;\r\n\t\t\ts.rotationConvergeThreshold = this.rotationConvergeThreshold;\r\n\r\n\t\t\ts.translationFactor = this.translationFactor;\r\n\t\t\ts.rotationFactor = this.rotationFactor;\r\n\r\n\t\t\ts.translationStep = this.translationStep;\r\n\t\t\ts.rotationStep = this.rotationStep;\r\n\r\n\t\t\ts.translationErrorClamp = this.translationErrorClamp;\r\n\t\t\ts.rotationErrorClamp = this.rotationErrorClamp;\r\n\r\n\t\t\tconst result = s.solve();\r\n\t\t\tresults.push( result );\r\n\r\n\t\t}\r\n\r\n\t\treturn results;\r\n\r\n\t}\r\n\r\n}\r\n","import { Joint, DOF } from './Joint.js';\n\nexport class Goal extends Joint {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.isGoal = true;\n\t\tthis.setFreeDoF();\n\n\t}\n\n\tsetDoF( ...args ) {\n\n\t\t// We don't support rotation goals that only specify 1 or 2 free rotation axes.\n\t\tlet rotCount =\n\t\t\tNumber( args.includes( DOF.EX ) ) +\n\t\t\tNumber( args.includes( DOF.EY ) ) +\n\t\t\tNumber( args.includes( DOF.EZ ) );\n\n\t\tif ( rotCount !== 0 && rotCount !== 3 ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tsuper.setDoF( ...args );\n\n\t}\n\n\tsetGoalDoF( ...args ) {\n\n\t\tthis.setDoF( ...args );\n\n\t}\n\n\tsetFreeDoF( ...args ) {\n\n\t\tconst freeDoF = [\n\t\t\tDOF.X, DOF.Y, DOF.Z,\n\t\t\tDOF.EX, DOF.EY, DOF.EZ,\n\t\t].filter( d => ! args.includes( d ) );\n\t\tthis.setDoF( ...freeDoF );\n\n\t}\n\n\taddChild() {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n","import { Joint } from '../core/Joint.js';\r\nimport { Link } from '../core/Link.js';\r\nimport { Goal } from '../core/Goal.js';\r\n\r\n// Takes a list of interconnected frames and serializes them into a non cyclic json representation\r\nexport function serialize( frames ) {\r\n\r\n\tconst map = new Map();\r\n\tconst info = [];\r\n\r\n\t// Create the initial frame list along with a joint -> index map\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tconst frame = frames[ i ];\r\n\r\n\t\tconst {\r\n\t\t\tname,\r\n\t\t\tdof,\r\n\t\t\tdofValues,\r\n\t\t\tdofTarget,\r\n\t\t\tdofRestPose,\r\n\t\t\tminDoFLimit,\r\n\t\t\tmaxDoFLimit,\r\n\t\t\ttargetSet,\r\n\t\t\trestPoseSet,\r\n\t\t\tposition,\r\n\t\t\tquaternion,\r\n\t\t\tisClosure,\r\n\t\t} = frame;\r\n\r\n\t\tlet type = 'Link';\r\n\t\tif ( frame.isGoal ) {\r\n\r\n\t\t\ttype = 'Goal';\r\n\r\n\t\t} else if ( frame.isJoint ) {\r\n\r\n\t\t\ttype = 'Joint';\r\n\r\n\t\t}\r\n\r\n\t\tconst res = {\r\n\t\t\tdof: dof ? dof.slice() : null,\r\n\t\t\tdofValues: dofValues ? dofValues.slice() : null,\r\n\t\t\tdofTarget: dofTarget ? dofTarget.slice() : null,\r\n\t\t\tdofRestPose: dofRestPose ? dofRestPose.slice() : null,\r\n\t\t\tminDoFLimit: minDoFLimit ? minDoFLimit.slice() : null,\r\n\t\t\tmaxDoFLimit: maxDoFLimit ? maxDoFLimit.slice() : null,\r\n\t\t\ttargetSet,\r\n\t\t\trestPoseSet,\r\n\t\t\tisClosure,\r\n\r\n\t\t\tname,\r\n\t\t\tposition: position.slice(),\r\n\t\t\tquaternion: quaternion.slice(),\r\n\t\t\tchildren: null,\r\n\t\t\ttype,\r\n\t\t};\r\n\r\n\t\tinfo.push( res );\r\n\t\tmap.set( frame, i );\r\n\r\n\t}\r\n\r\n\t// Create the child and parent index references.\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tconst inf = info[ i ];\r\n\t\tconst frame = frames[ i ];\r\n\t\tinf.children = frame.children.map( c => map.get( c ) );\r\n\r\n\t\tif ( frame.parent ) {\r\n\r\n\t\t\tinf.parent = map.get( frame.parent );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinf.parent = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn info;\r\n\r\n}\r\n\r\n// Deserialize the serialized representation of the graph\r\nexport function deserialize( data ) {\r\n\r\n\t// Create joints / links for every serialized version\r\n\tconst frames =\r\n\t\tdata.map( d => {\r\n\r\n\t\t\tconst {\r\n\t\t\t\ttype,\r\n\t\t\t\tname,\r\n\t\t\t\tposition,\r\n\t\t\t\tquaternion,\r\n\r\n\t\t\t\tdof,\r\n\t\t\t\tdofValues,\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t\ttargetSet,\r\n\t\t\t\trestPoseSet,\r\n\t\t\t\tisClosure,\r\n\t\t\t} = d;\r\n\r\n\t\t\tlet frame;\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'Goal':\r\n\t\t\t\tcase 'Joint':\r\n\t\t\t\t\tframe = type === 'Goal' ? new Goal() : new Joint();\r\n\r\n\t\t\t\t\tframe.setDoF( ...dof );\r\n\t\t\t\t\tframe.dofValues.set( dofValues );\r\n\t\t\t\t\tframe.dofTarget.set( dofTarget );\r\n\t\t\t\t\tframe.dofRestPose.set( dofRestPose );\r\n\t\t\t\t\tframe.minDoFLimit.set( minDoFLimit );\r\n\t\t\t\t\tframe.maxDoFLimit.set( maxDoFLimit );\r\n\r\n\t\t\t\t\tframe.targetSet = targetSet;\r\n\t\t\t\t\tframe.restPoseSet = restPoseSet;\r\n\t\t\t\t\tframe.isClosure = isClosure;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'Link':\r\n\t\t\t\t\tframe = new Link();\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tframe.name = name;\r\n\t\t\tframe.position.set( position );\r\n\t\t\tframe.quaternion.set( quaternion );\r\n\t\t\treturn frame;\r\n\r\n\t\t} );\r\n\r\n\t// set the parent and child from the maps\r\n\tfor ( let i = 0; i < frames.length; i ++ ) {\r\n\r\n\t\tconst frame = frames[ i ];\r\n\t\tconst info = data[ i ];\r\n\r\n\t\tframe.parent = frames[ info.parent ] || null;\r\n\t\tframe.children.push( ...info.children.map( i => frames[ i ] ) );\r\n\t\tframe.setMatrixNeedsUpdate();\r\n\r\n\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\tframe.child = frame.children[ 0 ] || null;\r\n\t\t\tframe.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn frames;\r\n\r\n}\r\n","export const JOINT_STRIDE = 304;\r\n\r\nexport const LINK_STRIDE = 56;\r\n\r\nexport function generateSharedBuffer( frames ) {\r\n\r\n\t// dofValues \t6 * 4\r\n\t// dofTarget \t6 * 4\r\n\t// dofRestPose \t6 * 4\r\n\t// minDoFLimit \t6 * 4\r\n\t// maxDoFLimit \t6 * 4\r\n\t// position \t3 * 4\r\n\t// quaternion \t4 * 4\r\n\t// targetSet \t1\r\n\t// restPoseSet \t1\r\n\t// --\r\n\t// total  \t\t150 bytes per joint\r\n\t// 4 byte aligned: 152\r\n\r\n\tconst arrayBuffer = new SharedArrayBuffer( JOINT_STRIDE * frames.length );\r\n\tconst float64 = new Float32Array( arrayBuffer );\r\n\tconst byte8 = new Uint8Array( arrayBuffer );\r\n\tapplyToBuffer( frames, float64, byte8 );\r\n\treturn arrayBuffer;\r\n\r\n}\r\n\r\nexport function applyToBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyFrameToBuffer( frames[ i ], floatBuffer, byteBuffer, i * JOINT_STRIDE, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function applyFromBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyBufferToFrame( frames[ i ], floatBuffer, byteBuffer, JOINT_STRIDE * i, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the frame to the given buffer starting at the given byte offset. Joints take JOINT_STRIDE\r\n// bytes while links take LINK_STRIDE bytes.\r\nexport function copyFrameToBuffer(\r\n\tframe,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tconst {\r\n\t\t\tposition,\r\n\t\t\tquaternion,\r\n\t\t} = frame;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 0 + i ] = position[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 3 + i ] = quaternion[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t\ttargetSet,\r\n\t\t\t\trestPoseSet,\r\n\t\t\t} = frame;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 0 * 6 + i ] = dofTarget[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 1 * 6 + i ] = dofRestPose[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 2 * 6 + i ] = minDoFLimit[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 3 * 6 + i ] = maxDoFLimit[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteBuffer[ byteOffset + 148 ] = Number( targetSet );\r\n\t\t\tbyteBuffer[ byteOffset + 149 ] = Number( restPoseSet );\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && frame.isJoint ) {\r\n\r\n\t\tconst { dofValues } = frame;\r\n\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 7 + 4 * 6 + i ] = dofValues[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the given buffer to the given frame starting at the given byte offset.\r\nexport function copyBufferToFrame(\r\n\tjoint,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tjoint.setPosition(\r\n\t\t\tfloatBuffer[ floatOffset + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 2 ],\r\n\t\t);\r\n\t\tjoint.setQuaternion(\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 2 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 3 ],\r\n\t\t);\r\n\r\n\t\tif ( joint.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t} = joint;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tdofTarget[ i ] = floatBuffer[ floatOffset + 7 + 0 * 6 + i ];\r\n\t\t\t\tdofRestPose[ i ] = floatBuffer[ floatOffset + 7 + 1 * 6 + i ];\r\n\t\t\t\tminDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 2 * 6 + i ];\r\n\t\t\t\tmaxDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 3 * 6 + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tjoint.targetSet = Boolean( byteBuffer[ byteOffset + 148 ] );\r\n\t\t\tjoint.restPoseSet = Boolean( byteBuffer[ byteOffset + 149 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && joint.isJoint ) {\r\n\r\n\t\tconst { dofValues } = joint;\r\n\t\tlet changed = false;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tconst v = floatBuffer[ floatOffset + 7 + 4 * 6 + i ];\r\n\t\t\tif ( v !== dofValues[ i ] ) {\r\n\r\n\t\t\t\tdofValues[ i ] = v;\r\n\t\t\t\tchanged = true;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t\t// only update dof matrix if it changed\r\n\t\tif ( changed ) {\r\n\r\n\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { Solver } from '../core/Solver.js';\r\nimport { SOLVE_STATUS } from '../core/ChainSolver.js';\r\nimport { deserialize } from './serialize.js';\r\nimport { applyToBuffer, applyFromBuffer } from './utils.js';\r\n\r\nlet solver = new Solver();\r\nlet solveHandle = - 1;\r\n\r\n// List of all frames in the graph\r\nlet frames = null;\r\n\r\n// Buffer variants\r\nlet buffer = null;\r\nlet floatBuffer = null;\r\nlet byteBuffer = null;\r\n\r\nglobal.onmessage = function ( { data: e } ) {\r\n\r\n\tconst { type, data } = e;\r\n\tswitch ( type ) {\r\n\r\n\t\t// The ik graph needs to be updated with all the deserialized\r\n\t\tcase 'updateStructure':\r\n\t\t\tframes = deserialize( data.serialized );\r\n\t\t\tsolver.roots = frames.filter( f => f.parent === null );\r\n\t\t\tsolver.updateStructure();\r\n\r\n\t\t\tbuffer = data.buffer;\r\n\t\t\tbyteBuffer = new Uint8Array( buffer );\r\n\t\t\tfloatBuffer = new Float32Array( buffer );\r\n\t\t\tbreak;\r\n\r\n\t\t// Update the settings of the solver\r\n\t\tcase 'updateSolverSettings':\r\n\t\t\tObject.assign( solver, data );\r\n\t\t\tbreak;\r\n\r\n\t\t// Start the solve loop\r\n\t\tcase 'startSolve':\r\n\t\t\tif ( solveHandle === - 1 ) {\r\n\r\n\t\t\t\tupdateSolve();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t// Stop the solve loop\r\n\t\tcase 'endSolve':\r\n\t\t\tif ( solveHandle !== - 1 ) {\r\n\r\n\t\t\t\tclearTimeout( solveHandle );\r\n\t\t\t\tsolveHandle = - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// The iterative solve loop\r\nfunction updateSolve() {\r\n\r\n\t// Copy any frame updates from the main thread\r\n\tapplyFromBuffer( frames, floatBuffer, byteBuffer, false, true );\r\n\r\n\t// Solve 1 iteration taking the most severe chain result\r\n\tconst result = solver.solve();\r\n\r\n\t// Copy the new DoF back to the shared buffer\r\n\tapplyToBuffer( frames, floatBuffer, byteBuffer, true, false );\r\n\r\n\tif ( result === SOLVE_STATUS.TIMEOUT ) {\r\n\r\n\t\t// yield so we can react to messages\r\n\t\tsolveHandle = setTimeout( updateSolve );\r\n\r\n\t} else {\r\n\r\n\t\tsolveHandle = - 1;\r\n\r\n\t}\r\n\r\n\tthis.postMessage( {\r\n\r\n\t\ttype: 'updateSolve',\r\n\t\tdata: result,\r\n\r\n\t} );\r\n\r\n}\r\n"]}