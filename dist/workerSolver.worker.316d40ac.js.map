{"version":3,"sources":["../node_modules/linear-solve/gauss-jordan.js","../src/core/utils/matrix.js","../src/core/MatrixPool.js","../src/core/utils/solver.js","../src/core/ChainSolver.js","../src/core/Solver.js","../src/core/Goal.js","../src/worker/serialize.js","../src/worker/utils.js","../src/worker/workerSolver.worker.js"],"names":["transpose","outMatrix","a","tr","length","tc","r","c","identity","scale","matrix","scalar","multiply","b","Error","m","n","k","sum","i","ti","create","row","col","result","Array","Float64Array","copy","sourceMatrix","clone","rows","resultMatrix","solve","vector","res","linearSolve","l","invert","add","subtract","magnitudeSquared","cols","magnitude","Math","sqrt","toString","dec","str","toFixed","log","console","mat","FixedMatrixPool","matrices","index","get","releaseAll","MatrixPool","pools","poolArray","colPools","pool","push","tempPos","tempQuat","accumulateClosureError","solver","joint","startIndex","errorVector","isConverged","rowCount","totalError","translationConvergeThreshold","rotationConvergeThreshold","translationErrorClamp","rotationErrorClamp","translationFactor","rotationFactor","translationDoFCount","rotationDoFCount","dofFlags","dof","getClosureError","isGoal","posMag","vec3","rotMag","vec4","d","accumulateTargetError","lockedJointDoFCount","lockedJointDoF","dofTarget","dofValues","posDelta","distance","rotDelta","DOF","EX","EY","EZ","lockedDoFCount","errorResult","lockedDoF","isLocked","rowIndex","dofList","tempEuler","eulerMag","matrixPool","targetRelativeToJointMatrix","targetDeltaWorldMatrix","tempDeltaWorldMatrix","tempInverseMatrixWorld","tempQuat2","tempPos2","targetJoints","freeJoints","errorResultInfo","dofResultInfo","errorRows","freeDoF","SOLVE_STATUS","CONVERGED","STALLED","DIVERGED","TIMEOUT","SOLVE_STATUS_NAMES","Object","entries","sort","map","el","ChainSolver","chain","from","targets","affectedClosures","affectedConnectedClosures","prevDoFValues","maxIterations","translationStep","rotationStep","stallThreshold","dampingFactor","divergeThreshold","restPoseFactor","init","filter","j","targetSet","isClosure","Map","forEach","set","Set","Uint8Array","target","currJoint","isJoint","parent","child","iterations","prevErrorMagnitude","Infinity","status","clear","restPoseSet","tryMinimizeEulerAngles","updateMatrixWorld","countUnconvergedVariables","setMatrixDoFNeedsUpdate","fillErrorVector","jacobian","fillJacobian","jacobianIdentityDamping","jacobianTranspose","jjt","jjti","jjtii","pseudoInverse","deltaTheta","restPose","restPoseResult","colIndex","colCount","dofRestPose","jij","jiji","stalled","delta","abs","applyJointAngles","lockedJoint","dti","has","value","getDoFValue","hitLimit","setDoFValue","fill","lockedCount","outJacobian","freeJoint","relevantClosures","relevantConnectedClosures","matrixWorld","co","getDeltaWorldMatrix","targetJoint","totalRows","unconvergedRows","addToTargetList","Solver","roots","isArray","solvers","updateStructure","chains","traversal","allChainJoints","traverseChains","frame","curr","chainSet","children","delete","independentChains","currChain","pop","otherChain","dependent","splice","nonChainJoints","root","traverse","results","s","Joint","Goal","args","setFreeDoF","rotCount","Number","includes","setDoF","X","Y","Z","serialize","frames","info","name","minDoFLimit","maxDoFLimit","position","quaternion","type","slice","inf","deserialize","data","Link","setMatrixNeedsUpdate","JOINT_STRIDE","LINK_STRIDE","generateSharedBuffer","arrayBuffer","SharedArrayBuffer","applyToBuffer","Float32Array","floatBuffer","byteBuffer","copyDoFValues","copyJointSettings","copyFrameToBuffer","applyFromBuffer","copyBufferToFrame","byteOffset","floatOffset","setPosition","setQuaternion","Boolean","changed","v","solveHandle","buffer","updateSolve","setTimeout","postMessage","global","onmessage","e","serialized","f","assign","clearTimeout"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAIA,IAAA,EAAA,WAQA,SAAA,EAAA,EAAA,GAEA,KAAA,KAAA,IAAA,MAAA,EAAA,QACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,OAAA,IAAA,CACA,KAAA,KAAA,GAAA,IAAA,MAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,KAAA,KAAA,GAAA,GAAA,EAAA,GAAA,GAIA,GAAA,EAAA,CACA,GAAA,iBAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,GAAA,CAAA,EAAA,IAGA,KAAA,OAAA,IAAA,EAAA,IA0HA,OAnHA,EAAA,UAAA,KAAA,SAAA,EAAA,GACA,KAAA,QAAA,KAAA,OAAA,KAAA,EAAA,GACA,IAAA,EAAA,KAAA,KAAA,GACA,KAAA,KAAA,GAAA,KAAA,KAAA,GACA,KAAA,KAAA,GAAA,GAMA,EAAA,UAAA,SAAA,SAAA,EAAA,GACA,KAAA,QAAA,KAAA,OAAA,SAAA,EAAA,GAEA,IADA,IAAA,EAAA,KAAA,KAAA,GACA,EAAA,EAAA,OAAA,EAAA,GAAA,EAAA,IACA,EAAA,IAAA,GAOA,EAAA,UAAA,OAAA,SAAA,EAAA,EAAA,GACA,KAAA,QAAA,KAAA,OAAA,OAAA,EAAA,EAAA,GAEA,IADA,IAAA,EAAA,KAAA,KAAA,GAAA,EAAA,KAAA,KAAA,GACA,EAAA,EAAA,OAAA,EAAA,GAAA,EAAA,IACA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,IAOA,EAAA,UAAA,YAAA,SAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,KAAA,KAAA,GAAA,OAAA,IACA,GAAA,IAAA,KAAA,KAAA,GAAA,GACA,OAAA,EAGA,OAAA,GAGA,EAAA,UAAA,MAAA,WAMA,IALA,IAAA,EAAA,EACA,EAAA,KAAA,KAAA,OACA,EAAA,KAAA,KAAA,GAAA,OACA,EAAA,GAEA,EAAA,EAAA,EAAA,EAAA,IAAA,CAGA,IADA,IAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,IAAA,EAAA,KAAA,KAAA,GAAA,GACA,KAAA,IAAA,GAAA,KAAA,IAAA,KACA,EAAA,EACA,EAAA,GAGA,GAAA,IAAA,EAEA,EAAA,KAAA,OACA,CAEA,KAAA,SAAA,EAAA,EAAA,GACA,KAAA,KAAA,EAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,IAAA,GACA,KAAA,OAAA,EAAA,GAAA,KAAA,KAAA,GAAA,IAIA,IAIA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,IAAA,KAAA,OAAA,YAAA,EAAA,IACA,MAAA,IAAA,MAAA,mBAGA,OAAA,KAAA,OAAA,MASA,QAAA,MAAA,SAAA,EAAA,GACA,IAAA,EAAA,IAAA,EAAA,EAAA,GAAA,QACA,GAAA,EAAA,OAAA,GAAA,IAAA,EAAA,GAAA,OAEA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,EAAA,GAAA,EAAA,GAAA,GAEA,OAAA,GAiBA,QAAA,OAAA,SAAA,GACA,OAAA,IAAA,EAAA,EAfA,SAAA,GAEA,IADA,IAAA,EAAA,IAAA,MAAA,GACA,EAAA,EAAA,EAAA,EAAA,IAAA,CACA,EAAA,GAAA,IAAA,MAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,GAAA,IAAA,EAAA,EAAA,EAGA,OAAA,EAOA,CAAA,EAAA,SAAA,SAGA,QAlJA,GAqJA,iBAAA,OAAA,UAAA,OAAA,QAAA;;ACuFO,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA,EAhPP,IAAA,EAAA,EAAA,QAAA,iBAgPO,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GA9OP,SAASA,EAAWC,EAAWC,GAKxB,IAHAC,IAAAA,EAAKD,EAAEE,OACPC,EAAKH,EAAG,GAAIE,OAERE,EAAI,EAAGA,EAAIH,EAAIG,IAElB,IAAA,IAAIC,EAAI,EAAGA,EAAIF,EAAIE,IAExBN,EAAWM,GAAKD,GAAMJ,EAAGI,GAAKC,GAQjC,SAASC,EAAUP,GAEZ,IAAA,IAAIK,EAAI,EAAGH,EAAKF,EAAUG,OAAQE,EAAIH,EAAIG,IAEzC,IAAA,IAAIC,EAAI,EAAGF,EAAKJ,EAAUG,OAAQG,EAAIF,EAAIE,IAE/CN,EAAWK,GAAKC,GAAMD,IAAMC,EAAI,EAAI,EAQvC,SAASE,EAAOR,EAAWS,EAAQC,GAE5B,IAAA,IAAIL,EAAI,EAAGH,EAAKF,EAAUG,OAAQE,EAAIH,EAAIG,IAEzC,IAAA,IAAIC,EAAI,EAAGF,EAAKJ,EAAUG,OAAQG,EAAIF,EAAIE,IAE/CN,EAAWK,GAAKC,GAAMG,EAAQJ,GAAKC,GAAMI,EAQ5C,SAASC,EAAUX,EAAWC,EAAGW,GAE3BX,GAAAA,IAAMW,EAEJ,MAAA,IAAIC,MAiBL,IALAC,IAAAA,EAAIb,EAAEE,OACNY,EAAIH,EAAET,OACNa,EAAIJ,EAAG,GAAIT,OAGPE,EAAI,EAAGH,EAAKY,EAAGT,EAAIH,EAAIG,IAG1B,IAAA,IAAIC,EAAI,EAAGF,EAAKY,EAAGV,EAAIF,EAAIE,IAAO,CAKjC,IAHFW,IAAAA,EAAM,EAGAC,EAAI,EAAGC,EAAKJ,EAAGG,EAAIC,EAAID,IAEhCD,GAAOhB,EAAGI,GAAKa,GAAMN,EAAGM,GAAKZ,GAI9BN,EAAWK,GAAKC,GAAMW,GAQzB,SAASG,EAAQC,EAAKC,GAGf,IADAC,IAAAA,EAAS,IAAIC,MAAOH,GAChBH,EAAI,EAAGA,EAAIG,EAAKH,IAEzBK,EAAQL,GAAM,IAAIO,aAAcH,GAI1BC,OAAAA,EAIR,SAASG,EAAM1B,EAAW2B,GAInB,IAFAzB,IAAAA,EAAKyB,EAAaxB,OAClBC,EAAKuB,EAAc,GAAIxB,OACnBE,EAAI,EAAGA,EAAIH,EAAIG,IAElB,IAAA,IAAIC,EAAI,EAAGA,EAAIF,EAAIE,IAExBN,EAAWK,GAAKC,GAAMqB,EAActB,GAAKC,GAQ5C,SAASsB,EAAOnB,GAEToB,IAEAC,EAAeV,EAFRX,EAAON,OACPM,EAAQ,GAAIN,QAGlB2B,OADPJ,EAAMI,EAAcrB,GACbqB,EAIR,SAASC,EAAO/B,EAAWS,EAAQuB,GAG5B,IADAC,IAAAA,EAAMC,EAAYH,QAAAA,MAAOtB,EAAQuB,GAC7Bd,EAAI,EAAGiB,EAAIF,EAAI9B,OAAQe,EAAIiB,EAAGjB,IAEvClB,EAAWkB,GAAK,GAAMe,EAAKf,GAM7B,SAASkB,EAAQpC,EAAWS,GAMrB,IAJAwB,IAAAA,EAAMC,EAAYE,QAAAA,OAAQ3B,GAE1BP,EAAKO,EAAQ,GAAIN,OACjBC,EAAKK,EAAON,OACRE,EAAI,EAAGA,EAAIH,EAAIG,IAElB,IAAA,IAAIC,EAAI,EAAGA,EAAIF,EAAIE,IAExBN,EAAWK,GAAKC,GAAM2B,EAAK5B,GAAKC,GAQnC,SAAS+B,EAAKrC,EAAWC,EAAGW,GAIrB,IAFAV,IAAAA,EAAKD,EAAEE,OACPC,EAAKH,EAAG,GAAIE,OACRE,EAAI,EAAGA,EAAIH,EAAIG,IAElB,IAAA,IAAIC,EAAI,EAAGA,EAAIF,EAAIE,IAExBN,EAAWK,GAAKC,GAAML,EAAGI,GAAKC,GAAMM,EAAGP,GAAKC,GAQ/C,SAASgC,EAAUtC,EAAWC,EAAGW,GAI1B,IAFAV,IAAAA,EAAKD,EAAEE,OACPC,EAAKH,EAAG,GAAIE,OACRE,EAAI,EAAGA,EAAIH,EAAIG,IAElB,IAAA,IAAIC,EAAI,EAAGA,EAAIF,EAAIE,IAExBN,EAAWK,GAAKC,GAAML,EAAGI,GAAKC,GAAMM,EAAGP,GAAKC,GAQ/C,SAASiC,EAAkB9B,GAKpB,IAHFQ,IAAAA,EAAM,EACJY,EAAOpB,EAAON,OACdqC,EAAO/B,EAAQ,GAAIN,OACfE,EAAI,EAAGA,EAAIwB,EAAMxB,IAEpB,IAAA,IAAIC,EAAI,EAAGA,EAAIkC,EAAMlC,IAE1BW,GAAOR,KAAAA,IAAAA,EAAQJ,GAAKC,GAAO,GAMtBW,OAAAA,EAIR,SAASwB,EAAWhC,GAEZiC,OAAAA,KAAKC,KAAMJ,EAAkB9B,IAIrC,SAASmC,EAAUnC,GAKZ,IALoBoC,IAAAA,EAAM,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,EAE1BhB,EAAOpB,EAAON,OACdqC,EAAO/B,EAAQ,GAAIN,OACrB2C,EAAM,GACAzC,EAAI,EAAGA,EAAIwB,EAAMxB,IAAO,CAE3B,IAAA,IAAIC,EAAI,EAAGA,EAAIkC,EAAMlC,IAE1BwC,GAAOrC,EAAQJ,GAAKC,GAAIyC,QAASF,GAAQ,KAG1CC,GAAO,KAGDA,OAAAA,EAIR,SAASE,EAAKvC,EAAQoC,GAErBI,QAAQD,IAAKJ,EAAUnC,EAAQoC,IAIzB,IAAMK,EAAM,CAClBnD,UAAAA,EACAQ,SAAAA,EACAC,MAAAA,EACAG,SAAAA,EACAS,OAAAA,EACAM,KAAAA,EACAE,MAAAA,EACAG,MAAAA,EACAK,OAAAA,EACAC,IAAAA,EACAC,SAAAA,EACAC,iBAAAA,EACAE,UAAAA,EACAG,SAAAA,EACAI,IAAAA,GAfM,QAAA,IAAA;;AC3KL,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,gBAAA,EArEF,IAAA,EAAA,QAAA,qBAqEE,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAnEIG,IAAAA,EAEL,SAAa9B,EAAAA,EAAKC,GAAM,EAAA,KAAA,GAEjB8B,IAAAA,EAAW,GACbC,EAAQ,EAEPC,KAAAA,IAAM,WAEN7C,IAAAA,EAAS2C,EAAUC,GAOhB5C,OANAA,IAEN2C,EAAUC,GAAU5C,EAASyC,EAAI9B,IAAAA,OAAQC,EAAKC,IAG/C+B,IACO5C,GAIH8C,KAAAA,WAAa,WAEjBF,EAAQ,IAQEG,EAEZ,SAAc,IAAA,EAAA,KAAA,GAEPC,IAAAA,EAAQ,GACRC,EAAY,GACbJ,KAAAA,IAAM,SAAUjC,EAAKC,GAErBqC,IAAAA,EAAWF,EAAOpC,GACfsC,IAENA,EAAWF,EAAOpC,GAAQ,IAIvBuC,IAAAA,EAAOD,EAAUrC,GAQdsC,OAPAA,IAENA,EAAOD,EAAUrC,GAAQ,IAAI6B,EAAiB9B,EAAKC,GACnDoC,EAAUG,KAAMD,IAIVA,EAAKN,OAIRC,KAAAA,WAAa,WAEX,IAAA,IAAIrC,EAAI,EAAGiB,EAAIuB,EAAUvD,OAAQe,EAAIiB,EAAGjB,IAE7CwC,EAAWxC,GAAIqC,eAMjB,QAAA,WAAA;;AC+JD,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,uBAAA,EAAA,QAAA,sBAAA,EApOD,IAAA,EAAA,QAAA,aAoOC,SAAA,EAAA,GAAA,MAAA,IAAA,MAAA,IAAA,EAAA,kBAlOD,IAAMO,EAAU,IAAIrC,aAAc,GAC5BsC,EAAW,IAAItC,aAAc,GAE5B,SAASuC,EACfC,EACAC,EACAC,GACAC,IAAAA,EAAc,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,KACd7C,EAAS,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,CAAE8C,aAAa,EAAOC,SAAU,EAAGC,WAAY,GAIvDC,EAMGP,EANHO,6BACAC,EAKGR,EALHQ,0BACAC,EAIGT,EAJHS,sBACAC,EAGGV,EAHHU,mBACAC,EAEGX,EAFHW,kBACAC,EACGZ,EADHY,eAIAC,EAIGZ,EAJHY,oBACAC,EAGGb,EAHHa,iBACAC,EAEGd,EAFHc,SACAC,EACGf,EADHe,IAIDf,EAAMgB,gBAAiBpB,EAASC,GAE5BO,IAAAA,EAAW,EACVJ,EAAMiB,SAEVrB,EAAS,IAAOkB,EAAU,GAC1BlB,EAAS,IAAOkB,EAAU,GAC1BlB,EAAS,IAAOkB,EAAU,GAC1BV,EAAWQ,EAEe,IAArBC,GAEJhB,EAAU,GAAM,EAChBA,EAAU,GAAM,EAChBA,EAAU,GAAM,EAChBA,EAAU,GAAM,GAIhBO,GAAY,GAMVD,IAAAA,GAAc,EACdE,EAAa,EACXa,EAASC,EAAKlF,KAAAA,OAAQ2D,GACtBwB,EAASC,EAAKpF,KAAAA,OAAQ4D,GAYvBK,GAVJgB,EAASZ,GACTc,EAASb,IAGTJ,GAAc,GAIfE,GAAca,EAASE,EAElBlB,EAgBCF,GAdAkB,EAASV,GAERlE,EAAAA,KAAAA,MAAOsD,EAASA,EAASY,EAAwBU,GAGlD5E,EAAAA,KAAAA,MAAOsD,EAASA,EAASc,GAEzBU,EAASX,GAERnE,EAAAA,KAAAA,MAAOuD,EAAUA,EAAUY,EAAqBW,GAGjD9E,EAAAA,KAAAA,MAAOuD,EAAUA,EAAUc,GAE3BX,EAAMiB,OAAS,CAEb,IAAA,IAAIjE,EAAI,EAAGA,EAAI4D,EAAqB5D,IAAO,CAE1CsE,IAAAA,EAAIP,EAAK/D,GACfkD,EAAaD,EAAajD,GAAK,GAAM4C,EAAS0B,GAIf,IAA3BtB,EAAMa,mBAEVX,EAAaD,EAAaW,EAAsB,GAAK,GAAMf,EAAU,GACrEK,EAAaD,EAAaW,EAAsB,GAAK,GAAMf,EAAU,GACrEK,EAAaD,EAAaW,EAAsB,GAAK,GAAMf,EAAU,GACrEK,EAAaD,EAAaW,EAAsB,GAAK,GAAMf,EAAU,SAMtEK,EAAaD,EAAa,GAAK,GAAML,EAAS,GAC9CM,EAAaD,EAAa,GAAK,GAAML,EAAS,GAC9CM,EAAaD,EAAa,GAAK,GAAML,EAAS,GAE9CM,EAAaD,EAAa,GAAK,GAAMJ,EAAU,GAC/CK,EAAaD,EAAa,GAAK,GAAMJ,EAAU,GAC/CK,EAAaD,EAAa,GAAK,GAAMJ,EAAU,GAC/CK,EAAaD,EAAa,GAAK,GAAMJ,EAAU,GAS1CxC,OAHPA,EAAOgD,WAAaA,EACpBhD,EAAO8C,YAAcA,EACrB9C,EAAO+C,SAAWA,EACX/C,EAID,SAASkE,EACfxB,EACAC,EACAC,GACAC,IAAAA,EAAc,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,KACd7C,EAAS,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,CAAE8C,aAAa,EAAOC,SAAU,EAAGC,WAAY,GAKvDC,EAMGP,EANHO,6BACAC,EAKGR,EALHQ,0BACAiB,EAIGzB,EAJHyB,oBACAhB,EAGGT,EAHHS,sBACAC,EAEGV,EAFHU,mBACAgB,EACG1B,EADH0B,eAIAC,EAMG1B,EANH0B,UACAC,EAKG3B,EALH2B,UACAf,EAIGZ,EAJHY,oBACAC,EAGGb,EAHHa,iBACAH,EAEGV,EAFHU,kBACAC,EACGX,EADHW,eAIKiB,EAAWT,EAAKU,KAAAA,SAAUF,EAAWD,GAMvCI,EACHJ,EAAWK,IAAIC,IAAOL,EAAWI,IAAIC,IACrCN,EAAWK,IAAIE,IAAON,EAAWI,IAAIE,IACrCP,EAAWK,IAAIG,IAAOP,EAAWI,IAAIG,IAGhCC,EAAiBX,EAAoBpC,IAAKY,IAAW,EAKtDE,GAJL7C,EAAO+C,SAAWQ,EAAsBC,EAAmBsB,EAC3D9E,EAAO8C,YAAcyB,EAAWtB,GAAgCwB,EAAWvB,EAC3E6B,YAAY/B,WAAauB,EAAWE,EAE/B5B,EAAc,CAEZmC,IAAAA,EAAYZ,EAAerC,IAAKY,GAChCsC,EAA8B,IAAnBH,EACXI,EAAW,EAGjB3C,EAAS,GAAM8B,EAAW,GAAMC,EAAW,GAC3C/B,EAAS,GAAM8B,EAAW,GAAMC,EAAW,GAC3C/B,EAAS,GAAM8B,EAAW,GAAMC,EAAW,GAGrCT,IAAAA,EAASC,EAAKlF,KAAAA,OAAQ2D,GACvBtD,EAAAA,KAAAA,MAAOsD,EAASA,EAASc,EAAoBF,EAAwBU,GACpE,IAAA,IAAIlE,EAAI,EAAGiB,EAAI2C,EAAqB5D,EAAIiB,EAAGjB,IAAO,CAEjD+D,IAAAA,EAAMyB,QAASxF,GAGhBsF,GAAYD,EAAWtB,KAM5Bb,EAAaD,EAAasC,GAAY,GAAM3C,EAASmB,GACrDwB,EAAAA,YAAAA,KAMDE,UAAW,GAAMzC,EAAM0B,UAAW,GAAM1B,EAAM2B,UAAW,GACzDc,UAAW,GAAMzC,EAAM0B,UAAW,GAAM1B,EAAM2B,UAAW,GACzDc,UAAW,GAAMzC,EAAM0B,UAAW,GAAM1B,EAAM2B,UAAW,GAGnDe,IAAAA,EAAWvB,EAAKlF,KAAAA,OAAQwG,WACzBnG,EAAAA,KAAAA,MAAOmG,UAAWA,UAAW9B,EAAiBF,EAAqBiC,GAClE,IAAA,IAAI1F,EAAI4D,EAAqB3C,EAAI2C,EAAsBC,EAAkB7D,EAAIiB,EAAGjB,IAAO,CAEtF+D,IAAAA,EAAMyB,QAASxF,GAGhBsF,GAAYD,EAAWtB,KAM5Bb,EAAaD,EAAasC,GAAY,GAAME,UAAW1B,GACvDwB,EAAAA,YAAAA;;;;;;;;ACukBD,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,QAAA,mBAAA,QAAA,kBAAA,EAryBF,IAAA,EAAA,QAAA,aACA,EAAA,QAAA,mBACA,EAAA,QAAA,qBACA,EAAA,QAAA,qBACA,EAAA,QAAA,uBAiyBE,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EA9xBF,IAAMI,EAAa,IAAIrD,EAAJ,WAGbsD,EAA8B,IAAIrF,aAAc,IAChDsF,EAAyB,IAAItF,aAAc,IAC3CuF,EAAuB,IAAIvF,aAAc,IACzCwF,EAAyB,IAAIxF,aAAc,IAC3CsC,EAAW,IAAItC,aAAc,GAC7BqC,EAAU,IAAIrC,aAAc,GAC5ByF,EAAY,IAAIzF,aAAc,GAC9B0F,EAAW,IAAI1F,aAAc,GAE7B2F,EAAe,GACfC,EAAa,GACbC,EAAkB,CACvBhD,SAAU,EACVD,aAAa,EACbE,WAAY,GAEPgD,EAAgB,CACrBC,UAAW,EACXC,QAAS,EACTlD,WAAY,GAGAmD,EAAe,CAE3BC,UAAW,EACXC,QAAS,EACTC,SAAU,EACVC,QAAS,GAgwBR,QAAA,aAAA,EA5vBK,IAAMC,EAAqBC,OAAOC,QAASP,GAAeQ,KAAM,SAAEjI,EAAGW,GAAOX,OAAAA,EAAG,GAAMW,EAAG,KAAMuH,IAAK,SAAAC,GAAMA,OAAAA,EAAI,KA4vBlH,QAAA,mBAAA,EA1vBWC,IAAAA,EAAAA,WAECC,SAAAA,EAAAA,GAAQ,EAAA,KAAA,GAEfA,KAAAA,MAAQ9G,MAAM+G,KAAMD,GAGpBE,KAAAA,QAAU,KAGVC,KAAAA,iBAAmB,KAGnBC,KAAAA,0BAA4B,KAK5BhD,KAAAA,oBAAsB,KAGtBC,KAAAA,eAAiB,KAIjBgD,KAAAA,cAAgB,KAGhBC,KAAAA,eAAkB,EAElBpE,KAAAA,8BAAiC,EACjCC,KAAAA,2BAA8B,EAE9BG,KAAAA,mBAAsB,EACtBC,KAAAA,gBAAmB,EAEnBgE,KAAAA,iBAAoB,EACpBC,KAAAA,cAAiB,EAEjBpE,KAAAA,uBAA0B,EAC1BC,KAAAA,oBAAuB,EAEvBoE,KAAAA,gBAAmB,EACnBC,KAAAA,eAAkB,EAClBC,KAAAA,kBAAqB,EACrBC,KAAAA,gBAAmB,EAEnBC,KAAAA,OA2sBL,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,OAvsBM,MAAA,WAGAb,IAAAA,EAAQ,KAAKA,MACbE,EAAUF,EAAMc,OAAQ,SAAAC,GAAKA,OAAAA,EAAEC,WAAaD,EAAEE,YAE9C5D,EAAiB,IAAI6D,IACrB9D,EAAsB,IAAI8D,IAC1Bb,EAAgB,IAAIa,IAEpBf,EAAmB,IAAIe,IACvBd,EAA4B,IAAIc,IACtClB,EAAMmB,QAAS,SAAAJ,GAIdZ,EAAiBiB,IAAKL,EAAG,IAAIM,KAC7BjB,EAA0BgB,IAAKL,EAAG,IAAIM,KAGtChE,EAAe+D,IAAKL,EAAG,IAAIO,WAAY,IACvCjB,EAAce,IAAKL,EAAG,IAAI5H,aAAc,MAIzC+G,EAAQiB,QAAS,SAAAI,GAEXA,GAAAA,EAAON,UAAY,CAKfO,IAHJA,IAAAA,EAAYD,EAGRC,GAEFA,EAAUC,SAEdtB,EAAiBnF,IAAKwG,GAAYzH,IAAKwH,GAIxCC,EAAYA,EAAUE,OAMfF,IADRA,EAAYD,EAAOI,MACXH,GAEFA,EAAUC,SAEdrB,EAA0BpF,IAAKwG,GAAYzH,IAAKwH,GAIjDC,EAAYA,EAAUE,UAQpBxB,KAAAA,QAAUA,EACVC,KAAAA,iBAAmBA,EACnBC,KAAAA,0BAA4BA,EAC5B/C,KAAAA,eAAiBA,EACjBD,KAAAA,oBAAsBA,EACtBiD,KAAAA,cAAgBA,IAooBrB,CAAA,IAAA,QAhoBO,MAAA,WAGNM,IAAAA,EAMG,KANHA,iBACAF,EAKG,KALHA,eACAT,EAIG,KAJHA,MACAY,EAGG,KAHHA,eACAxD,EAEG,KAFHA,oBACAiD,EACG,KADHA,cAGGuB,EAAa,EACbC,EAAqBC,EAAAA,EACrBC,GAAW,EAGf3E,EAAoB4E,QAId,IAAA,IAAIpJ,EAAI,EAAGiB,EAAImG,EAAMnI,OAAQe,EAAIiB,EAAGjB,IAAO,CAE1CgD,IAAAA,EAAQoE,EAAOpH,IAChBgD,EAAMoF,WAAapF,EAAMqG,cAE7BrG,EAAMsG,yBAML,OAAA,CAEF3D,EAAWtD,aAGL,IAAA,IAAIrC,EAAI,EAAGiB,EAAImG,EAAMnI,OAAQe,EAAIiB,EAAGjB,IAAO,CAElCoH,EAAOpH,GACfuJ,oBAMPrD,EAAajH,OAAS,EACtBkH,EAAWlH,OAAS,EACfuK,KAAAA,0BAA2BrD,EAAYD,EAAcG,GAClDE,IAAAA,EAAmCF,EAAnCE,QAASD,EAA0BD,EAA1BC,UAAWjD,EAAegD,EAAfhD,WAGvBiD,GAAc,IAAdA,EAAkB,CAEtB6C,EAAS3C,EAAaC,UACtB,MAKIpD,GAAAA,EAAa4F,EAAqBlB,EAAmB,CAEzDN,EAAcc,QAAS,SAAE5D,EAAW3B,GAEnCA,EAAM2B,UAAU6D,IAAK7D,GACrB3B,EAAMyG,4BAKPN,EAAS3C,EAAaG,SACtB,MAOIqC,GAJLC,EAAqB5F,IAGrB2F,EACkB,KAAKtB,cAAgB,CAEtCyB,EAAS3C,EAAaI,QACtB,MAQK1D,IAAAA,EAAcyC,EAAWvD,IAAKkE,EAAW,GAC1CoD,KAAAA,gBAAiBxD,EAAchD,GAE9ByG,IAAAA,EAAWhE,EAAWvD,IAAKkE,EAAWC,GACvCqD,KAAAA,aAAc1D,EAAcC,EAAYwD,GAYvCE,IAAAA,EAA0BlE,EAAWvD,IAAKkE,EAAWA,GACvDjH,EAAAA,IAAAA,SAAUwK,GACVvK,EAAAA,IAAAA,MAAOuK,EAAyBA,EAAyB,KAAA,IAAA,KAAK/B,cAAiB,IAG7EgC,IAAAA,EAAoBnE,EAAWvD,IAAKmE,EAASD,GAC/CzH,EAAAA,IAAAA,UAAWiL,EAAmBH,GAG5BI,IAAAA,EAAMpE,EAAWvD,IAAKkE,EAAWA,GACnC7G,EAAAA,IAAAA,SAAUsK,EAAKJ,EAAUG,GAGvBE,IAAAA,EAAOrE,EAAWvD,IAAKkE,EAAWA,GACpCnF,EAAAA,IAAAA,IAAK6I,EAAMD,EAAKF,GAGdI,IAAAA,EAAQtE,EAAWvD,IAAKkE,EAAWA,GACrCpF,EAAAA,IAAAA,OAAQ+I,EAAOD,GAGbE,IAAAA,EAAgBvE,EAAWvD,IAAKmE,EAASD,GAC3C7G,EAAAA,IAAAA,SAAUyK,EAAeJ,EAAmBG,GAG1CE,IAAAA,EAAaxE,EAAWvD,IAAKmE,EAAS,GAOvCyB,GANDvI,EAAAA,IAAAA,SAAU0K,EAAYD,EAAehH,GAMjB,IAAnB8E,EAAuB,CASrB,IAHAoC,IAAAA,EAAWzE,EAAWvD,IAAKmE,EAAS,GACpC8D,EAAiB1E,EAAWvD,IAAKmE,EAAS,GAC5C+D,EAAW,EACLtK,EAAI,EAAGiB,EAAIkF,EAAWlH,OAAQe,EAAIiB,EAAGjB,IAAO,CAE/CgD,IAAAA,EAAQmD,EAAYnG,GACpBmF,EAAiB,KAAKX,oBAAoBpC,IAAKY,IAAW,EAC1DsC,EAA8B,IAAnBH,EACXE,EAAY,KAAKZ,eAAerC,IAAKY,GAErCuH,EAAWvH,EAAMa,iBAAmBb,EAAMY,oBAAsBuB,EACjEnC,GAAAA,EAAMqG,YAKJ,IAHA7D,IAAAA,EAAUxC,EAAMe,IAChBY,EAAY3B,EAAM2B,UAClB6F,EAAcxH,EAAMwH,YAChBlG,EAAI,EAAGA,EAAIiG,EAAUjG,IAAO,CAI/BP,IAAAA,EAAMyB,EAASlB,GAEhBgB,GAAYD,EAAWtB,KAE5BqG,EAAUE,GAAY,GAAM3F,EAAWZ,GAAQyG,EAAazG,GAC5DuG,UAMK,IAAA,IAAIhG,EAAI,EAAGA,EAAIiG,EAAUjG,IAE9B8F,EAAUE,GAAY,GAAM,EAC5BA,IASGG,IAAAA,EAAM9E,EAAWvD,IAAKmE,EAASA,GACjC9G,EAAAA,IAAAA,SAAUgL,EAAKP,EAAeP,GAG5Be,IAAAA,EAAO/E,EAAWvD,IAAKmE,EAASA,GAClClH,EAAAA,IAAAA,SAAUqL,GACVtJ,EAAAA,IAAAA,SAAUsJ,EAAMA,EAAMD,GAGtBhL,EAAAA,IAAAA,SAAU4K,EAAgBK,EAAMN,GAE9B,IAAA,IAAIjL,EAAI,EAAGA,EAAIoH,EAASpH,IAE7BgL,EAAYhL,GAAK,IAAOiL,EAAUjL,GAAK,GAAM6I,EAO1CH,GAAAA,EAAiB,EAAI,CAGnB,IADF8C,IAAAA,GAAU,EACJ3K,EAAI,EAAGiB,EAAIkJ,EAAWlL,OAAQe,EAAIiB,EAAGjB,IAAO,CAE/C4K,IAAAA,GAAQT,EAAYnK,GAAK,GAC1BwB,GAAAA,KAAKqJ,IAAKD,IAAU/C,EAAiB,CAEzC8C,GAAU,EACV,OAMGA,GAAAA,EAAU,CAEdxB,EAAS3C,EAAaE,QACtB,OAOFe,EAAcc,QAAS,SAAE5D,EAAW3B,GAEnC2B,EAAU6D,IAAKxF,EAAM2B,aAMjBmG,KAAAA,iBAAkB3E,EAAYgE,GAO7BhB,OAFPjD,EAAajH,OAAS,EACtBkH,EAAWlH,OAAS,EACbkK,IA2YP,CAAA,IAAA,mBAtYiBhD,MAAAA,SAAAA,EAAYgE,GASvB,IANL1F,IAAAA,EAEG,KAFHA,eACAD,EACG,KADHA,oBAGGuG,GAAc,EACdC,EAAM,EACAhL,EAAI,EAAGiB,EAAIkF,EAAWlH,OAAQe,EAAIiB,EAAGjB,IAQxC,IALAgD,IAAAA,EAAQmD,EAAYnG,GACpBwF,EAAUxC,EAAMe,IAChBsB,EAAYZ,EAAerC,IAAKY,GAChCsC,EAAWd,EAAoByG,IAAKjI,GAEhCsB,EAAI,EAAGrD,EAAIuE,EAAQvG,OAAQqF,EAAIrD,EAAGqD,IAAO,CAE5CP,IAAAA,EAAMyB,EAASlB,GAChBgB,IAAAA,IAAYD,EAAWtB,GAAvBuB,CAOC4F,IAAAA,EAAQlI,EAAMmI,YAAapH,GAI5BqH,GAHYpI,EAAMqI,YAAatH,EAAKmH,EAAQf,EAAYa,GAAO,IAGpD,CAERxG,EAAoByG,IAAKjI,KAE/BwB,EAAoBgE,IAAKxF,EAAO,GAChCqC,EAAUiG,KAAM,IAGXC,IAAAA,EAAc/G,EAAoBpC,IAAKY,GAC7CwB,EAAoBgE,IAAKxF,EAAOuI,EAAc,GAC9ClG,EAAWtB,GAAQ,EACnBgH,GAAc,EAIfC,KAMGA,GAAAA,IAAQb,EAAWlL,OAEjB,MAAA,IAAIU,MAIJoL,OAAAA,IA4UP,CAAA,IAAA,eApUa7E,MAAAA,SAAAA,EAAcC,EAAYqF,GAgBjC,IAbL7D,IAAAA,EAMG,KANHA,gBACAC,EAKG,KALHA,aACAnD,EAIG,KAJHA,eACAD,EAGG,KAHHA,oBACAd,EAEG,KAFHA,kBACAC,EACG,KADHA,eAIK4D,EAAmB,KAAKA,iBACxBC,EAA4B,KAAKA,0BAEnC8C,EAAW,EACLlL,EAAI,EAAGF,EAAKiH,EAAWlH,OAAQG,EAAIF,EAAIE,IAAO,CAGjDqM,IAAAA,EAAYtF,EAAY/G,GACxBsM,EAAmBnE,EAAiBnF,IAAKqJ,GACzCE,EAA4BnE,EAA0BpF,IAAKqJ,GAC3DjG,EAAUiG,EAAU1H,IACpBwG,EAAWkB,EAAU7H,oBAAsB6H,EAAU5H,iBAErDyB,EAAWd,EAAoByG,IAAKQ,GACpCpG,EAAYZ,EAAerC,IAAKqJ,GAGjCvK,EAAAA,KAAAA,OAAQ6E,EAAwB0F,EAAUG,aAGzC,IAAA,IAAIC,EAAK,EAAGA,EAAKtB,EAAUsB,IAAQ,CAElC9H,IAAAA,EAAMyB,EAASqG,GAGhBvG,IAAAA,IAAYD,EAAWtB,GAAvBuB,CAMDC,IAAAA,EAAW,EAGXqF,EAAQ7G,EAAM,EAAI4D,EAAkBC,EACnC6D,EAAUK,oBAAqB/H,EAAK6G,EAAO9E,KAE/C8E,IAAW,GAKN,IAAA,IAAIzL,EAAI,EAAGH,EAAKkH,EAAajH,OAAQE,EAAIH,EAAIG,IAAO,CAEnD4M,IAAAA,EAAc7F,EAAc/G,GAG7B4M,GAAAA,EAAY1D,UAEXqD,GAAAA,EAAiBT,IAAKc,IAAiBJ,EAA0BV,IAAKc,GAsCrEA,GA/BLA,EAAY/H,gBAAiBpB,EAASC,GACjC8I,EAA0BV,IAAKc,IAI9BtM,EAAAA,KAAAA,SAAUmG,EAA6BG,EAAwBgG,EAAYhD,MAAM6C,aACjFnM,EAAAA,KAAAA,SAAUoG,EAAwBC,EAAsBF,IAGxCmG,EAAAA,EAAAA,qBAAAA,EAAYH,YAAa/F,EAAwBI,EAAUD,KAM3EvG,EAAAA,KAAAA,SAAUmG,EAA6BG,EAAwBgG,EAAYH,aAC3EnM,EAAAA,KAAAA,SAAUoG,EAAwBC,EAAsBF,IAGxCC,EAAAA,EAAAA,qBAAAA,EAAwBkG,EAAYhD,MAAM6C,YAAa3F,EAAUD,IAMlF5E,EAAAA,KAAAA,SAAUwB,EAASqD,EAAUrD,GAC7BtD,EAAAA,KAAAA,MAAOsD,EAASA,EAASc,EAAoBkH,GAE7CxJ,EAAAA,KAAAA,SAAUyB,EAAUmD,EAAWnD,GAC/BvD,EAAAA,KAAAA,MAAOuD,EAAUA,EAAUc,EAAiBiH,GAE5CmB,EAAY9H,OAAS,CAGnB,IADEL,IAAAA,EAA+CmI,EAA/CnI,oBAAqBC,EAA0BkI,EAA1BlI,iBAAkBE,EAAQgI,EAARhI,IACrC/D,EAAI,EAAGA,EAAI4D,EAAqB5D,IAAO,CAE1CsE,IAAAA,EAAIP,EAAK/D,GACfwL,EAAajG,EAAWvF,GAAKsK,GAAa1H,EAAS0B,GAI1B,IAArBT,IAEJ2H,EAAajG,EAAW3B,EAAsB,GAAK0G,GAAazH,EAAU,GAC1E2I,EAAajG,EAAW3B,EAAsB,GAAK0G,GAAazH,EAAU,GAC1E2I,EAAajG,EAAW3B,EAAsB,GAAK0G,GAAazH,EAAU,GAC1E2I,EAAajG,EAAW3B,EAAsB,GAAK0G,GAAazH,EAAU,GAC1E0C,GAAY,GAGbA,GAAY3B,OAKZ4H,EAAajG,EAAW,GAAK+E,GAAa1H,EAAS,GACnD4I,EAAajG,EAAW,GAAK+E,GAAa1H,EAAS,GACnD4I,EAAajG,EAAW,GAAK+E,GAAa1H,EAAS,GAGnD4I,EAAajG,EAAW,GAAK+E,GAAazH,EAAU,GACpD2I,EAAajG,EAAW,GAAK+E,GAAazH,EAAU,GACpD2I,EAAajG,EAAW,GAAK+E,GAAazH,EAAU,GACpD2I,EAAajG,EAAW,GAAK+E,GAAazH,EAAU,GACpD0C,GAAY,MAIP,CAGFyG,IAAAA,EAAY,EACXD,EAAY9H,SAEhB+H,EAAYD,EAAYnI,oBACc,IAAjCmI,EAAYlI,mBAEhBmI,GAAa,IAMT,IAAA,IAAIhM,EAAI,EAAGA,EAAIgM,EAAWhM,IAE/BwL,EAAajG,EAAWvF,GAAKsK,GAAa,EAI3C/E,GAAYyG,EAOTD,GAAAA,EAAY3D,UAAY,CAEtBhF,IAAAA,EAAW2I,EAAYnI,oBAAsBmI,EAAYlI,iBAE1D4H,GAAAA,IAAcM,EAUZ,IAAA,IAAI/L,EAAI,EAAGA,EAAIoD,EAAUpD,IAE9BwL,EAAajG,EAAW+E,GAAYA,IAAe,OAM9C,IAAA,IAAItK,EAAI,EAAGA,EAAIoD,EAAUpD,IAE9BwL,EAAajG,EAAWvF,GAAKsK,GAAa,EAM5C/E,GAAYnC,GAMdkH,MAMGA,GAAAA,IAAakB,EAAa,GAAIvM,OAE5B,MAAA,IAAIU,QAoHX,CAAA,IAAA,kBA7GgBuG,MAAAA,SAAAA,EAAchD,GAGxB,IADFqC,IAAAA,EAAW,EACLvF,EAAI,EAAGiB,EAAIiF,EAAajH,OAAQe,EAAIiB,EAAGjB,IAAO,CAEjDgD,IAAAA,EAAQkD,EAAclG,GACvBgD,EAAMqF,aAEc,EAAA,EAAA,wBAAA,KAAMrF,EAAOuC,EAAUrC,EAAakD,GAC5Db,GAAYa,EAAgBhD,UAIxBJ,EAAMoF,YAEV7D,sBAAuB,KAAMvB,EAAOuC,EAAUrC,EAAakD,GAC3Db,GAAYa,EAAgBhD,aA6F9B,CAAA,IAAA,4BAnF0B+C,MAAAA,SAAAA,EAAYD,EAAcG,GAS9C,IAPE7B,IAAAA,EAAwB,KAAxBA,oBAEF4C,EAAQ,KAAKA,MACf/D,EAAa,EACbiD,EAAY,EACZ2F,EAAkB,EAClB1F,EAAU,EACJvG,EAAI,EAAGiB,EAAImG,EAAMnI,OAAQe,EAAIiB,EAAGjB,IAAO,CAE5CkM,IAAAA,GAAkB,EAChBlJ,EAAQoE,EAAOpH,GACfqF,EAAYb,EAAoBpC,IAAKY,IAAW,EAajDA,EAAMqF,aAEc,EAAA,EAAA,wBAAA,KAAMrF,EAAOsD,EAAW,KAAMF,GAC/CA,EAAgBjD,cAEtB8I,GAAmB7F,EAAgBhD,SACnCC,GAAc+C,EAAgB/C,YAG/B6I,GAAkB,EAClB5F,GAAaF,EAAgBhD,UAKxBoC,IAAAA,EAAUxC,EAAMe,IACjBf,EAAMoF,YAEV7D,sBAAuB,KAAMvB,EAAOsD,EAAW,KAAMF,GAC9CA,EAAgBjD,cAEtB8I,GAAmB7F,EAAgBhD,SACnCC,GAAc+C,EAAgB/C,YAI/B6I,GAAkB,EAClB5F,GAAaF,EAAgBhD,UAIvBJ,EAAMiB,SAEZsC,GAAWf,EAAQvG,OAASoG,EAC5Bc,EAAWxD,KAAMK,IAIbkJ,GAEJhG,EAAavD,KAAMK,GAOI,IAApBiJ,IAEJ3F,EAAY,GAIbD,EAAcC,UAAYA,EAC1BD,EAAcE,QAAUA,EACxBF,EAAchD,WAAaA,MAE3B,EA1vBW8D,GA0vBX,QAAA,YAAA;;AChmBA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,EArMF,IAAA,EAAA,QAAA,oBAqME,SAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,wIAAA,SAAA,EAAA,EAAA,GAAA,GAAA,EAAA,CAAA,GAAA,iBAAA,EAAA,OAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,UAAA,SAAA,KAAA,GAAA,MAAA,GAAA,GAAA,MAAA,WAAA,GAAA,EAAA,cAAA,EAAA,EAAA,YAAA,MAAA,QAAA,GAAA,QAAA,EAAA,MAAA,KAAA,GAAA,cAAA,GAAA,2CAAA,KAAA,GAAA,EAAA,EAAA,QAAA,GAAA,SAAA,EAAA,GAAA,GAAA,oBAAA,QAAA,OAAA,YAAA,OAAA,GAAA,OAAA,MAAA,KAAA,GAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,OAAA,EAAA,GAAA,SAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,UAAA,EAAA,EAAA,QAAA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAnMWgF,IAAAA,EAAAA,WAEc,SAAA,IAAbC,IAAAA,EAAQ,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,GAAK,EAAA,KAAA,GAEpB1E,KAAAA,cAAgB,EAChBG,KAAAA,eAAiB,KACjBC,KAAAA,cAAgB,KAChBC,KAAAA,iBAAmB,IACnBC,KAAAA,eAAiB,IAEjB1E,KAAAA,6BAA+B,KAC/BC,KAAAA,0BAA4B,KAE5BG,KAAAA,kBAAoB,EACpBC,KAAAA,eAAiB,EAEjBgE,KAAAA,gBAAkB,KAClBC,KAAAA,aAAe,KAEfpE,KAAAA,sBAAwB,GACxBC,KAAAA,mBAAqB,GAErB2I,KAAAA,MAAQ9L,MAAM+L,QAASD,GAAeA,EAAAA,GAAU,CAAEA,GAClDE,KAAAA,QAAU,KAEVC,KAAAA,kBA0KL,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,kBArKiB,MAAA,WAEXH,IAAAA,EAAQ,KAAKA,MACbI,EAAS,GACTC,EAAY,IAAIhE,IAChBiE,EAAiB,IAAIjE,IA+D3B2D,EAAM7D,QA9DiB,SAAjBoE,EAAiBC,GAGjBA,GAAAA,EAAM/D,QAAU,CAEd7F,IAAAA,EAAQ4J,EAIT5J,GAHLyJ,EAAUtL,IAAK6B,GAGVA,EAAMqF,UAAY,CAMdwE,IAFFC,IAAAA,EAAW,IAAIrE,IACjBoE,EAAO7J,EAAM+F,MACT8D,GAAO,CAETA,GAAAA,EAAKhE,QAAU,CAEd4D,GAAAA,EAAUxB,IAAK4B,GAEnB,MAIAC,EAAS3L,IAAK0L,GACdH,EAAevL,IAAK0L,GAMtBA,EAAOA,EAAK/D,OAIb2D,EAAUlE,QAAS,SAAAnJ,GAElB0N,EAAS3L,IAAK/B,GACdsN,EAAevL,IAAK/B,KAGrBoN,EAAO7J,KAAMmK,IAQT,IADAC,IAAAA,EAAWH,EAAMG,SACb/M,EAAI,EAAGiB,EAAI8L,EAAS9N,OAAQe,EAAIiB,EAAGjB,IAE5C2M,EAAgBI,EAAU/M,IAK3ByM,EAAUO,OAAQJ,KASXJ,IADFS,IAAAA,EAAoB,GAvET,EAAA,WA0EVC,IAAAA,EAAYV,EAAOW,MACzBF,EAAkBtK,KAAMuK,GAClB,IA5EU,IAAA,EAAA,SAAA,GAgFTE,IAAAA,EAAaZ,EAAQxM,GAEvBqN,GAAY,EAChBD,EAAW7E,QAAS,SAAAnJ,GAEnBiO,EAAYA,GAAaH,EAAUjC,IAAK7L,KAIpCiO,IAEJD,EAAW7E,QAAS,SAAAnJ,GAAK8N,OAAAA,EAAU/L,IAAK/B,KACxCoN,EAAOc,OAAQtN,EAAG,GAClBA,KA7Fc,EAAA,GA4ENA,EAAI,EAAGA,EAAIwM,EAAOvN,OAAQe,IAA1BA,EAAAA,IAJHwM,EAAOvN,QAAS,IA+BlBsO,IAAAA,EAAiB,IAAI9E,IAC3B2D,EAAM7D,QAAS,SAAAiF,GAAQA,OAAAA,EAAKC,SAAU,SAAArO,GAEhCA,EAAEyJ,SAAWzJ,EAAE2E,IAAI9E,OAAS,IAAOyN,EAAezB,IAAK7L,IAE3DmO,EAAepM,IAAK/B,OAOjBkN,KAAAA,QAAUW,EAAkBhG,IAAK,SAAA7H,GAAK,OAAA,IAAI+H,EAAJ,YAAiB/H,KACvDmO,KAAAA,eAAiBA,IAiDtB,CAAA,IAAA,QA7CO,MAAA,WAECjB,IAAAA,EAA4B,KAA5BA,QAA4B,KAAnBiB,eAGFhF,QAAS,SAAAvF,GAElBA,EAAMoF,YAEVpF,EAAM2B,UAAU6D,IAAKxF,EAAM0B,WAC3B1B,EAAMyG,6BAOF,IADAiE,IAAAA,EAAU,GACN1N,EAAI,EAAGiB,EAAIqL,EAAQrN,OAAQe,EAAIiB,EAAGjB,IAAO,CAE5C2N,IAAAA,EAAIrB,EAAStM,GACnB2N,EAAEjG,cAAgB,KAAKA,cACvBiG,EAAE9F,eAAiB,KAAKA,eACxB8F,EAAE7F,cAAgB,KAAKA,cACvB6F,EAAE5F,iBAAmB,KAAKA,iBAC1B4F,EAAE3F,eAAiB,KAAKA,eAExB2F,EAAErK,6BAA+B,KAAKA,6BACtCqK,EAAEpK,0BAA4B,KAAKA,0BAEnCoK,EAAEjK,kBAAoB,KAAKA,kBAC3BiK,EAAEhK,eAAiB,KAAKA,eAExBgK,EAAEhG,gBAAkB,KAAKA,gBACzBgG,EAAE/F,aAAe,KAAKA,aAEtB+F,EAAEnK,sBAAwB,KAAKA,sBAC/BmK,EAAElK,mBAAqB,KAAKA,mBAEtBpD,IAAAA,EAASsN,EAAE9M,QACjB6M,EAAQ/K,KAAMtC,GAIRqN,OAAAA,MAEP,EAnMWvB,GAmMX,QAAA,OAAA;;;;;;;;;;ACnMwByB,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,UAAAA,EAF1B,IAAA,EAAA,QAAA,cAE0BA,SAAAA,EAAAA,GAAAA,OAAAA,EAAAA,mBAAAA,QAAAA,iBAAAA,OAAAA,SAAAA,SAAAA,GAAAA,cAAAA,GAAAA,SAAAA,GAAAA,OAAAA,GAAAA,mBAAAA,QAAAA,EAAAA,cAAAA,QAAAA,IAAAA,OAAAA,UAAAA,gBAAAA,IAAAA,GAAAA,SAAAA,EAAAA,GAAAA,OAAAA,EAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA,IAAAA,SAAAA,IAAAA,MAAAA,IAAAA,UAAAA,wIAAAA,SAAAA,EAAAA,EAAAA,GAAAA,GAAAA,EAAAA,CAAAA,GAAAA,iBAAAA,EAAAA,OAAAA,EAAAA,EAAAA,GAAAA,IAAAA,EAAAA,OAAAA,UAAAA,SAAAA,KAAAA,GAAAA,MAAAA,GAAAA,GAAAA,MAAAA,WAAAA,GAAAA,EAAAA,cAAAA,EAAAA,EAAAA,YAAAA,MAAAA,QAAAA,GAAAA,QAAAA,EAAAA,MAAAA,KAAAA,GAAAA,cAAAA,GAAAA,2CAAAA,KAAAA,GAAAA,EAAAA,EAAAA,QAAAA,GAAAA,SAAAA,EAAAA,GAAAA,GAAAA,oBAAAA,QAAAA,OAAAA,YAAAA,OAAAA,GAAAA,OAAAA,MAAAA,KAAAA,GAAAA,SAAAA,EAAAA,GAAAA,GAAAA,MAAAA,QAAAA,GAAAA,OAAAA,EAAAA,GAAAA,SAAAA,EAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,UAAAA,EAAAA,EAAAA,QAAAA,IAAAA,IAAAA,EAAAA,EAAAA,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,EAAAA,GAAAA,OAAAA,EAAAA,SAAAA,EAAAA,EAAAA,GAAAA,KAAAA,aAAAA,GAAAA,MAAAA,IAAAA,UAAAA,qCAAAA,SAAAA,EAAAA,EAAAA,GAAAA,IAAAA,IAAAA,EAAAA,EAAAA,EAAAA,EAAAA,OAAAA,IAAAA,CAAAA,IAAAA,EAAAA,EAAAA,GAAAA,EAAAA,WAAAA,EAAAA,aAAAA,EAAAA,EAAAA,cAAAA,EAAAA,UAAAA,IAAAA,EAAAA,UAAAA,GAAAA,OAAAA,eAAAA,EAAAA,EAAAA,IAAAA,IAAAA,SAAAA,EAAAA,EAAAA,EAAAA,GAAAA,OAAAA,GAAAA,EAAAA,EAAAA,UAAAA,GAAAA,GAAAA,EAAAA,EAAAA,GAAAA,EAAAA,SAAAA,EAAAA,EAAAA,EAAAA,GAAAA,OAAAA,EAAAA,oBAAAA,SAAAA,QAAAA,IAAAA,QAAAA,IAAAA,SAAAA,EAAAA,EAAAA,GAAAA,IAAAA,EAAAA,EAAAA,EAAAA,GAAAA,GAAAA,EAAAA,CAAAA,IAAAA,EAAAA,OAAAA,yBAAAA,EAAAA,GAAAA,OAAAA,EAAAA,IAAAA,EAAAA,IAAAA,KAAAA,GAAAA,EAAAA,SAAAA,EAAAA,EAAAA,GAAAA,GAAAA,SAAAA,EAAAA,EAAAA,GAAAA,MAAAA,OAAAA,UAAAA,eAAAA,KAAAA,EAAAA,IAAAA,QAAAA,EAAAA,EAAAA,MAAAA,OAAAA,EAAAA,SAAAA,EAAAA,EAAAA,GAAAA,GAAAA,mBAAAA,GAAAA,OAAAA,EAAAA,MAAAA,IAAAA,UAAAA,sDAAAA,EAAAA,UAAAA,OAAAA,OAAAA,GAAAA,EAAAA,UAAAA,CAAAA,YAAAA,CAAAA,MAAAA,EAAAA,UAAAA,EAAAA,cAAAA,KAAAA,GAAAA,EAAAA,EAAAA,GAAAA,SAAAA,EAAAA,EAAAA,GAAAA,OAAAA,EAAAA,OAAAA,gBAAAA,SAAAA,EAAAA,GAAAA,OAAAA,EAAAA,UAAAA,EAAAA,IAAAA,EAAAA,GAAAA,SAAAA,EAAAA,GAAAA,IAAAA,EAAAA,IAAAA,OAAAA,WAAAA,IAAAA,EAAAA,EAAAA,EAAAA,GAAAA,GAAAA,EAAAA,CAAAA,IAAAA,EAAAA,EAAAA,MAAAA,YAAAA,EAAAA,QAAAA,UAAAA,EAAAA,UAAAA,QAAAA,EAAAA,EAAAA,MAAAA,KAAAA,WAAAA,OAAAA,EAAAA,KAAAA,IAAAA,SAAAA,EAAAA,EAAAA,GAAAA,OAAAA,GAAAA,WAAAA,EAAAA,IAAAA,mBAAAA,EAAAA,EAAAA,GAAAA,EAAAA,SAAAA,EAAAA,GAAAA,QAAAA,IAAAA,EAAAA,MAAAA,IAAAA,eAAAA,6DAAAA,OAAAA,EAAAA,SAAAA,IAAAA,GAAAA,oBAAAA,UAAAA,QAAAA,UAAAA,OAAAA,EAAAA,GAAAA,QAAAA,UAAAA,KAAAA,OAAAA,EAAAA,GAAAA,mBAAAA,MAAAA,OAAAA,EAAAA,IAAAA,OAAAA,KAAAA,UAAAA,SAAAA,KAAAA,QAAAA,UAAAA,KAAAA,GAAAA,gBAAAA,EAAAA,MAAAA,GAAAA,OAAAA,GAAAA,SAAAA,EAAAA,GAAAA,OAAAA,EAAAA,OAAAA,eAAAA,OAAAA,eAAAA,SAAAA,GAAAA,OAAAA,EAAAA,WAAAA,OAAAA,eAAAA,KAAAA,GAAbC,IAAAA,EAAAA,SAAAA,GAAaD,EAAAA,EAAAA,EAAAA,OAAAA,IAAAA,EAAAA,EAAAA,GAEF,SAAA,IAAA,IAAA,EAAA,EAAA,KAAA,GAAPE,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAO,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAPA,EAAO,GAAA,UAAA,GAAA,OAEZA,EAAAA,EAAAA,KAAAA,MAAAA,EAAAA,CAAAA,MAAAA,OAAAA,KACL7J,QAAS,EACT8J,EAAAA,aAJiB,EAFEH,OAAAA,EAAAA,EAAAA,CAAAA,CAAAA,IAAAA,SAUP,MAAA,WAAPE,IAAO,IAAA,EAAPA,EAAAA,UAAAA,OAAAA,EAAO,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAPA,EAAO,GAAA,UAAA,GAGbE,IAAAA,EACHC,OAAQH,EAAKI,SAAUnJ,EAAIC,IAAAA,KAC3BiJ,OAAQH,EAAKI,SAAUnJ,EAAIE,IAAAA,KAC3BgJ,OAAQH,EAAKI,SAAUnJ,EAAIG,IAAAA,KAEvB8I,GAAa,IAAbA,GAA+B,IAAbA,EAEhB,MAAA,IAAIrO,OAIMmO,EAAAA,EAAAA,EAAAA,EAAAA,WAAAA,SAAAA,OAAAA,KAAAA,MAAAA,EAAAA,CAAAA,MAAAA,OAAAA,MAxBOF,CAAAA,IAAAA,aA4BH,MAAA,WAEhBO,KAAAA,OAAL,MAAA,KAAA,aA9BwBP,CAAAA,IAAAA,aAkCH,MAAA,WAAPE,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAO,IAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAPA,EAAO,GAAA,UAAA,GAEfvH,IAAAA,EAAU,CACfxB,EAAIqJ,IAAAA,EAAGrJ,EAAIsJ,IAAAA,EAAGtJ,EAAIuJ,IAAAA,EAClBvJ,EAAIC,IAAAA,GAAID,EAAIE,IAAAA,GAAIF,EAAIG,IAAAA,IACnBgD,OAAQ,SAAA5D,GAAK,OAAEwJ,EAAKI,SAAU5J,KAC3B6J,KAAAA,OAAW5H,MAAAA,KAAAA,EAAAA,MAxCQqH,CAAAA,IAAAA,WA4Cd,MAAA,WAEJ,MAAA,IAAIjO,UA9CciO,EAAbC,GAAaD,QAAAA,KAAAA;;AC+JzB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,UAAA,EAAA,QAAA,YAAA,EAjKD,IAAA,EAAA,QAAA,oBACA,EAAA,QAAA,mBACA,EAAA,QAAA,mBA+JC,SAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,IAAA,SAAA,IAAA,MAAA,IAAA,UAAA,wIAAA,SAAA,EAAA,EAAA,GAAA,GAAA,EAAA,CAAA,GAAA,iBAAA,EAAA,OAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,UAAA,SAAA,KAAA,GAAA,MAAA,GAAA,GAAA,MAAA,WAAA,GAAA,EAAA,cAAA,EAAA,EAAA,YAAA,MAAA,QAAA,GAAA,QAAA,EAAA,MAAA,KAAA,GAAA,cAAA,GAAA,2CAAA,KAAA,GAAA,EAAA,EAAA,QAAA,GAAA,SAAA,EAAA,GAAA,GAAA,oBAAA,QAAA,OAAA,YAAA,OAAA,GAAA,OAAA,MAAA,KAAA,GAAA,SAAA,EAAA,GAAA,GAAA,MAAA,QAAA,GAAA,OAAA,EAAA,GAAA,SAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,UAAA,EAAA,EAAA,QAAA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,MAAA,GAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,EA5JM,SAASW,EAAWC,GAMpB,IAJAvH,IAAAA,EAAM,IAAIqB,IACVmG,EAAO,GAGHzO,EAAI,EAAGiB,EAAIuN,EAAOvP,OAAQe,EAAIiB,EAAGjB,IAAO,CAE3C4M,IAAAA,EAAQ4B,EAAQxO,GAGrB0O,EAYG9B,EAZH8B,KACA3K,EAWG6I,EAXH7I,IACAY,EAUGiI,EAVHjI,UACAD,EASGkI,EATHlI,UACA8F,EAQGoC,EARHpC,YACAmE,EAOG/B,EAPH+B,YACAC,EAMGhC,EANHgC,YACAxG,EAKGwE,EALHxE,UACAiB,EAIGuD,EAJHvD,YACAwF,EAGGjC,EAHHiC,SACAC,EAEGlC,EAFHkC,WACAzG,EACGuE,EADHvE,UAGG0G,EAAO,OACNnC,EAAM3I,OAEV8K,EAAO,OAEInC,EAAM/D,UAEjBkG,EAAO,SAIFhO,IAAAA,EAAM,CACXgD,IAAKA,EAAMA,EAAIiL,QAAU,KACzBrK,UAAWA,EAAYA,EAAUqK,QAAU,KAC3CtK,UAAWA,EAAYA,EAAUsK,QAAU,KAC3CxE,YAAaA,EAAcA,EAAYwE,QAAU,KACjDL,YAAaA,EAAcA,EAAYK,QAAU,KACjDJ,YAAaA,EAAcA,EAAYI,QAAU,KACjD5G,UAAAA,EACAiB,YAAAA,EACAhB,UAAAA,EAEAqG,KAAAA,EACAG,SAAUA,EAASG,QACnBF,WAAYA,EAAWE,QACvBjC,SAAU,KACVgC,KAAAA,GAGDN,EAAK9L,KAAM5B,GACXkG,EAAIuB,IAAKoE,EAAO5M,GAKX,IAAA,IAAIA,EAAI,EAAGiB,EAAIuN,EAAOvP,OAAQe,EAAIiB,EAAGjB,IAAO,CAE3CiP,IAAAA,EAAMR,EAAMzO,GACZ4M,EAAQ4B,EAAQxO,GACtBiP,EAAIlC,SAAWH,EAAMG,SAAS9F,IAAK,SAAA7H,GAAK6H,OAAAA,EAAI7E,IAAKhD,KAE5CwN,EAAM9D,OAEVmG,EAAInG,OAAS7B,EAAI7E,IAAKwK,EAAM9D,QAI5BmG,EAAInG,OAAS,KAMR2F,OAAAA,EAKD,SAASS,EAAaC,GAqDtB,IAlDAX,IAAAA,EACLW,EAAKlI,IAAK,SAAA3C,GAAK,IAAA,EAmBVsI,EAhBHmC,EAcGzK,EAdHyK,KACAL,EAaGpK,EAbHoK,KACAG,EAYGvK,EAZHuK,SACAC,EAWGxK,EAXHwK,WAEA/K,EASGO,EATHP,IACAY,EAQGL,EARHK,UACAD,EAOGJ,EAPHI,UACA8F,EAMGlG,EANHkG,YACAmE,EAKGrK,EALHqK,YACAC,EAIGtK,EAJHsK,YACAxG,EAGG9D,EAHH8D,UACAiB,EAEG/E,EAFH+E,YACAhB,EACG/D,EADH+D,UAIQ0G,OAAAA,GACH,IAAA,OACA,IAAA,SAGJnC,EAFAA,EAAiB,SAATmC,EAAkB,IAAIlB,EAAJ,KAAa,IAAID,EAAJ,OAEjCO,OAAWpK,MAAAA,EAAAA,EAAAA,IACjB6I,EAAMjI,UAAU6D,IAAK7D,GACrBiI,EAAMlI,UAAU8D,IAAK9D,GACrBkI,EAAMpC,YAAYhC,IAAKgC,GACvBoC,EAAM+B,YAAYnG,IAAKmG,GACvB/B,EAAMgC,YAAYpG,IAAKoG,GAEvBhC,EAAMxE,UAAYA,EAClBwE,EAAMvD,YAAcA,EACpBuD,EAAMvE,UAAYA,EAClB,MACI,IAAA,OACJuE,EAAQ,IAAIwC,EAAJ,KAOHxC,OAHPA,EAAM8B,KAAOA,EACb9B,EAAMiC,SAASrG,IAAKqG,GACpBjC,EAAMkC,WAAWtG,IAAKsG,GACflC,IAKC5M,EAAI,EAAGA,EAAIwO,EAAOvP,OAAQe,IAAO,CAAA,IAAA,EAEpC4M,EAAQ4B,EAAQxO,GAChByO,EAAOU,EAAMnP,GAEnB4M,EAAM9D,OAAS0F,EAAQC,EAAK3F,SAAY,MACxC8D,EAAAA,EAAMG,UAASpK,KAAS8L,MAAAA,EAAAA,EAAAA,EAAK1B,SAAS9F,IAAK,SAAAjH,GAAKwO,OAAAA,EAAQxO,OACxD4M,EAAMyC,uBAEDzC,EAAM/D,UAEV+D,EAAM7D,MAAQ6D,EAAMG,SAAU,IAAO,KACrCH,EAAMnD,2BAMD+E,OAAAA;;ACqCP,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,qBAAA,EAAA,QAAA,cAAA,EAAA,QAAA,gBAAA,EAAA,QAAA,kBAAA,EAAA,QAAA,kBAAA,EAAA,QAAA,YAAA,QAAA,kBAAA,EApMM,IAAMc,EAAe,IAoM3B,QAAA,aAAA,EAlMM,IAAMC,EAAc,GAEpB,SAASC,EAAsBhB,GAe/BiB,IAAAA,EAAc,IAAIC,kBAAmBJ,EAAed,EAAOvP,QAI1DwQ,OADPE,EAAenB,EAFC,IAAIoB,aAAcH,GACpB,IAAI/G,WAAY+G,IAEvBA,EAID,SAASE,EAAenB,EAAQqB,EAAaC,GAE7C,IAFyDC,IAAAA,IAAgB,UAAA,OAAA,QAAA,IAAA,UAAA,KAAA,UAAA,GAAMC,IAAoB,UAAA,OAAA,QAAA,IAAA,UAAA,KAAA,UAAA,GAE/FhQ,EAAI,EAAGiB,EAAIuN,EAAOvP,OAAQe,EAAIiB,EAAGjB,IAE1CiQ,EAAmBzB,EAAQxO,GAAK6P,EAAaC,EAAY9P,EAAIsP,EAAcS,EAAeC,GAMrF,SAASE,EAAiB1B,EAAQqB,EAAaC,GAE/C,IAF2DC,IAAAA,IAAgB,UAAA,OAAA,QAAA,IAAA,UAAA,KAAA,UAAA,GAAMC,IAAoB,UAAA,OAAA,QAAA,IAAA,UAAA,KAAA,UAAA,GAEjGhQ,EAAI,EAAGiB,EAAIuN,EAAOvP,OAAQe,EAAIiB,EAAGjB,IAE1CmQ,EAAmB3B,EAAQxO,GAAK6P,EAAaC,EAAYR,EAAetP,EAAG+P,EAAeC,GAQrF,SAASC,EACfrD,EACAiD,EACAC,EACAM,GACAL,IAAAA,IAAgB,UAAA,OAAA,QAAA,IAAA,UAAA,KAAA,UAAA,GAIVM,EAAcD,EAAa,EAC5BJ,KAJe,UAAA,OAAA,QAAA,IAAA,UAAA,KAAA,UAAA,GAIK,CAMlB,IAHLnB,IAAAA,EAEGjC,EAFHiC,SACAC,EACGlC,EADHkC,WAES9O,EAAI,EAAGA,EAAI,EAAGA,IAEvB6P,EAAaQ,EAAc,EAAIrQ,GAAM6O,EAAU7O,GAI1C,IAAA,IAAIA,EAAI,EAAGA,EAAI,EAAGA,IAEvB6P,EAAaQ,EAAc,EAAIrQ,GAAM8O,EAAY9O,GAI7C4M,GAAAA,EAAM/D,QAAU,CAWd,IARLnE,IAAAA,EAMGkI,EANHlI,UACA8F,EAKGoC,EALHpC,YACAmE,EAIG/B,EAJH+B,YACAC,EAGGhC,EAHHgC,YACAxG,EAEGwE,EAFHxE,UACAiB,EACGuD,EADHvD,YAGSrJ,EAAI,EAAGA,EAAI,EAAGA,IAEvB6P,EAAaQ,EAAc,EAAI,EAAQrQ,GAAM0E,EAAW1E,GACxD6P,EAAaQ,EAAc,EAAI,EAAQrQ,GAAMwK,EAAaxK,GAC1D6P,EAAaQ,EAAc,EAAI,GAAQrQ,GAAM2O,EAAa3O,GAC1D6P,EAAaQ,EAAc,EAAI,GAAQrQ,GAAM4O,EAAa5O,GAI3D8P,EAAYM,EAAa,KAAQnC,OAAQ7F,GACzC0H,EAAYM,EAAa,KAAQnC,OAAQ5E,IAOtC0G,GAAAA,GAAiBnD,EAAM/D,QAIrB,IAFElE,IAAAA,EAAciI,EAAdjI,UAEE3E,EAAI,EAAGA,EAAI,EAAGA,IAEvB6P,EAAaQ,EAAc,EAAI,GAAQrQ,GAAM2E,EAAW3E,GASpD,SAASmQ,EACfnN,EACA6M,EACAC,EACAM,GACAL,IAAAA,IAAgB,UAAA,OAAA,QAAA,IAAA,UAAA,KAAA,UAAA,GAIVM,EAAcD,EAAa,EAE5BJ,MALe,UAAA,OAAA,QAAA,IAAA,UAAA,KAAA,UAAA,MAOnBhN,EAAMsN,YACLT,EAAaQ,EAAc,GAC3BR,EAAaQ,EAAc,GAC3BR,EAAaQ,EAAc,IAE5BrN,EAAMuN,cACLV,EAAaQ,EAAc,EAAI,GAC/BR,EAAaQ,EAAc,EAAI,GAC/BR,EAAaQ,EAAc,EAAI,GAC/BR,EAAaQ,EAAc,EAAI,IAG3BrN,EAAM6F,SAAU,CASd,IANLnE,IAAAA,EAIG1B,EAJH0B,UACA8F,EAGGxH,EAHHwH,YACAmE,EAEG3L,EAFH2L,YACAC,EACG5L,EADH4L,YAGS5O,EAAI,EAAGA,EAAI,EAAGA,IAEvB0E,EAAW1E,GAAM6P,EAAaQ,EAAc,EAAI,EAAQrQ,GACxDwK,EAAaxK,GAAM6P,EAAaQ,EAAc,EAAI,EAAQrQ,GAC1D2O,EAAa3O,GAAM6P,EAAaQ,EAAc,EAAI,GAAQrQ,GAC1D4O,EAAa5O,GAAM6P,EAAaQ,EAAc,EAAI,GAAQrQ,GAI3DgD,EAAMoF,UAAYoI,QAASV,EAAYM,EAAa,MACpDpN,EAAMqG,YAAcmH,QAASV,EAAYM,EAAa,MAMnDL,GAAAA,GAAiB/M,EAAM6F,QAAU,CAI/B,IAFElE,IAAAA,EAAc3B,EAAd2B,UACJ8L,GAAU,EACJzQ,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAExB0Q,IAAAA,EAAIb,EAAaQ,EAAc,EAAI,GAAQrQ,GAC5C0Q,IAAM/L,EAAW3E,KAErB2E,EAAW3E,GAAM0Q,EACjBD,GAAU,GAQPA,GAEJzN,EAAMyG,2BAMR,QAAA,YAAA;;;AC1GA,IAAA,EAAA,UAAA,GA1FD,EAAA,QAAA,qBACA,EAAA,QAAA,0BACA,EAAA,QAAA,kBACA,EAAA,QAAA,cAEI1G,EAAS,IAAIoJ,EAAJ,OACTwE,GAAgB,EAGhBnC,EAAS,KAGToC,EAAS,KACTf,EAAc,KACdC,EAAa,KA+CjB,SAASe,KAGSrC,EAAAA,EAAAA,iBAAAA,EAAQqB,EAAaC,GAAY,GAAO,GAGnDzP,IAAAA,EAAS0C,EAAOlC,SAGP2N,EAAAA,EAAAA,eAAAA,EAAQqB,EAAaC,GAAY,GAAM,GAKrDa,EAHItQ,IAAWmG,EAAaI,aAAAA,QAGdkK,WAAYD,IAIV,EAIZE,KAAAA,YAAa,CAEjBhC,KAAM,cACNI,KAAM9O,IAtER2Q,EAAOC,UAAY,SAAwB,GAANC,IAAAA,EAAN/B,EAAAA,KAEtBJ,EAAemC,EAAfnC,KAAMI,EAAS+B,EAAT/B,KACLJ,OAAAA,GAGH,IAAA,kBACJP,GAAS,EAAaW,EAAAA,aAAAA,EAAKgC,YAC3BpO,EAAOqJ,MAAQoC,EAAOtG,OAAQ,SAAAkJ,GAAKA,OAAa,OAAbA,EAAEtI,SACrC/F,EAAOwJ,kBAEPqE,EAASzB,EAAKyB,OACdd,EAAa,IAAIpH,WAAYkI,GAC7Bf,EAAc,IAAID,aAAcgB,GAChC,MAGI,IAAA,uBACJ9J,OAAOuK,OAAQtO,EAAQoM,GACvB,MAGI,IAAA,cACmB,IAAlBwB,GAEJE,IAGD,MAGI,IAAA,YACmB,IAAlBF,IAEJW,aAAcX,GACdA,GAAgB","file":"workerSolver.worker.316d40ac.js","sourceRoot":"..\\example","sourcesContent":["/**\n * Gauss-Jordan elimination\n */\n\nvar linear = (function(){\n/**\n * Used internally to solve systems\n * If you want to solve A.x = B,\n * choose data=A and mirror=B.\n * mirror can be either an array representing a vector\n * or an array of arrays representing a matrix.\n */\nfunction Mat(data, mirror) {\n  // Clone the original matrix\n  this.data = new Array(data.length);\n  for (var i=0, cols=data[0].length; i<data.length; i++) {\n    this.data[i] = new Array(cols);\n    for(var j=0; j<cols; j++) {\n      this.data[i][j] = data[i][j];\n    }\n  }\n\n  if (mirror) {\n    if (typeof mirror[0] !== \"object\") {\n      for (var i=0; i<mirror.length; i++) {\n        mirror[i] = [mirror[i]];\n      }\n    }\n    this.mirror = new Mat(mirror);\n  }\n}\n\n/**\n * Swap lines i and j in the matrix\n */\nMat.prototype.swap = function (i, j) {\n  if (this.mirror) this.mirror.swap(i,j);\n  var tmp = this.data[i];\n  this.data[i] = this.data[j];\n  this.data[j] = tmp;\n}\n\n/**\n * Multiply line number i by l\n */\nMat.prototype.multline = function (i, l) {\n  if (this.mirror) this.mirror.multline(i,l);\n  var line = this.data[i];\n  for (var k=line.length-1; k>=0; k--) {\n    line[k] *= l;\n  }\n}\n\n/**\n * Add line number j multiplied by l to line number i\n */\nMat.prototype.addmul = function (i, j, l) {\n  if (this.mirror) this.mirror.addmul(i,j,l);\n  var lineI = this.data[i], lineJ = this.data[j];\n  for (var k=lineI.length-1; k>=0; k--) {\n    lineI[k] = lineI[k] + l*lineJ[k];\n  }\n}\n\n/**\n * Tests if line number i is composed only of zeroes\n */\nMat.prototype.hasNullLine = function (i) {\n  for (var j=0; j<this.data[i].length; j++) {\n    if (this.data[i][j] !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nMat.prototype.gauss = function() {\n  var pivot = 0,\n      lines = this.data.length,\n      columns = this.data[0].length,\n      nullLines = [];\n\n  for (var j=0; j<columns; j++) {\n    // Find the line on which there is the maximum value of column j\n    var maxValue = 0, maxLine = 0;\n    for (var k=pivot; k<lines; k++) {\n      var val = this.data[k][j];\n      if (Math.abs(val) > Math.abs(maxValue)) {\n        maxLine = k;\n        maxValue = val;\n      } \n    }\n    if (maxValue === 0) {\n      // The matrix is not invertible. The system may still have solutions.\n      nullLines.push(pivot);\n    } else {\n      // The value of the pivot is maxValue\n      this.multline(maxLine, 1/maxValue);\n      this.swap(maxLine, pivot);\n      for (var i=0; i<lines; i++) {\n        if (i !== pivot) {\n          this.addmul(i, pivot, -this.data[i][j]);\n        }\n      }\n    }\n    pivot++;\n  }\n\n  // Check that the system has null lines where it should\n  for (var i=0; i<nullLines.length; i++) {\n    if (!this.mirror.hasNullLine(nullLines[i])) {\n      throw new Error(\"singular matrix\");\n    }\n  }\n  return this.mirror.data;\n}\n\n/**\n * Solves A.x = b\n * @param A\n * @param b\n * @return x\n */\nexports.solve = function solve(A, b) {\n  var result = new Mat(A,b).gauss();\n  if (result.length > 0 && result[0].length === 1) {\n    // Convert Nx1 matrices to simple javascript arrays\n    for (var i=0; i<result.length; i++) result[i] = result[i][0];\n  }\n  return result;\n}\n\nfunction identity(n) {\n  var id = new Array(n);\n  for (var i=0; i<n; i++) {\n    id[i] = new Array(n);\n    for (var j=0; j<n; j++) {\n      id[i][j] = (i === j) ? 1 : 0;\n    }\n  }\n  return id;\n}\n\n/**\n * invert a matrix\n */\nexports.invert = function invert(A) {\n  return new Mat(A, identity(A.length)).gauss();\n}\n\nreturn exports;\n})();\n\nif (typeof module.exports === \"object\") module.exports = linear;\n","import linearSolve from 'linear-solve';\r\n\r\nfunction transpose( outMatrix, a ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ c ][ r ] = a[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction identity( outMatrix ) {\r\n\r\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = r === c ? 1 : 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction scale( outMatrix, matrix, scalar ) {\r\n\r\n\tfor ( let r = 0, tr = outMatrix.length; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0, tc = outMatrix.length; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = matrix[ r ][ c ] * scalar;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction multiply( outMatrix, a, b ) {\r\n\r\n\tif ( a === b ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n\t// a is m x n\r\n\t// b is n x k\r\n\t// outMatrix is m x k\r\n\r\n\t// m = a rows\r\n\t// n = a cols or b rows\r\n\t// k = b cols\r\n\r\n\tconst m = a.length;\r\n\tconst n = b.length;\r\n\tconst k = b[ 0 ].length;\r\n\r\n\t// iterate over m\r\n\tfor ( let r = 0, tr = m; r < tr; r ++ ) {\r\n\r\n\t\t// iterate over k\r\n\t\tfor ( let c = 0, tc = k; c < tc; c ++ ) {\r\n\r\n\t\t\tlet sum = 0;\r\n\r\n\t\t\t// iterate over n\r\n\t\t\tfor ( let i = 0, ti = n; i < ti; i ++ ) {\r\n\r\n\t\t\t\tsum += a[ r ][ i ] * b[ i ][ c ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutMatrix[ r ][ c ] = sum;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction create( row, col ) {\r\n\r\n\tconst result = new Array( row );\r\n\tfor ( let i = 0; i < row; i ++ ) {\r\n\r\n\t\tresult[ i ] = new Float64Array( col );\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction copy( outMatrix, sourceMatrix ) {\r\n\r\n\tconst tr = sourceMatrix.length;\r\n\tconst tc = sourceMatrix[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = sourceMatrix[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction clone( matrix ) {\r\n\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tconst resultMatrix = create( rows, cols );\r\n\tcopy( resultMatrix, matrix );\r\n\treturn resultMatrix;\r\n\r\n}\r\n\r\nfunction solve( outMatrix, matrix, vector ) {\r\n\r\n\tconst res = linearSolve.solve( matrix, vector );\r\n\tfor ( let i = 0, l = res.length; i < l; i ++ ) {\r\n\r\n\t\toutMatrix[ i ][ 0 ] = res[ i ];\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction invert( outMatrix, matrix ) {\r\n\r\n\tconst res = linearSolve.invert( matrix );\r\n\r\n\tconst tr = matrix[ 0 ].length;\r\n\tconst tc = matrix.length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = res[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction add( outMatrix, a, b ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] + b[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction subtract( outMatrix, a, b ) {\r\n\r\n\tconst tr = a.length;\r\n\tconst tc = a[ 0 ].length;\r\n\tfor ( let r = 0; r < tr; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < tc; c ++ ) {\r\n\r\n\t\t\toutMatrix[ r ][ c ] = a[ r ][ c ] - b[ r ][ c ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction magnitudeSquared( matrix ) {\r\n\r\n\tlet sum = 0;\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tfor ( let r = 0; r < rows; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < cols; c ++ ) {\r\n\r\n\t\t\tsum += matrix[ r ][ c ] ** 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn sum;\r\n\r\n}\r\n\r\nfunction magnitude( matrix ) {\r\n\r\n\treturn Math.sqrt( magnitudeSquared( matrix ) );\r\n\r\n}\r\n\r\nfunction toString( matrix, dec = 3 ) {\r\n\r\n\tconst rows = matrix.length;\r\n\tconst cols = matrix[ 0 ].length;\r\n\tlet str = '';\r\n\tfor ( let r = 0; r < rows; r ++ ) {\r\n\r\n\t\tfor ( let c = 0; c < cols; c ++ ) {\r\n\r\n\t\t\tstr += matrix[ r ][ c ].toFixed( dec ) + ', ';\r\n\r\n\t\t}\r\n\t\tstr += '\\n';\r\n\r\n\t}\r\n\treturn str;\r\n\r\n}\r\n\r\nfunction log( matrix, dec ) {\r\n\r\n\tconsole.log( toString( matrix, dec ) );\r\n\r\n}\r\n\r\nexport const mat = {\r\n\ttranspose,\r\n\tidentity,\r\n\tscale,\r\n\tmultiply,\r\n\tcreate,\r\n\tcopy,\r\n\tclone,\r\n\tsolve,\r\n\tinvert,\r\n\tadd,\r\n\tsubtract,\r\n\tmagnitudeSquared,\r\n\tmagnitude,\r\n\ttoString,\r\n\tlog,\r\n};\r\n","import { mat } from './utils/matrix.js';\n\nclass FixedMatrixPool {\n\n\tconstructor( row, col ) {\n\n\t\tconst matrices = [];\n\t\tlet index = 0;\n\n\t\tthis.get = function() {\n\n\t\t\tlet matrix = matrices[ index ];\n\t\t\tif ( ! matrix ) {\n\n\t\t\t\tmatrices[ index ] = matrix = mat.create( row, col );\n\n\t\t\t}\n\t\t\tindex ++;\n\t\t\treturn matrix;\n\n\t\t};\n\n\t\tthis.releaseAll = function() {\n\n\t\t\tindex = 0;\n\n\t\t};\n\n\t}\n\n}\n\nexport class MatrixPool {\n\n\tconstructor() {\n\n\t\tconst pools = {};\n\t\tconst poolArray = [];\n\t\tthis.get = function( row, col ) {\n\n\t\t\tlet colPools = pools[ row ];\n\t\t\tif ( ! colPools ) {\n\n\t\t\t\tcolPools = pools[ row ] = {};\n\n\t\t\t}\n\n\t\t\tlet pool = colPools[ col ];\n\t\t\tif ( ! pool ) {\n\n\t\t\t\tpool = colPools[ col ] = new FixedMatrixPool( row, col );\n\t\t\t\tpoolArray.push( pool );\n\n\t\t\t}\n\n\t\t\treturn pool.get();\n\n\t\t};\n\n\t\tthis.releaseAll = function() {\n\n\t\t\tfor ( let i = 0, l = poolArray.length; i < l; i ++ ) {\n\n\t\t\t\tpoolArray[ i ].releaseAll();\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n","import { vec3, vec4 } from 'gl-matrix';\r\n\r\nconst tempPos = new Float64Array( 3 );\r\nconst tempQuat = new Float64Array( 4 );\r\n\r\nexport function accumulateClosureError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\tdofFlags,\r\n\t\tdof,\r\n\t} = joint;\r\n\r\n\t// Get the error from child towards the closure target\r\n\tjoint.getClosureError( tempPos, tempQuat );\r\n\r\n\tlet rowCount = 7;\r\n\tif ( joint.isGoal ) {\r\n\r\n\t\ttempPos[ 0 ] *= dofFlags[ 0 ];\r\n\t\ttempPos[ 1 ] *= dofFlags[ 1 ];\r\n\t\ttempPos[ 2 ] *= dofFlags[ 2 ];\r\n\t\trowCount = translationDoFCount;\r\n\r\n\t\tif ( rotationDoFCount === 0 ) {\r\n\r\n\t\t\ttempQuat[ 0 ] = 0;\r\n\t\t\ttempQuat[ 1 ] = 0;\r\n\t\t\ttempQuat[ 2 ] = 0;\r\n\t\t\ttempQuat[ 3 ] = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trowCount += 4;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tlet isConverged = false;\r\n\tlet totalError = 0;\r\n\tconst posMag = vec3.length( tempPos );\r\n\tconst rotMag = vec4.length( tempQuat );\r\n\tif (\r\n\t\tposMag < translationConvergeThreshold &&\r\n\t\trotMag < rotationConvergeThreshold\r\n\t) {\r\n\r\n\t\tisConverged = true;\r\n\r\n\t}\r\n\r\n\ttotalError += posMag + rotMag;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tif ( posMag > translationErrorClamp ) {\r\n\r\n\t\t\tvec3.scale( tempPos, tempPos, translationErrorClamp / posMag );\r\n\r\n\t\t}\r\n\t\tvec4.scale( tempPos, tempPos, translationFactor );\r\n\r\n\t\tif ( rotMag > rotationErrorClamp ) {\r\n\r\n\t\t\tvec4.scale( tempQuat, tempQuat, rotationErrorClamp / rotMag );\r\n\r\n\t\t}\r\n\t\tvec4.scale( tempQuat, tempQuat, rotationFactor );\r\n\r\n\t\tif ( joint.isGoal ) {\r\n\r\n\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\r\n\r\n\t\t\t\tconst d = dof[ i ];\r\n\t\t\t\terrorVector[ startIndex + i ][ 0 ] = tempPos[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joint.rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 0 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 1 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 2 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\t\terrorVector[ startIndex + translationDoFCount + 3 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\terrorVector[ startIndex + 0 ][ 0 ] = tempPos[ 0 ];\r\n\t\t\terrorVector[ startIndex + 1 ][ 0 ] = tempPos[ 1 ];\r\n\t\t\terrorVector[ startIndex + 2 ][ 0 ] = tempPos[ 2 ];\r\n\r\n\t\t\terrorVector[ startIndex + 3 ][ 0 ] = tempQuat[ 0 ];\r\n\t\t\terrorVector[ startIndex + 4 ][ 0 ] = tempQuat[ 1 ];\r\n\t\t\terrorVector[ startIndex + 5 ][ 0 ] = tempQuat[ 2 ];\r\n\t\t\terrorVector[ startIndex + 6 ][ 0 ] = tempQuat[ 3 ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tresult.totalError = totalError;\r\n\tresult.isConverged = isConverged;\r\n\tresult.rowCount = rowCount;\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function accumulateTargetError(\r\n\tsolver,\r\n\tjoint,\r\n\tstartIndex,\r\n\terrorVector = null,\r\n\tresult = { isConverged: false, rowCount: 7, totalError: 0 }\r\n) {\r\n\r\n\t// Find whether or not the target has converged or not\r\n\tconst {\r\n\t\ttranslationConvergeThreshold,\r\n\t\trotationConvergeThreshold,\r\n\t\tlockedJointDoFCount,\r\n\t\ttranslationErrorClamp,\r\n\t\trotationErrorClamp,\r\n\t\tlockedJointDoF,\r\n\t} = solver;\r\n\r\n\tconst {\r\n\t\tdofTarget,\r\n\t\tdofValues,\r\n\t\ttranslationDoFCount,\r\n\t\trotationDoFCount,\r\n\t\ttranslationFactor,\r\n\t\trotationFactor,\r\n\t} = joint;\r\n\r\n\t// get the position delta\r\n\tconst posDelta = vec3.distance( dofValues, dofTarget );\r\n\r\n\t// TODO: if three euler angles are being used we should set this to a quaternion to measure\r\n\t// error rather than euler angles. We should instead just always use quaternions for targets\r\n\t// for now.\r\n\t// Before running this solver we try to ensure the target and restPose are minimized\r\n\tlet rotDelta =\r\n\t\tdofTarget[ DOF.EX ] - dofValues[ DOF.EX ] +\r\n\t\tdofTarget[ DOF.EY ] - dofValues[ DOF.EY ] +\r\n\t\tdofTarget[ DOF.EZ ] - dofValues[ DOF.EZ ];\r\n\r\n\t// Get the row count\r\n\tconst lockedDoFCount = lockedJointDoFCount.get( joint ) || 0;\r\n\tresult.rowCount = translationDoFCount + rotationDoFCount - lockedDoFCount;\r\n\tresult.isConverged = posDelta < translationConvergeThreshold && rotDelta < rotationConvergeThreshold;\r\n\terrorResult.totalError = posDelta + rotDelta;\r\n\r\n\tif ( errorVector ) {\r\n\r\n\t\tconst lockedDoF = lockedJointDoF.get( joint );\r\n\t\tconst isLocked = lockedDoFCount !== 0;\r\n\t\tconst rowIndex = 0;\r\n\r\n\t\t// error from current state to target\r\n\t\ttempPos[ 0 ] = dofTarget[ 0 ] - dofValues[ 0 ];\r\n\t\ttempPos[ 1 ] = dofTarget[ 1 ] - dofValues[ 1 ];\r\n\t\ttempPos[ 2 ] = dofTarget[ 2 ] - dofValues[ 2 ];\r\n\r\n\t\t// clamp the position delta to the max error step\r\n\t\tconst posMag = vec3.length( tempPos );\r\n\t\tvec3.scale( tempPos, tempPos, translationFactor * translationErrorClamp / posMag );\r\n\t\tfor ( let i = 0, l = translationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempPos[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// get the euler differences\r\n\t\t// before running this solver we minimize the euler targets\r\n\t\ttempEuler[ 0 ] = joint.dofTarget[ 3 ] - joint.dofValues[ 3 ];\r\n\t\ttempEuler[ 1 ] = joint.dofTarget[ 4 ] - joint.dofValues[ 4 ];\r\n\t\ttempEuler[ 2 ] = joint.dofTarget[ 5 ] - joint.dofValues[ 5 ];\r\n\r\n\t\t// clamp the euler difference to the error step magnitude\r\n\t\tconst eulerMag = vec3.length( tempEuler );\r\n\t\tvec3.scale( tempEuler, tempEuler, rotationFactor * rotationErrorClamp / eulerMag );\r\n\t\tfor ( let i = translationDoFCount, l = translationDoFCount + rotationDoFCount; i < l; i ++ ) {\r\n\r\n\t\t\tconst dof = dofList[ i ];\r\n\r\n\t\t\t// skip this degree of freedom if it's locked\r\n\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\terrorVector[ startIndex + rowIndex ][ 0 ] = tempEuler[ dof ];\r\n\t\t\trowIndex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { vec3, vec4, mat4 } from 'gl-matrix';\r\nimport { MatrixPool } from './MatrixPool.js';\r\nimport { accumulateClosureError } from './utils/solver.js';\r\nimport { mat } from './utils/matrix.js';\r\nimport { getMatrixDifference } from './utils/glmatrix.js';\r\n\r\n// global stores\r\nconst matrixPool = new MatrixPool();\r\n\r\n// temp reusable variables\r\nconst targetRelativeToJointMatrix = new Float64Array( 16 );\r\nconst targetDeltaWorldMatrix = new Float64Array( 16 );\r\nconst tempDeltaWorldMatrix = new Float64Array( 16 );\r\nconst tempInverseMatrixWorld = new Float64Array( 16 );\r\nconst tempQuat = new Float64Array( 4 );\r\nconst tempPos = new Float64Array( 3 );\r\nconst tempQuat2 = new Float64Array( 4 );\r\nconst tempPos2 = new Float64Array( 3 );\r\n\r\nconst targetJoints = [];\r\nconst freeJoints = [];\r\nconst errorResultInfo = {\r\n\trowCount: 0,\r\n\tisConverged: false,\r\n\ttotalError: 0,\r\n};\r\nconst dofResultInfo = {\r\n\terrorRows: 0,\r\n\tfreeDoF: 0,\r\n\ttotalError: 0,\r\n};\r\n\r\nexport const SOLVE_STATUS = {\r\n\r\n\tCONVERGED: 0,\r\n\tSTALLED: 1,\r\n\tDIVERGED: 2,\r\n\tTIMEOUT: 3,\r\n\r\n};\r\n\r\nexport const SOLVE_STATUS_NAMES = Object.entries( SOLVE_STATUS ).sort( ( a, b ) => a[ 1 ] - b[ 1 ] ).map( el => el[ 0 ] );\r\n\r\nexport class ChainSolver {\r\n\r\n\tconstructor( chain ) {\r\n\r\n\t\tthis.chain = Array.from( chain );\r\n\r\n\t\t// list of targets we're trying to minimize in the chain\r\n\t\tthis.targets = null;\r\n\r\n\t\t// map of joint -> closures that the given jointa affects\r\n\t\tthis.affectedClosures = null;\r\n\r\n\t\t// map of joint -> closure children that the given joint affects\r\n\t\tthis.affectedConnectedClosures = null;\r\n\r\n\t\t// map of joint -> that stores the amount of DoF that are locked after\r\n\t\t// hitting a joint limit.\r\n\t\t// Undefined or 0 if none are locked\r\n\t\tthis.lockedJointDoFCount = null;\r\n\r\n\t\t// map of joint -> list of locked DoF\r\n\t\tthis.lockedJointDoF = null;\r\n\r\n\t\t// map of joint -> previous joint angles for resetting joint angles on\r\n\t\t// divergence check.\r\n\t\tthis.prevDoFValues = null;\r\n\r\n\t\t// options -- these are set by the containing Solver.\r\n\t\tthis.maxIterations = - 1;\r\n\r\n\t\tthis.translationConvergeThreshold = - 1;\r\n\t\tthis.rotationConvergeThreshold = - 1;\r\n\r\n\t\tthis.translationFactor = - 1;\r\n\t\tthis.rotationFactor = - 1;\r\n\r\n\t\tthis.translationStep = - 1;\r\n\t\tthis.rotationStep = - 1;\r\n\r\n\t\tthis.translationErrorClamp = - 1;\r\n\t\tthis.rotationErrorClamp = - 1;\r\n\r\n\t\tthis.stallThreshold = - 1;\r\n\t\tthis.dampingFactor = - 1;\r\n\t\tthis.divergeThreshold = - 1;\r\n\t\tthis.restPoseFactor = - 1;\r\n\r\n\t\tthis.init();\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\r\n\t\t// Find all joints with targets.\r\n\t\tconst chain = this.chain;\r\n\t\tconst targets = chain.filter( j => j.targetSet || j.isClosure );\r\n\r\n\t\tconst lockedJointDoF = new Map();\r\n\t\tconst lockedJointDoFCount = new Map();\r\n\t\tconst prevDoFValues = new Map();\r\n\r\n\t\tconst affectedClosures = new Map();\r\n\t\tconst affectedConnectedClosures = new Map();\r\n\t\tchain.forEach( j => {\r\n\r\n\t\t\t// Track which joints will have a direct affect on which targets move\r\n\t\t\t// for closure end effectors.\r\n\t\t\taffectedClosures.set( j, new Set() );\r\n\t\t\taffectedConnectedClosures.set( j, new Set() );\r\n\r\n\t\t\t// Initialize our array with all possible degrees of freedom\r\n\t\t\tlockedJointDoF.set( j, new Uint8Array( 6 ) );\r\n\t\t\tprevDoFValues.set( j, new Float64Array( 6 ) );\r\n\r\n\t\t} );\r\n\r\n\t\ttargets.forEach( target => {\r\n\r\n\t\t\tif ( target.isClosure ) {\r\n\r\n\t\t\t\tlet currJoint = target;\r\n\r\n\t\t\t\t// climb the joint tree and mark every joint as affecting this closure end.\r\n\t\t\t\twhile ( currJoint ) {\r\n\r\n\t\t\t\t\tif ( currJoint.isJoint ) {\r\n\r\n\t\t\t\t\t\taffectedClosures.get( currJoint ).add( target );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrJoint = currJoint.parent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// and mark the joints up the other chain as effecting the other connector link.\r\n\t\t\t\tcurrJoint = target.child;\r\n\t\t\t\twhile ( currJoint ) {\r\n\r\n\t\t\t\t\tif ( currJoint.isJoint ) {\r\n\r\n\t\t\t\t\t\taffectedConnectedClosures.get( currJoint ).add( target );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrJoint = currJoint.parent;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tthis.targets = targets;\r\n\t\tthis.affectedClosures = affectedClosures;\r\n\t\tthis.affectedConnectedClosures = affectedConnectedClosures;\r\n\t\tthis.lockedJointDoF = lockedJointDoF;\r\n\t\tthis.lockedJointDoFCount = lockedJointDoFCount;\r\n\t\tthis.prevDoFValues = prevDoFValues;\r\n\r\n\t}\r\n\r\n\tsolve() {\r\n\r\n\t\tconst {\r\n\t\t\tdivergeThreshold,\r\n\t\t\tstallThreshold,\r\n\t\t\tchain,\r\n\t\t\trestPoseFactor,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t\tprevDoFValues,\r\n\t\t} = this;\r\n\r\n\t\tlet iterations = 0;\r\n\t\tlet prevErrorMagnitude = Infinity;\r\n\t\tlet status = - 1;\r\n\r\n\t\t// Clear out all the locked joints\r\n\t\tlockedJointDoFCount.clear();\r\n\r\n\t\t// TODO: instead of trying to use minimal euler angles we should try to represent joint\r\n\t\t// error as a quaternion in the quaternion vector.\r\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst joint = chain[ i ];\r\n\t\t\tif ( joint.targetSet || joint.restPoseSet ) {\r\n\r\n\t\t\t\tjoint.tryMinimizeEulerAngles();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdo {\r\n\r\n\t\t\tmatrixPool.releaseAll();\r\n\r\n\t\t\t// Make sure our matrices are all up to date\r\n\t\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst joint = chain[ i ];\r\n\t\t\t\tjoint.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: this only needs to be recomputed if a joint was locked so maybe lets check that? We also\r\n\t\t\t// lock joints inside this function so maybe we can forgo that?\r\n\t\t\ttargetJoints.length = 0;\r\n\t\t\tfreeJoints.length = 0;\r\n\t\t\tthis.countUnconvergedVariables( freeJoints, targetJoints, dofResultInfo )\r\n\t\t\tconst { freeDoF, errorRows, totalError } = dofResultInfo;\r\n\r\n\t\t\t// Check if we've converged\r\n\t\t\tif ( errorRows === 0 ) {\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.CONVERGED;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check if we've diverged\r\n\t\t\tif ( totalError > prevErrorMagnitude + divergeThreshold ) {\r\n\r\n\t\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\r\n\r\n\t\t\t\t\tjoint.dofValues.set( dofValues );\r\n\t\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t\t\t} );\r\n\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.DIVERGED;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\t\t\tprevErrorMagnitude = totalError;\r\n\r\n\t\t\t// Check if we've hit max iterations\r\n\t\t\titerations ++;\r\n\t\t\tif ( iterations > this.maxIterations ) {\r\n\r\n\t\t\t\tstatus = SOLVE_STATUS.TIMEOUT;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// A * x = b\r\n\t\t\t// find x such that it yields b where is the clamped error we're trying to work towards\r\n\t\t\t// and A is the jacobian, and x is the delta joint angles.\r\n\r\n\t\t\tconst errorVector = matrixPool.get( errorRows, 1 );\r\n\t\t\tthis.fillErrorVector( targetJoints, errorVector );\r\n\r\n\t\t\tconst jacobian = matrixPool.get( errorRows, freeDoF );\r\n\t\t\tthis.fillJacobian( targetJoints, freeJoints, jacobian );\r\n\r\n\t\t\t// TODO: try to solve with SVD method -- do we really need to? Why not just always use the transpose method?\r\n\r\n\t\t\t// Use a transpose pseudo inverse approach: A^T * A * x = A^T * b with the damping term\r\n\t\t\t// J^T * J * x = J^T * e\r\n\t\t\t// x = J^T * ( J * J^T )^-1 * e\r\n\r\n\t\t\t// and with the adding damping\r\n\t\t\t// x = J^T * ( J * J^T + l^2 * I )^-1 * e\r\n\r\n\t\t\t// l^2 * I\r\n\t\t\tconst jacobianIdentityDamping = matrixPool.get( errorRows, errorRows );\r\n\t\t\tmat.identity( jacobianIdentityDamping );\r\n\t\t\tmat.scale( jacobianIdentityDamping, jacobianIdentityDamping, this.dampingFactor ** 2 );\r\n\r\n\t\t\t// J^T\r\n\t\t\tconst jacobianTranspose = matrixPool.get( freeDoF, errorRows );\r\n\t\t\tmat.transpose( jacobianTranspose, jacobian );\r\n\r\n\t\t\t// J * J^T\r\n\t\t\tconst jjt = matrixPool.get( errorRows, errorRows );\r\n\t\t\tmat.multiply( jjt, jacobian, jacobianTranspose );\r\n\r\n\t\t\t// J * J^T + l^2 * I\r\n\t\t\tconst jjti = matrixPool.get( errorRows, errorRows );\r\n\t\t\tmat.add( jjti, jjt, jacobianIdentityDamping );\r\n\r\n\t\t\t// ( J * J^T + l^2 * I )^-1\r\n\t\t\tconst jjtii = matrixPool.get( errorRows, errorRows );\r\n\t\t\tmat.invert( jjtii, jjti );\r\n\r\n\t\t\t// J^T * ( J * J^T + l^2 * I )^-1\r\n\t\t\tconst pseudoInverse = matrixPool.get( freeDoF, errorRows );\r\n\t\t\tmat.multiply( pseudoInverse, jacobianTranspose, jjtii );\r\n\r\n\t\t\t// x = deltaTheta = J^T * ( J * J^T + l^2 * I )^-1 * e\r\n\t\t\tconst deltaTheta = matrixPool.get( freeDoF, 1 );\r\n\t\t\tmat.multiply( deltaTheta, pseudoInverse, errorVector );\r\n\r\n\t\t\t// console.log( 'ERROR VECTOR', errorVector );\r\n\t\t\t// console.log( 'JACOBIAN', jacobian );\r\n\t\t\t// console.log( 'DELTA_THETA', deltaTheta );\r\n\r\n\t\t\tif ( restPoseFactor !== 0 ) {\r\n\r\n\t\t\t\t// Nullspace Projection\r\n\t\t\t\t// I - J^-1 * J is the orthogonal null space of J where J^-1 is the pseudoinverse\r\n\t\t\t\t// Multiplied by the rest position of each dof\r\n\t\t\t\t// ( I - J^-1 * J ) * restPose\r\n\t\t\t\tconst restPose = matrixPool.get( freeDoF, 1 );\r\n\t\t\t\tconst restPoseResult = matrixPool.get( freeDoF, 1 );\r\n\t\t\t\tlet colIndex = 0;\r\n\t\t\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst joint = freeJoints[ i ];\r\n\t\t\t\t\tconst lockedDoFCount = this.lockedJointDoFCount.get( joint ) || 0;\r\n\t\t\t\t\tconst isLocked = lockedDoFCount !== 0;\r\n\t\t\t\t\tconst lockedDoF = this.lockedJointDoF.get( joint );\r\n\r\n\t\t\t\t\tconst colCount = joint.rotationDoFCount + joint.translationDoFCount - lockedDoFCount;\r\n\t\t\t\t\tif ( joint.restPoseSet ) {\r\n\r\n\t\t\t\t\t\tconst dofList = joint.dof;\r\n\t\t\t\t\t\tconst dofValues = joint.dofValues;\r\n\t\t\t\t\t\tconst dofRestPose = joint.dofRestPose;\r\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\r\n\r\n\t\t\t\t\t\t\t// NOTE: this is reversed because in applyAngles we're having to negate the\r\n\t\t\t\t\t\t\t// delta angles for some reason atm\r\n\t\t\t\t\t\t\tconst dof = dofList[ d ];\r\n\r\n\t\t\t\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) continue;\r\n\r\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = dofValues[ dof ] - dofRestPose[ dof ];\r\n\t\t\t\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tfor ( let d = 0; d < colCount; d ++ ) {\r\n\r\n\t\t\t\t\t\t\trestPose[ colIndex ][ 0 ] = 0;\r\n\t\t\t\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// J^-1 * J\r\n\t\t\t\tconst jij = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.multiply( jij, pseudoInverse, jacobian );\r\n\r\n\t\t\t\t// ( I - J^-1 * J )\r\n\t\t\t\tconst jiji = matrixPool.get( freeDoF, freeDoF );\r\n\t\t\t\tmat.identity( jiji );\r\n\t\t\t\tmat.subtract( jiji, jiji, jij );\r\n\r\n\t\t\t\t// ( I - J^-1 * J ) * restPose\r\n\t\t\t\tmat.multiply( restPoseResult, jiji, restPose );\r\n\r\n\t\t\t\tfor ( let r = 0; r < freeDoF; r ++ ) {\r\n\r\n\t\t\t\t\tdeltaTheta[ r ][ 0 ] += restPose[ r ][ 0 ] * restPoseFactor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check if our joints have not moved and returned stalled\r\n\t\t\tif ( stallThreshold > 0 ) {\r\n\r\n\t\t\t\tlet stalled = true;\r\n\t\t\t\tfor ( let i = 0, l = deltaTheta.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst delta = deltaTheta[ i ][ 0 ];\r\n\t\t\t\t\tif ( Math.abs( delta ) > stallThreshold ) {\r\n\r\n\t\t\t\t\t\tstalled = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( stalled ) {\r\n\r\n\t\t\t\t\tstatus = SOLVE_STATUS.STALLED;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Prep for a divergence check\r\n\t\t\tprevDoFValues.forEach( ( dofValues, joint ) => {\r\n\r\n\t\t\t\tdofValues.set( joint.dofValues );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\t// apply the latest joint angles and lock and joints that have\r\n\t\t\t// hit their joint limits.\r\n\t\t\tthis.applyJointAngles( freeJoints, deltaTheta );\r\n\r\n\t\t\t// there's still error and we're under the max iterations\r\n\t\t} while( true );\r\n\r\n\t\ttargetJoints.length = 0;\r\n\t\tfreeJoints.length = 0;\r\n\t\treturn status;\r\n\r\n\t}\r\n\r\n\t// Apply the delta values from the solve to the free joints in the list\r\n\tapplyJointAngles( freeJoints, deltaTheta ) {\r\n\r\n\t\tconst {\r\n\t\t\tlockedJointDoF,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t} = this;\r\n\r\n\t\tlet lockedJoint = false;\r\n\t\tlet dti = 0;\r\n\t\tfor ( let i = 0, l = freeJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\t// Apply the delta to every free joint\r\n\t\t\tconst joint = freeJoints[ i ];\r\n\t\t\tconst dofList = joint.dof;\r\n\t\t\tconst lockedDoF = lockedJointDoF.get( joint );\r\n\t\t\tconst isLocked = lockedJointDoFCount.has( joint );\r\n\r\n\t\t\tfor ( let d = 0, l = dofList.length; d < l; d ++ ) {\r\n\r\n\t\t\t\tconst dof = dofList[ d ];\r\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: why are we negating here?\r\n\t\t\t\tconst value = joint.getDoFValue( dof )\r\n\t\t\t\tconst hitLimit = joint.setDoFValue( dof, value - deltaTheta[ dti ][ 0 ] );\r\n\r\n\t\t\t\t// lock the joint if we hit a limit\r\n\t\t\t\tif ( hitLimit ) {\r\n\r\n\t\t\t\t\tif ( ! lockedJointDoFCount.has( joint ) ) {\r\n\r\n\t\t\t\t\t\tlockedJointDoFCount.set( joint, 0 );\r\n\t\t\t\t\t\tlockedDoF.fill( 0 );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst lockedCount = lockedJointDoFCount.get( joint );\r\n\t\t\t\t\tlockedJointDoFCount.set( joint, lockedCount + 1 );\r\n\t\t\t\t\tlockedDoF[ dof ] = 1;\r\n\t\t\t\t\tlockedJoint = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dti !== deltaTheta.length ) {\r\n\r\n\t\t\tthrow new Error();\r\n\r\n\t\t}\r\n\r\n\t\treturn lockedJoint;\r\n\r\n\t}\r\n\r\n\t// generate the jacobian\r\n\t// The jacobian has one column for each free degree of freedom and a row for every\r\n\t// target degree of freedom we have. The entries are generated by adjusting every\r\n\t// DoF by some epsilon and storing how much it affected the target error.\r\n\tfillJacobian( targetJoints, freeJoints, outJacobian ) {\r\n\r\n\t\tconst {\r\n\t\t\ttranslationStep,\r\n\t\t\trotationStep,\r\n\t\t\tlockedJointDoF,\r\n\t\t\tlockedJointDoFCount,\r\n\t\t\ttranslationFactor,\r\n\t\t\trotationFactor,\r\n\t\t} = this;\r\n\r\n\t\t// TODO: abstract this\r\n\t\tconst affectedClosures = this.affectedClosures;\r\n\t\tconst affectedConnectedClosures = this.affectedConnectedClosures;\r\n\r\n\t\tlet colIndex = 0;\r\n\t\tfor ( let c = 0, tc = freeJoints.length; c < tc; c ++ ) {\r\n\r\n\t\t\t// TODO: If this is a goal we should skip adding it to the jacabian columns\r\n\t\t\tconst freeJoint = freeJoints[ c ];\r\n\t\t\tconst relevantClosures = affectedClosures.get( freeJoint );\r\n\t\t\tconst relevantConnectedClosures = affectedConnectedClosures.get( freeJoint );\r\n\t\t\tconst dofList = freeJoint.dof;\r\n\t\t\tconst colCount = freeJoint.translationDoFCount + freeJoint.rotationDoFCount;\r\n\r\n\t\t\tconst isLocked = lockedJointDoFCount.has( freeJoint );\r\n\t\t\tconst lockedDoF = lockedJointDoF.get( freeJoint );\r\n\r\n\t\t\t// get the world inverse of the free joint\r\n\t\t\tmat4.invert( tempInverseMatrixWorld, freeJoint.matrixWorld );\r\n\r\n\t\t\t// iterate over every degree of freedom in the joint\r\n\t\t\tfor ( let co = 0; co < colCount; co ++ ) {\r\n\r\n\t\t\t\tconst dof = dofList[ co ];\r\n\r\n\t\t\t\t// skip this joint if it's locked\r\n\t\t\t\tif ( isLocked && lockedDoF[ dof ] ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rowIndex = 0;\r\n\r\n\t\t\t\t// generate the adjusted matrix based on the epsilon for the joint.\r\n\t\t\t\tlet delta = dof < 3 ? translationStep : rotationStep;\r\n\t\t\t\tif ( freeJoint.getDeltaWorldMatrix( dof, delta, tempDeltaWorldMatrix ) ) {\r\n\r\n\t\t\t\t\tdelta *= - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Iterate over every target\r\n\t\t\t\tfor ( let r = 0, tr = targetJoints.length; r < tr; r ++ ) {\r\n\r\n\t\t\t\t\tconst targetJoint = targetJoints[ r ];\r\n\r\n\t\t\t\t\t// if it's a closure target\r\n\t\t\t\t\tif ( targetJoint.isClosure ) {\r\n\r\n\t\t\t\t\t\tif ( relevantClosures.has( targetJoint ) || relevantConnectedClosures.has( targetJoint ) ) {\r\n\r\n\t\t\t\t\t\t\t// TODO: If this is a Goal it only add 1 or 2 fields if only two axes are set. Quat is only\r\n\t\t\t\t\t\t\t// needed if 3 eulers are used.\r\n\t\t\t\t\t\t\t// TODO: these could be cached per target joint get the current error within the closure joint\r\n\r\n\t\t\t\t\t\t\t// Get the error from child towards the closure target\r\n\t\t\t\t\t\t\ttargetJoint.getClosureError( tempPos, tempQuat );\r\n\t\t\t\t\t\t\tif ( relevantConnectedClosures.has( targetJoint ) ) {\r\n\r\n\t\t\t\t\t\t\t\t// If this is affecting a link connected to a closure joint then adjust that child link by\r\n\t\t\t\t\t\t\t\t// the delta rotation.\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.child.matrixWorld );\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\r\n\r\n\t\t\t\t\t\t\t\t// Get the new error\r\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetJoint.matrixWorld, targetDeltaWorldMatrix, tempPos2, tempQuat2 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// If this is directly affecting a closure joint then adjust that child link by the delta\r\n\t\t\t\t\t\t\t\t// rotation.\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetRelativeToJointMatrix, tempInverseMatrixWorld, targetJoint.matrixWorld );\r\n\t\t\t\t\t\t\t\tmat4.multiply( targetDeltaWorldMatrix, tempDeltaWorldMatrix, targetRelativeToJointMatrix );\r\n\r\n\t\t\t\t\t\t\t\t// Get the new error\r\n\t\t\t\t\t\t\t\tgetMatrixDifference( targetDeltaWorldMatrix, targetJoint.child.matrixWorld, tempPos2, tempQuat2 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Get the amount that the rotation and translation error changed due to the\r\n\t\t\t\t\t\t\t// small DoF adjustment to serve as the derivative.\r\n\t\t\t\t\t\t\tvec3.subtract( tempPos, tempPos2, tempPos );\r\n\t\t\t\t\t\t\tvec3.scale( tempPos, tempPos, translationFactor / delta );\r\n\r\n\t\t\t\t\t\t\tvec4.subtract( tempQuat, tempQuat2, tempQuat );\r\n\t\t\t\t\t\t\tvec4.scale( tempQuat, tempQuat, rotationFactor / delta );\r\n\r\n\t\t\t\t\t\t\tif ( targetJoint.isGoal ) {\r\n\r\n\t\t\t\t\t\t\t\tconst { translationDoFCount, rotationDoFCount, dof } = targetJoint;\r\n\t\t\t\t\t\t\t\tfor ( let i = 0; i < translationDoFCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst d = dof[ i ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = tempPos[ d ];\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif ( rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 0 ][ colIndex ] = tempQuat[ 0 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 1 ][ colIndex ] = tempQuat[ 1 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 2 ][ colIndex ] = tempQuat[ 2 ];\r\n\t\t\t\t\t\t\t\t\toutJacobian[ rowIndex + translationDoFCount + 3 ][ colIndex ] = tempQuat[ 3 ];\r\n\t\t\t\t\t\t\t\t\trowIndex += 4;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\trowIndex += translationDoFCount;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// set translation\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 0 ][ colIndex ] = tempPos[ 0 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 1 ][ colIndex ] = tempPos[ 1 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 2 ][ colIndex ] = tempPos[ 2 ];\r\n\r\n\t\t\t\t\t\t\t\t// set rotation\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 3 ][ colIndex ] = tempQuat[ 0 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 4 ][ colIndex ] = tempQuat[ 1 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 5 ][ colIndex ] = tempQuat[ 2 ];\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + 6 ][ colIndex ] = tempQuat[ 3 ];\r\n\t\t\t\t\t\t\t\trowIndex += 7;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// if the target isn't relevant then there's no delta\r\n\t\t\t\t\t\t\tlet totalRows = 7;\r\n\t\t\t\t\t\t\tif ( targetJoint.isGoal  ) {\r\n\r\n\t\t\t\t\t\t\t\ttotalRows = targetJoint.translationDoFCount;\r\n\t\t\t\t\t\t\t\tif ( targetJoint.rotationDoFCount === 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttotalRows += 4;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < totalRows; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\trowIndex += totalRows;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Check if this joint has a target set and update the jacobian rows if it does\r\n\t\t\t\t\tif ( targetJoint.targetSet ) {\r\n\r\n\t\t\t\t\t\tconst rowCount = targetJoint.translationDoFCount + targetJoint.rotationDoFCount;\r\n\r\n\t\t\t\t\t\tif ( freeJoint === targetJoint ) {\r\n\r\n\t\t\t\t\t\t\t// if we're just dealing with a target dof joint then there can't be any influence\r\n\t\t\t\t\t\t\t// but otherwise the only joint that can have an effect on this error is the joint\r\n\t\t\t\t\t\t\t// itself.\r\n\t\t\t\t\t\t\t// TODO: Having noted that is this really necessary? Is there any way that this doesn't just\r\n\t\t\t\t\t\t\t// jump to the solution and lock? How can we afford some slack? With a low weight? Does that\r\n\t\t\t\t\t\t\t// get applied here?\r\n\t\t\t\t\t\t\t// TODO: If this joint happens to have three euler joints we need to use a quat here. Otherwise we\r\n\t\t\t\t\t\t\t// use the euler angles.\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + colIndex ][ colIndex ] = - 1;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < rowCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\toutJacobian[ rowIndex + i ][ colIndex ] = 0;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\trowIndex += rowCount;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolIndex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( colIndex !== outJacobian[ 0 ].length ) {\r\n\r\n\t\t\tthrow new Error();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Fill in the error vector\r\n\tfillErrorVector( targetJoints, errorVector ) {\r\n\r\n\t\tlet rowIndex = 0;\r\n\t\tfor ( let i = 0, l = targetJoints.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst joint = targetJoints[ i ];\r\n\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\taccumulateClosureError( this, joint, rowIndex, errorVector, errorResultInfo );\r\n\t\t\t\trowIndex += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\taccumulateTargetError( this, joint, rowIndex, errorVector, errorResultInfo );\r\n\t\t\t\trowIndex += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Count the unconverged targets in the chain and store them in targetJoints and store\r\n\t// any freeJoints in\r\n\tcountUnconvergedVariables( freeJoints, targetJoints, dofResultInfo ) {\r\n\r\n\t\tconst { lockedJointDoFCount } = this;\r\n\r\n\t\tconst chain = this.chain;\r\n\t\tlet totalError = 0;\r\n\t\tlet errorRows = 0;\r\n\t\tlet unconvergedRows = 0;\r\n\t\tlet freeDoF = 0;\r\n\t\tfor ( let i = 0, l = chain.length; i < l; i ++ ) {\r\n\r\n\t\t\tlet addToTargetList = false;\r\n\t\t\tconst joint = chain[ i ];\r\n\t\t\tconst lockedDoF = lockedJointDoFCount.get( joint ) || 0;\r\n\r\n\t\t\t// TODO: Should we check every variable against the convergence threshold or is\r\n\t\t\t// it better to check the magnitude?\r\n\r\n\t\t\t// TODO: We may be able to speed this up by using the square distance and length\r\n\t\t\t// to compare error.\r\n\r\n\t\t\t// TODO: If this is a goal we shouldnt add to the free dof because they won't be added\r\n\t\t\t// to the jacobian\r\n\r\n\t\t\t// If this is a closure joint then we need to make sure we're solving\r\n\t\t\t// for the other child end to meet this joint so this error is important.\r\n\t\t\tif ( joint.isClosure ) {\r\n\r\n\t\t\t\taccumulateClosureError( this, joint, errorRows, null, errorResultInfo );\r\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\r\n\r\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\r\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\r\n\r\n\t\t\t\t}\r\n\t\t\t\taddToTargetList = true;\r\n\t\t\t\terrorRows += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check out far the joint is from the target dof value.\r\n\t\t\tconst dofList = joint.dof;\r\n\t\t\tif ( joint.targetSet ) {\r\n\r\n\t\t\t\taccumulateTargetError( this, joint, errorRows, null, errorResultInfo );\r\n\t\t\t\tif ( ! errorResultInfo.isConverged ) {\r\n\r\n\t\t\t\t\tunconvergedRows += errorResultInfo.rowCount;\r\n\t\t\t\t\ttotalError += errorResultInfo.totalError;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddToTargetList = true;\r\n\t\t\t\terrorRows += errorResultInfo.rowCount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! joint.isGoal ) {\r\n\r\n\t\t\t\tfreeDoF += dofList.length - lockedDoF;\r\n\t\t\t\tfreeJoints.push( joint );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( addToTargetList ) {\r\n\r\n\t\t\t\ttargetJoints.push( joint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// if it turns out that everything is converged.\r\n\t\tif ( unconvergedRows === 0 ) {\r\n\r\n\t\t\terrorRows = 0;\r\n\r\n\t\t}\r\n\r\n\t\tdofResultInfo.errorRows = errorRows;\r\n\t\tdofResultInfo.freeDoF = freeDoF;\r\n\t\tdofResultInfo.totalError = totalError;\r\n\r\n\t}\r\n\r\n}\r\n","import { ChainSolver } from './ChainSolver.js';\n\nexport class Solver {\n\n\tconstructor( roots = [] ) {\n\n\t\tthis.maxIterations = 5;\n\t\tthis.stallThreshold = 1e-4;\n\t\tthis.dampingFactor = 0.001;\n\t\tthis.divergeThreshold = 0.01;\n\t\tthis.restPoseFactor = 0.01;\n\n\t\tthis.translationConvergeThreshold = 1e-3;\n\t\tthis.rotationConvergeThreshold = 1e-5;\n\n\t\tthis.translationFactor = 1;\n\t\tthis.rotationFactor = 1;\n\n\t\tthis.translationStep = 1e-3;\n\t\tthis.rotationStep = 1e-3;\n\n\t\tthis.translationErrorClamp = 0.1;\n\t\tthis.rotationErrorClamp = 0.1;\n\n\t\tthis.roots = Array.isArray( roots ) ? [ ...roots ] : [ roots ];\n\t\tthis.solvers = null;\n\n\t\tthis.updateStructure();\n\n\t}\n\n\t// needs to be called whenever tree structure is updated\n\tupdateStructure() {\n\n\t\tconst roots = this.roots;\n\t\tconst chains = [];\n\t\tconst traversal = new Set();\n\t\tconst allChainJoints = new Set();\n\t\tconst traverseChains = frame => {\n\n\t\t\t// If we found a joint then add it to the traversal list\n\t\t\tif ( frame.isJoint ) {\n\n\t\t\t\tconst joint = frame;\n\t\t\t\ttraversal.add( joint );\n\n\t\t\t\t// If we found a closure joint\n\t\t\t\tif ( joint.isClosure ) {\n\n\t\t\t\t\t// Traverse back up the tree until we find a common ancestor\n\t\t\t\t\t// and create a new chain\n\t\t\t\t\tconst chainSet = new Set();\n\t\t\t\t\tlet curr = joint.child;\n\t\t\t\t\twhile ( curr ) {\n\n\t\t\t\t\t\tif ( curr.isJoint ) {\n\n\t\t\t\t\t\t\tif ( traversal.has( curr ) ) {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tchainSet.add( curr );\n\t\t\t\t\t\t\t\tallChainJoints.add( curr );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurr = curr.parent;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttraversal.forEach( c => {\n\n\t\t\t\t\t\tchainSet.add( c )\n\t\t\t\t\t\tallChainJoints.add( c );\n\n\t\t\t\t\t} );\n\t\t\t\t\tchains.push( chainSet );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Continue traversing\n\t\t\tconst children = frame.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\ttraverseChains( children[ i ] );\n\n\t\t\t}\n\n\t\t\t// Remove the joint from our traversal set\n\t\t\ttraversal.delete( frame );\n\n\t\t};\n\n\t\t// find all chains in the roots\n\t\troots.forEach( traverseChains );\n\n\t\t// Merge interdependent chains\n\t\tconst independentChains = [];\n\t\twhile ( chains.length ) {\n\n\t\t\tconst currChain = chains.pop();\n\t\t\tindependentChains.push( currChain );\n\t\t\tfor ( let i = 0; i < chains.length; i ++ ) {\n\n\t\t\t\t// see if this chain is dependent on the current chain\n\t\t\t\t// and if so merge the chains.\n\t\t\t\tconst otherChain = chains[ i ];\n\n\t\t\t\tlet dependent = false;\n\t\t\t\totherChain.forEach( c => {\n\n\t\t\t\t\tdependent = dependent || currChain.has( c );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( dependent ) {\n\n\t\t\t\t\totherChain.forEach( c => currChain.add( c ) );\n\t\t\t\t\tchains.splice( i, 1 );\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Find any joints that aren't considered part of a solve chain so we\n\t\t// can just update them using forward kinematics.\n\t\tconst nonChainJoints = new Set();\n\t\troots.forEach( root => root.traverse( c => {\n\n\t\t\tif ( c.isJoint && c.dof.length > 0 && ! allChainJoints.has( c ) ) {\n\n\t\t\t\tnonChainJoints.add( c );\n\n\t\t\t}\n\n\t\t} ) );\n\n\t\t// Create the solvers for the chains\n\t\tthis.solvers = independentChains.map( c => new ChainSolver( c ) );\n\t\tthis.nonChainJoints = nonChainJoints;\n\n\t}\n\n\tsolve() {\n\n\t\tconst { solvers, nonChainJoints } = this;\n\n\t\t// update any non chain joints\n\t\tnonChainJoints.forEach( joint => {\n\n\t\t\tif ( joint.targetSet ) {\n\n\t\t\t\tjoint.dofValues.set( joint.dofTarget );\n\t\t\t\tjoint.setMatrixDoFNeedsUpdate();\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst results = [];\n\t\tfor ( let i = 0, l = solvers.length; i < l; i ++ ) {\n\n\t\t\tconst s = solvers[ i ];\n\t\t\ts.maxIterations = this.maxIterations;\n\t\t\ts.stallThreshold = this.stallThreshold;\n\t\t\ts.dampingFactor = this.dampingFactor;\n\t\t\ts.divergeThreshold = this.divergeThreshold;\n\t\t\ts.restPoseFactor = this.restPoseFactor;\n\n\t\t\ts.translationConvergeThreshold = this.translationConvergeThreshold;\n\t\t\ts.rotationConvergeThreshold = this.rotationConvergeThreshold;\n\n\t\t\ts.translationFactor = this.translationFactor;\n\t\t\ts.rotationFactor = this.rotationFactor;\n\n\t\t\ts.translationStep = this.translationStep;\n\t\t\ts.rotationStep = this.rotationStep;\n\n\t\t\ts.translationErrorClamp = this.translationErrorClamp;\n\t\t\ts.rotationErrorClamp = this.rotationErrorClamp;\n\n\t\t\tconst result = s.solve();\n\t\t\tresults.push( result );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n}\n","import { Joint, DOF } from './Joint.js';\n\nexport class Goal extends Joint {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.isGoal = true;\n\t\tthis.setFreeDoF();\n\n\t}\n\n\tsetDoF( ...args ) {\n\n\t\t// We don't support rotation goals that only specify 1 or 2 free rotation axes.\n\t\tlet rotCount =\n\t\t\tNumber( args.includes( DOF.EX ) ) +\n\t\t\tNumber( args.includes( DOF.EY ) ) +\n\t\t\tNumber( args.includes( DOF.EZ ) );\n\n\t\tif ( rotCount !== 0 && rotCount !== 3 ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t\tsuper.setDoF( ...args );\n\n\t}\n\n\tsetGoalDoF( ...args ) {\n\n\t\tthis.setDoF( ...args );\n\n\t}\n\n\tsetFreeDoF( ...args ) {\n\n\t\tconst freeDoF = [\n\t\t\tDOF.X, DOF.Y, DOF.Z,\n\t\t\tDOF.EX, DOF.EY, DOF.EZ,\n\t\t].filter( d => ! args.includes( d ) );\n\t\tthis.setDoF( ...freeDoF );\n\n\t}\n\n\taddChild() {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n","import { Joint } from '../core/Joint.js';\r\nimport { Link } from '../core/Link.js';\r\nimport { Goal } from '../core/Goal.js';\r\n\r\n// Takes a list of interconnected frames and serializes them into a non cyclic json representation\r\nexport function serialize( frames ) {\r\n\r\n\tconst map = new Map();\r\n\tconst info = [];\r\n\r\n\t// Create the initial frame list along with a joint -> index map\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tconst frame = frames[ i ];\r\n\r\n\t\tconst {\r\n\t\t\tname,\r\n\t\t\tdof,\r\n\t\t\tdofValues,\r\n\t\t\tdofTarget,\r\n\t\t\tdofRestPose,\r\n\t\t\tminDoFLimit,\r\n\t\t\tmaxDoFLimit,\r\n\t\t\ttargetSet,\r\n\t\t\trestPoseSet,\r\n\t\t\tposition,\r\n\t\t\tquaternion,\r\n\t\t\tisClosure,\r\n\t\t} = frame;\r\n\r\n\t\tlet type = 'Link';\r\n\t\tif ( frame.isGoal ) {\r\n\r\n\t\t\ttype = 'Goal';\r\n\r\n\t\t} else if ( frame.isJoint ) {\r\n\r\n\t\t\ttype = 'Joint';\r\n\r\n\t\t}\r\n\r\n\t\tconst res = {\r\n\t\t\tdof: dof ? dof.slice() : null,\r\n\t\t\tdofValues: dofValues ? dofValues.slice() : null,\r\n\t\t\tdofTarget: dofTarget ? dofTarget.slice() : null,\r\n\t\t\tdofRestPose: dofRestPose ? dofRestPose.slice() : null,\r\n\t\t\tminDoFLimit: minDoFLimit ? minDoFLimit.slice() : null,\r\n\t\t\tmaxDoFLimit: maxDoFLimit ? maxDoFLimit.slice() : null,\r\n\t\t\ttargetSet,\r\n\t\t\trestPoseSet,\r\n\t\t\tisClosure,\r\n\r\n\t\t\tname,\r\n\t\t\tposition: position.slice(),\r\n\t\t\tquaternion: quaternion.slice(),\r\n\t\t\tchildren: null,\r\n\t\t\ttype,\r\n\t\t};\r\n\r\n\t\tinfo.push( res );\r\n\t\tmap.set( frame, i );\r\n\r\n\t}\r\n\r\n\t// Create the child and parent index references.\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tconst inf = info[ i ];\r\n\t\tconst frame = frames[ i ];\r\n\t\tinf.children = frame.children.map( c => map.get( c ) );\r\n\r\n\t\tif ( frame.parent ) {\r\n\r\n\t\t\tinf.parent = map.get( frame.parent );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinf.parent = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn info;\r\n\r\n}\r\n\r\n// Deserialize the serialized representation of the graph\r\nexport function deserialize( data ) {\r\n\r\n\t// Create joints / links for every serialized version\r\n\tconst frames =\r\n\t\tdata.map( d => {\r\n\r\n\t\t\tconst {\r\n\t\t\t\ttype,\r\n\t\t\t\tname,\r\n\t\t\t\tposition,\r\n\t\t\t\tquaternion,\r\n\r\n\t\t\t\tdof,\r\n\t\t\t\tdofValues,\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t\ttargetSet,\r\n\t\t\t\trestPoseSet,\r\n\t\t\t\tisClosure,\r\n\t\t\t} = d;\r\n\r\n\t\t\tlet frame;\r\n\t\t\tswitch ( type ) {\r\n\t\t\t\tcase 'Goal':\r\n\t\t\t\tcase 'Joint':\r\n\t\t\t\t\tframe = type === 'Goal' ? new Goal() : new Joint();\r\n\r\n\t\t\t\t\tframe.setDoF( ...dof );\r\n\t\t\t\t\tframe.dofValues.set( dofValues );\r\n\t\t\t\t\tframe.dofTarget.set( dofTarget );\r\n\t\t\t\t\tframe.dofRestPose.set( dofRestPose );\r\n\t\t\t\t\tframe.minDoFLimit.set( minDoFLimit );\r\n\t\t\t\t\tframe.maxDoFLimit.set( maxDoFLimit );\r\n\r\n\t\t\t\t\tframe.targetSet = targetSet;\r\n\t\t\t\t\tframe.restPoseSet = restPoseSet;\r\n\t\t\t\t\tframe.isClosure = isClosure;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'Link':\r\n\t\t\t\t\tframe = new Link();\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tframe.name = name;\r\n\t\t\tframe.position.set( position );\r\n\t\t\tframe.quaternion.set( quaternion );\r\n\t\t\treturn frame;\r\n\r\n\t\t} );\r\n\r\n\t// set the parent and child from the maps\r\n\tfor ( let i = 0; i < frames.length; i ++ ) {\r\n\r\n\t\tconst frame = frames[ i ];\r\n\t\tconst info = data[ i ];\r\n\r\n\t\tframe.parent = frames[ info.parent ] || null;\r\n\t\tframe.children.push( ...info.children.map( i => frames[ i ] ) );\r\n\t\tframe.setMatrixNeedsUpdate();\r\n\r\n\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\tframe.child = frame.children[ 0 ] || null;\r\n\t\t\tframe.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn frames;\r\n\r\n}\r\n","export const JOINT_STRIDE = 304;\r\n\r\nexport const LINK_STRIDE = 56;\r\n\r\nexport function generateSharedBuffer( frames ) {\r\n\r\n\t// dofValues \t6 * 4\r\n\t// dofTarget \t6 * 4\r\n\t// dofRestPose \t6 * 4\r\n\t// minDoFLimit \t6 * 4\r\n\t// maxDoFLimit \t6 * 4\r\n\t// position \t3 * 4\r\n\t// quaternion \t4 * 4\r\n\t// targetSet \t1\r\n\t// restPoseSet \t1\r\n\t// --\r\n\t// total  \t\t150 bytes per joint\r\n\t// 4 byte aligned: 152\r\n\r\n\tconst arrayBuffer = new SharedArrayBuffer( JOINT_STRIDE * frames.length );\r\n\tconst float64 = new Float32Array( arrayBuffer );\r\n\tconst byte8 = new Uint8Array( arrayBuffer );\r\n\tapplyToBuffer( frames, float64, byte8 );\r\n\treturn arrayBuffer;\r\n\r\n}\r\n\r\nexport function applyToBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyFrameToBuffer( frames[ i ], floatBuffer, byteBuffer, i * JOINT_STRIDE, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function applyFromBuffer( frames, floatBuffer, byteBuffer, copyDoFValues = true, copyJointSettings = true  ) {\r\n\r\n\tfor ( let i = 0, l = frames.length; i < l; i ++ ) {\r\n\r\n\t\tcopyBufferToFrame( frames[ i ], floatBuffer, byteBuffer, JOINT_STRIDE * i, copyDoFValues, copyJointSettings );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the frame to the given buffer starting at the given byte offset. Joints take JOINT_STRIDE\r\n// bytes while links take LINK_STRIDE bytes.\r\nexport function copyFrameToBuffer(\r\n\tframe,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tconst {\r\n\t\t\tposition,\r\n\t\t\tquaternion,\r\n\t\t} = frame;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 0 + i ] = position[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 3 + i ] = quaternion[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t\ttargetSet,\r\n\t\t\t\trestPoseSet,\r\n\t\t\t} = frame;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 0 * 6 + i ] = dofTarget[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 1 * 6 + i ] = dofRestPose[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 2 * 6 + i ] = minDoFLimit[ i ];\r\n\t\t\t\tfloatBuffer[ floatOffset + 7 + 3 * 6 + i ] = maxDoFLimit[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteBuffer[ byteOffset + 148 ] = Number( targetSet );\r\n\t\t\tbyteBuffer[ byteOffset + 149 ] = Number( restPoseSet );\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && frame.isJoint ) {\r\n\r\n\t\tconst { dofValues } = frame;\r\n\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloatBuffer[ floatOffset + 7 + 4 * 6 + i ] = dofValues[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Copy data from the given buffer to the given frame starting at the given byte offset.\r\nexport function copyBufferToFrame(\r\n\tjoint,\r\n\tfloatBuffer,\r\n\tbyteBuffer,\r\n\tbyteOffset,\r\n\tcopyDoFValues = true,\r\n\tcopyJointSettings = true,\r\n) {\r\n\r\n\tconst floatOffset = byteOffset / 4;\r\n\r\n\tif ( copyJointSettings ) {\r\n\r\n\t\tjoint.setPosition(\r\n\t\t\tfloatBuffer[ floatOffset + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 2 ],\r\n\t\t);\r\n\t\tjoint.setQuaternion(\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 0 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 1 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 2 ],\r\n\t\t\tfloatBuffer[ floatOffset + 3 + 3 ],\r\n\t\t);\r\n\r\n\t\tif ( joint.isJoint ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tdofTarget,\r\n\t\t\t\tdofRestPose,\r\n\t\t\t\tminDoFLimit,\r\n\t\t\t\tmaxDoFLimit,\r\n\t\t\t} = joint;\r\n\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tdofTarget[ i ] = floatBuffer[ floatOffset + 7 + 0 * 6 + i ];\r\n\t\t\t\tdofRestPose[ i ] = floatBuffer[ floatOffset + 7 + 1 * 6 + i ];\r\n\t\t\t\tminDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 2 * 6 + i ];\r\n\t\t\t\tmaxDoFLimit[ i ] = floatBuffer[ floatOffset + 7 + 3 * 6 + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tjoint.targetSet = Boolean( byteBuffer[ byteOffset + 148 ] );\r\n\t\t\tjoint.restPoseSet = Boolean( byteBuffer[ byteOffset + 149 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( copyDoFValues && joint.isJoint ) {\r\n\r\n\t\tconst { dofValues } = joint;\r\n\t\tlet changed = false;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tconst v = floatBuffer[ floatOffset + 7 + 4 * 6 + i ];\r\n\t\t\tif ( v !== dofValues[ i ] ) {\r\n\r\n\t\t\t\tdofValues[ i ] = v;\r\n\t\t\t\tchanged = true;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t\t// only update dof matrix if it changed\r\n\t\tif ( changed ) {\r\n\r\n\t\t\tjoint.setMatrixDoFNeedsUpdate();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { Solver } from '../core/Solver.js';\nimport { SOLVE_STATUS } from '../core/ChainSolver.js';\nimport { deserialize } from './serialize.js';\nimport { applyToBuffer, applyFromBuffer } from './utils.js';\n\nlet solver = new Solver();\nlet solveHandle = - 1;\n\n// List of all frames in the graph\nlet frames = null;\n\n// Buffer variants\nlet buffer = null;\nlet floatBuffer = null;\nlet byteBuffer = null;\n\nglobal.onmessage = function( { data: e } ) {\n\n\tconst { type, data } = e;\n\tswitch ( type ) {\n\n\t\t// The ik graph needs to be updated with all the deserialized\n\t\tcase 'updateStructure':\n\t\t\tframes = deserialize( data.serialized );\n\t\t\tsolver.roots = frames.filter( f => f.parent === null );\n\t\t\tsolver.updateStructure();\n\n\t\t\tbuffer = data.buffer;\n\t\t\tbyteBuffer = new Uint8Array( buffer );\n\t\t\tfloatBuffer = new Float32Array( buffer );\n\t\t\tbreak;\n\n\t\t// Update the settings of the solver\n\t\tcase 'updateSolverSettings':\n\t\t\tObject.assign( solver, data );\n\t\t\tbreak;\n\n\t\t// Start the solve loop\n\t\tcase 'startSolve':\n\t\t\tif ( solveHandle === - 1 ) {\n\n\t\t\t\tupdateSolve();\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Stop the solve loop\n\t\tcase 'endSolve':\n\t\t\tif ( solveHandle !== - 1 ) {\n\n\t\t\t\tclearTimeout( solveHandle );\n\t\t\t\tsolveHandle = - 1;\n\n\t\t\t}\n\t\t\tbreak;\n\n\t}\n\n};\n\n// The iterative solve loop\nfunction updateSolve() {\n\n\t// Copy any frame updates from the main thread\n\tapplyFromBuffer( frames, floatBuffer, byteBuffer, false, true );\n\n\t// Solve 1 iteration taking the most severe chain result\n\tconst result = solver.solve();\n\n\t// Copy the new DoF back to the shared buffer\n\tapplyToBuffer( frames, floatBuffer, byteBuffer, true, false );\n\n\tif ( result === SOLVE_STATUS.TIMEOUT ) {\n\n\t\t// yield so we can react to messages\n\t\tsolveHandle = setTimeout( updateSolve );\n\n\t} else {\n\n\t\tsolveHandle = - 1;\n\n\t}\n\n\tthis.postMessage( {\n\n\t\ttype: 'updateSolve',\n\t\tdata: result,\n\n\t} );\n\n}\n"]}